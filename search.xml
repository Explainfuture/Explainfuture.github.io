<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章！</title>
    <url>/2025/03/08/FirstBlog/</url>
    <content><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><ul>
<li><strong>运算器</strong>进行信息处理；</li>
<li><strong>寄存器</strong>进行信息存储；</li>
<li><strong>控制器</strong>协调各种器件进行工作；</li>
<li><strong>内部总线</strong>实现CPU内各个器件之间的联系。</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"1.png","alt":"img","title":""}]</div>
  </div>
<h2 id="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"><a href="#8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？" class="headerlink" title="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"></a>8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？</h2><p>把16位寄存器分成<strong>AH</strong>和<strong>AL</strong>两个独立的8位寄存器使用；<br>同样，32位或64位的寄存器也可以分，从而实现兼容性。<br>比如AX中现在存储0101010110101010，可以分为AH<strong>01010101</strong>和AL<strong>10101010</strong>来存储</p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="汇编指令-控制CPU完成的操作"><a href="#汇编指令-控制CPU完成的操作" class="headerlink" title="汇编指令                控制CPU完成的操作"></a>汇编指令                控制CPU完成的操作</h3><ul>
<li>mov ax,18                  将18送入AX</li>
<li>mov ah,78                  将78送入AH</li>
<li>add ax,8                   将AX中的值和8相加并把值存入AX</li>
<li>mov ax,bx                  将BX中的值赋值给AX</li>
<li>add ax,bx                  将AX和BX中的内容相加并把值存于AX<br><strong>注意：汇编指令不区分大小写，MOV也行</strong></li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"2.png","alt":"img","title":""}]</div>
  </div>
<p>在进行低八位运算的时候，比如最后一行85+93，结果等于158，但发生了溢出，只能显示58，1舍弃而不是进位到高位。</p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在存储空间中都有唯一的位置。8086CPU有20位地址总线，可传送20位地址，寻址能力为1MB（2的20次方）。8086是<strong>16位</strong>的CPU，16位地址表示的是地址总线的宽度，即CPU可以直接访问的地址范围。如果地址总线是16位，那么可表示的地址数量为2的十六次方&#x3D;65536个字节（即 64KB）。这意味着 CPU 最多只能寻址 64KB 的内存空间。<br>使用地址加法器将两个16位地址合成一个20位的物理地址。一个叫做<strong>段地址</strong>，另一个叫做<strong>偏移地址</strong>。<br><strong>段地址✖16 + 偏移地址 &#x3D; 物理地址，也称之为左移四位（二进制中），在十六进制里左移1位即可。</strong><br>最后得到的20位物理地址被地址总线传送到存储器里。<br>描述存储单元的方法（物理地址为21F60H，段地址为2000H，则偏移地址为1F60H）</p>
<ul>
<li>数据存放在内存2000：1F60单元中</li>
<li>数据存放在内存的2000段中的1F60H中</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"3.png","alt":"img","title":""}]</div>
  </div>]]></content>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2025/03/09/Thread/</url>
    <content><![CDATA[<h1 id="C-11多线程编程"><a href="#C-11多线程编程" class="headerlink" title="C++11多线程编程"></a>C++11多线程编程</h1><hr>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程就是正在运行的程序</li>
<li>线程就是进程中的进程</li>
<li>多线程可以提高效率。</li>
<li>线程的多少取决于CPU的<strong>核数</strong><br>如下图，如果是串行的话就必须顺序执行，但如果并行的话你就可以在同一时间内干多个事情。但同时要注意你的“<strong>核数</strong>”，你不能同时刷抖音和听音乐，因为你没有四个耳朵，亦或者说你的手机同一时间内只能处理一个应用播放声音。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread1.png" alt="图片"></li>
</ul>
<h1 id="C-11-Thread"><a href="#C-11-Thread" class="headerlink" title="C++11 Thread"></a>C++11 Thread</h1><ul>
<li>准备工具 Visual Studio</li>
<li>线程库 thread</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用thread创建一个线程"><a href="#使用thread创建一个线程" class="headerlink" title="使用thread创建一个线程"></a>使用thread创建一个线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HelloWorld&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行调试后，会得到下面结果：<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread2.png" alt="图片"><br>我们发现报错了，为什么会这样呢？</p>
<hr>
<p>可以理解为main里是<strong>主线程</strong>，一开始我们便创建了一个<strong>子线程</strong>，并让其执行PrintHelloWorld的函数。当<strong>子线程</strong>没有执行完毕的时候，主线程已执行完毕。<strong>主线程不会等待子线程执行完毕</strong>，可能子线程才执行到Hello，主程序已经return 0了，所以出现报错；<strong>所以说主线程和子线程是并发运行的！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;HelloworldMain&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
<p>当我们再次加入一行代码时发现，先输出的是<strong>主线程</strong>的HelloworldMain,接下来才是<strong>子线程</strong>的Helloworld。从这里我们可以看出：<strong>创建线程是需要时间的</strong>。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread3.png" alt="图片"></p>
<h2 id="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"><a href="#如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？" class="headerlink" title="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"></a>如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？</h2><h3 id="函数thread-join"><a href="#函数thread-join" class="headerlink" title="函数thread.join()"></a><strong>函数thread.join()</strong></h3><p>在 C++ 中，std::thread::join() 的作用是 等待<strong>子线程执行完毕</strong>，然后<strong>主线程才继续执行</strong>。如果没有 join()，主线程可能会在子线程执行完成之前就结束，导致未定义行为程序报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworldMain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当我们添加了thread1.join()之后，相当于告诉主线程：“大哥你先等我弄完你再往下走，别丢下我！” （<strong>演示注释掉thread1.join()的情况</strong>）<br>join的作用是：<strong>确保子线程完成</strong>，执行顺序可控，但是会<strong>阻塞</strong>主线程，直到子线程完成。<br>阻塞示例 （joinable()用于判断线程是否可以使用join函数，返回的是一个bool值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread1</span><span class="params">(print)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (thread<span class="number">1.</span><span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数thread-detach"><a href="#函数thread-detach" class="headerlink" title="函数thread.detach()"></a><strong>函数thread.detach()</strong></h3><p>让子线程“脱离”主线程，主线程不再管理它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>你可以干你的事情，我也可以干我的事情，不管你了。像请客吃饭，请客的人把单买了之后说我先走一步，你们随意。对比上面的阻塞，我们发现detach是<strong>并发</strong>的。</p>
]]></content>
      <categories>
        <category>c++多线程</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread2</title>
    <url>/2025/03/09/Thread2/</url>
    <content><![CDATA[<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><h2 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h2><p>当多线程去共享同一个数据的时候，会造成争夺</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码发现，a的值没有如我们预期所认为是20000，而是随机的数字。这是因为线程在读取同一个数据的时候发生了争夺。<br>解决办法：当一个线程拿了数据，其他线程禁止拿，也就是互斥锁：线程访问共享资源前，先<strong>加锁</strong>（lock），用完后<strong>解锁</strong>（unlock）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>(); <span class="comment">//在这个线程即将访问数据的时候上锁</span></span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//在访问完成后解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多线程安全：如果多线程程序每一次的运行结果和单线程运行的结果是一样的，那么你的线程就是安全的。</strong></p>
<h2 id="互斥量死锁"><a href="#互斥量死锁" class="headerlink" title="互斥量死锁"></a>互斥量死锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法，当某个线程获取到了m1，那就让他获取m2，按照这样的规则，所有的线程都得先有m1才有m2，那其他线程拿不到m1自然也拿不到m2，所以调换func_2的m1、m2顺序即可。</p>
<h2 id="lock-guard与unique-lock"><a href="#lock-guard与unique-lock" class="headerlink" title="lock_guard与unique_lock"></a>lock_guard与unique_lock</h2><p>std::lock_guard是C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p>
<ul>
<li>当构造函数被调用时，该互斥量会被<code>自动锁定</code></li>
<li>当析构函数被调用时，该互斥量会被<code>自动解锁</code></li>
<li>std::lock_guard对象不能复制或移动，因此它<code>只能在局部作用域中使用</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lg</span>(mtx);</span><br><span class="line">		shared_data++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock_guard<mutex>lg(mtx)的作用就相当于mtx.lock() 且 mtx.unlock().<br>有五个用法：</mutex></p>
<h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="手动解锁"><a href="#手动解锁" class="headerlink" title="手动解锁"></a>手动解锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 提前解锁</span></span><br><span class="line">    <span class="comment">// 此处不再受互斥锁保护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="延迟加锁"><a href="#延迟加锁" class="headerlink" title="延迟加锁"></a>延迟加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;  <span class="comment">// 不自动加锁</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();  <span class="comment">// 需要时再手动加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="尝试加锁"><a href="#尝试加锁" class="headerlink" title="尝试加锁"></a>尝试加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;  <span class="comment">// 判断是否加锁成功</span></span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 锁未获取成功，执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁转移"><a href="#互斥锁转移" class="headerlink" title="互斥锁转移"></a>互斥锁转移</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx)</span></span>;  <span class="comment">// 获取锁</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock2 = std::<span class="built_in">move</span>(lock1);  <span class="comment">// lock1 转移给 lock2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311104759163.png" alt="生产者与消费者"><br>生产者与消费者模型可以这样比喻：生产者是小鸡，任务队列是鸡蛋篮子，消费者是饲养员。有源源不断的任务从生产者发出，由消费者解除，也类似于银行排队系统。<br>当任务队列为<strong>空</strong>的时候，消费者无法去取任务，因此会进入<strong>等待</strong>的状态。那此时老板会下发任务，如何让消费者知道有任务？需要<strong>通知</strong>，让消费者知道我该往里面取任务了。<br>condition_variable有两种</p>
<ul>
<li>notify_one 唤醒消费者中的<em>一个线程</em>来干活</li>
<li>notify-all 唤醒消费者中的<em>所有线程</em>来干活<br><strong>区别在于：通知只发一次，但是对象不同，唤醒一条线程和所有线程的区别</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt;g_queue;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait函数g_cv.wait(lock, predicate)的作用：</p>
<ul>
<li>当前线程进入等待状态，直到 predicate 返回 true，也就是说第二个判断条件是true就往下执行</li>
<li>lock 是一个 std::unique_lock<a href="std::mutex">std::mutex</a>，用于保护临界区资源。</li>
<li>predicate 是一个 Lambda 表达式，返回 true 时线程继续执行，否则会一直等待。<br>两个代码是等价的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!g_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 条件不满足，释放 lock 并进入等待状态</span></span><br><span class="line">    g_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条件满足，继续执行后续代码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 g_queue 为空时，线程会阻塞（等待）。</li>
<li>当 g_queue 非空时，线程继续执行，不会进入等待状态。</li>
</ul>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>除了可以用互斥锁来维护共享变量外，还可以通过原子操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">std::atomic &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在初始化的时候，不允许使用<code>std::atomic&lt;int&gt; a = 0</code>，因为原子操作不允许拷贝复制，应该用默认的构造函数<code>std::atomic&lt;int&gt; a(0)或std::atomic&lt;int&gt; a&#123;0&#125;</code><br>把共享的数据设置为原子变量，更好地维护线程安全，还可以提升运行速度。</p>
<p>小班演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_queue;  <span class="comment">//容器要包含类型</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();  <span class="comment">//每次加任务的时候通知一下</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		flag++;</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Comsumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Comsumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11跨平台线程池"><a href="#C-11跨平台线程池" class="headerlink" title="C++11跨平台线程池"></a>C++11跨平台线程池</h1>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Practise</title>
    <url>/2025/03/10/C-Practise/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="auto：在C-中，auto可以自动推导类型。"><a href="#auto：在C-中，auto可以自动推导类型。" class="headerlink" title="auto：在C++中，auto可以自动推导类型。"></a>auto：在C++中，auto可以自动推导类型。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//有两种方式可以遍历STL容器</span></span><br><span class="line">- <span class="keyword">for</span> (std::vector::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">- <span class="keyword">for</span> (<span class="keyword">auto</span> vtest : v)</span><br></pre></td></tr></table></figure>
<p>&amp;为引用，加&amp;与否取决于是否要修改原值或避免拷贝</p>
<ul>
<li>需要修改并输出修改后的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 = v1<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;v1&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>建议都加std::</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(n,c)</span>  <span class="comment">//可以生成一个包含n个c的字符串。</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string a.<span class="built_in">find</span>() <span class="comment">//可以找一个你想要东西的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">abbrevName</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[<span class="number">0</span>]);</span><br><span class="line">  s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[name.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)<span class="number">+1</span>]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL——set"><a href="#STL——set" class="headerlink" title="STL——set"></a>STL——set</h3><p>set 有insert，erase，count，find,size等用法，通常用于查找的时候不用find（因为要返回迭代器的值），而是用count，set底层是红黑树，可以实现自动除重，比如insert(6)两次，只会有一个，所以count()的值只会是0和1；用于判断是否存储在里面。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312112552261.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">insert</span>();</span><br><span class="line">set.<span class="built_in">erase</span>();</span><br><span class="line">set.<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure>
<p>unordered_set和set大体上一样，但是是用哈希表实现的，所以里面是无序的，但是查找很快,O(1)级，set的查找是O(logN);</p>
<p>set插入vector的元素很方便，使用迭代器，同时通过assign分配新值给nums替换旧值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; <span class="built_in">s</span> (nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">		nums.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span> nums.<span class="built_in">size</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ns = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n!=ns) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>判断前后两次的size是否相同，不同则有重复插入。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一个映射，由Key-&gt;Value，内部是用pair实现。<br>常见的用法有</p>
<ul>
<li>m[] &#x3D; ;</li>
<li>m.erase();</li>
<li>m.count(); &#x2F;&#x2F;用于查找有没有值，return1&#x2F;0;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312120338656.png"><br>可以看到map也像set一样会自动排序，且后来者会覆盖，count返回的是0和1。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外层循环a.size()-1次，内层循环a.size()-i-1次;加引用和不加引用的区别在于：<strong>通过引用传递，函数内部对向量的修改会直接反映在原始向量上，这正是冒泡排序需要的效果，即直接在原数组上排序。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;a[j<span class="number">+1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[j<span class="number">+1</span>];</span><br><span class="line">				a[j<span class="number">+1</span>] = a[j];</span><br><span class="line">				a[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一种<strong>数据类型</strong>，在32为系统性size &#x3D; 4，64 &#x3D; 8.指针存放的是内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>意思是p指针现在存储的是a的地址，可以使用解引用号<em>来访问*<em>p存储的这个地址的值</em></em>。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>const为常量，加在指针前就称之为常量指针 const int *p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;a;</span><br><span class="line">*p = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p><strong>这是一个非法的操作</strong>，常量指针可以<strong>改变指向的地址</strong>，但<strong>不能改变指向地址的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>
<p>这是一个合法的操作，现在p指向的就是b的地址。</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>指针常量和常量指针作用刚好相反，要这样理解：<strong>const后面跟着谁谁就无法改变</strong>，在指针常量中，int *const p，const后面跟着的是地址，所以地址就不能改；在常量指针中，const int *p，const后面跟的是int值，所以值不可以改。<br>所以当const int *const p两个都不可以改。快速记忆：遇到英文翻译中文，const int *p,const是常量，后面是指针，所以常量指针;int *const p,先遇到指针，再遇到常量，所以叫指针常量。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用就是取别名，本质是指针，让b的地址和a的地址相同，但记住在这里引用类似于常量指针，不允许再更改成其他的地址了，但可以改值。<strong>引用必须初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>
<h3 id="引用不要返回局部变量"><a href="#引用不要返回局部变量" class="headerlink" title="引用不要返回局部变量"></a>引用不要返回局部变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次的时候可以正常输出10，但第二次就不行了，因为局部变量存放在栈区，会被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static关键字让他是静态变量，存放在<strong>全局区</strong>，全局区上的数据在程序结束后释放。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类有<strong>属性</strong>和<strong>行为</strong>，比如一个学生类，属性就是学生的名字&#x2F;学生的学号，行为就是打印出名字和学号，也可以用行为来给学生的属性赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_num;</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;m_num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员私有化之后可以实现只读&#x2F;只写&#x2F;可读可写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_age = <span class="number">18</span>;</span><br><span class="line">		string m_name;</span><br><span class="line">		string m_lover;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (age&gt;<span class="number">150</span>||age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m_age = age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student s;</span><br><span class="line">	s.<span class="built_in">set_age</span>(<span class="number">160</span>);</span><br><span class="line">	s.<span class="built_in">get_age</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_x = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_y = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_y;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_x;</span><br><span class="line">		<span class="type">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_r</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_r = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_center</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_center = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">point <span class="title">getm_center</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_center;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_r;</span><br><span class="line">		point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Relation</span><span class="params">(circle &amp;c,point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dx = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_x</span>()-p.<span class="built_in">getm_x</span>();</span><br><span class="line">	<span class="type">int</span> dy = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_y</span>()-p.<span class="built_in">getm_y</span>();</span><br><span class="line">	cout&lt;&lt;dx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dy;</span><br><span class="line">	<span class="type">int</span> rdistance = c.<span class="built_in">getm_r</span>()*c.<span class="built_in">getm_r</span>();</span><br><span class="line">	<span class="type">int</span> distance = dx*dx+dy*dy;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (distance==rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆上&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(distance&gt;rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆外&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;在圆内&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	point p;</span><br><span class="line">	circle c;</span><br><span class="line">	c.<span class="built_in">setm_r</span>(<span class="number">10</span>);</span><br><span class="line">	point center;</span><br><span class="line">	center.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	center.<span class="built_in">setm_y</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">setm_center</span>(center); </span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	p.<span class="built_in">setm_y</span>(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Relation</span>(c,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>没有返回值，不用写void，函数名与类名相同，构造函数可以有参数，可以发生重载，创建对象的时候会自动调用，而且只调用一次。<br>析构函数前加一个~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;构造&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;析构&quot;</span>;</span><br><span class="line">	 &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	person p1;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以省略冗余的代码，继承父类。<br>继承语法： class 子类 : 继承方式 父类<br>class cpp : public header<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183703034.png">;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183742270.png">;<br>子类可以缩小权限范围，但不能扩大权限范围。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321191947414.png"></p>
]]></content>
  </entry>
  <entry>
    <title>算法（一）</title>
    <url>/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><p>介绍常用的算法</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有三个关键量，right、left、middle；<code>middle = (right - left)&gt;&gt;1</code>，其中<code>&gt;&gt;</code>为右移运算符，将right - left结果的二进制位向右移一位，&gt;&gt;n右移n位，举个例子</p>
<ul>
<li>8 - 4 &#x3D; 4，4的二进制位为0100，右移一位变为0010，代表十进制2。</li>
<li>7 - 2 &#x3D; 5，5的二进制位为0101，右移一位变为0010，代表十进制2。<br>可以看出，右移运算符的作用是<code>将两数相减并向下取整得到结果</code><br>为什么要用右移运算符而不用&#x2F;2？</li>
<li>右移运算 &gt;&gt; 通常比除法 &#x2F; 更快，因为位运算是底层硬件直接支持的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left)&gt;&gt;<span class="number">1</span>); <span class="comment">//left每一次加上新的中间值</span></span><br><span class="line">			<span class="keyword">if</span> (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&lt;target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</strong><br><strong>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</strong><br>采用二分法，注意停止条件，当left&gt;right就停止了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (right&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> p = <span class="number">1.0</span>*middle*middle;</span><br><span class="line">            <span class="keyword">if</span> (p==x) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span> (p&lt;x)&#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311182900217.png"></p>
<h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><p>滑动窗口类似于双指针，用于去求最短子序列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311202740831.gif"><br>j是终止位置，很像毛毛虫往前拱，吃到了，然后尾巴再上来。<br>LeetCode 209</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum&gt;=target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                x = x &gt; subLength ? subLength : x;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == INT32_MAX? <span class="number">0</span> : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口例题2<br>The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:</p>
<p>maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4});<br>&#x2F;&#x2F;should be 6: {4, -1, 2, 1}<br>Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</p>
<p>Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist&#x2F;subarray.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSequence</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, maxSum = <span class="number">0</span>;  <span class="comment">// 初始化最大和为 0（符合题目要求）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; arr.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">        sum += arr[right];  <span class="comment">// 扩展窗口</span></span><br><span class="line">        </span><br><span class="line">        maxSum = std::<span class="built_in">max</span>(maxSum, sum);  <span class="comment">// 更新最大子数组和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前窗口的和变成负数，移动左指针</span></span><br><span class="line">        <span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的一步在while(sum&lt;0),会把之前为负数的窗口给舍弃掉，1 + -3 &#x3D; -2，-2 -1 &#x3D; -3，left左移动一位，-3 -（-3） &#x3D; 0，left左移一位，所以left变成了3；从3又继续开始遍历。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>说实话贪心算法并没有固定的套路。<br><strong>所以唯一的难点就是如何通过局部最优，推出整体最优。</strong><br>LeetCode455<a href="https://leetcode.cn/problems/assign-cookies/">分饼干</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g.<span class="built_in">size</span>()==<span class="number">0</span>||s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span> (s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span> (g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;g.<span class="built_in">size</span>()&amp;&amp;j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]&lt;=s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>计算机系统</title>
    <url>/2025/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h2><h3 id="80386通用寄存器"><a href="#80386通用寄存器" class="headerlink" title="80386通用寄存器"></a>80386通用寄存器</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312130401047.png"></p>
<ul>
<li>%ax :accumulate 累加寄存器</li>
<li>%bx :base 基址寄存器</li>
<li>%cx :count 计数寄存器</li>
<li>%dx :divide 放除法的商和余数</li>
<li>%eax : extend 扩展 表示32位的寄存器<br>%eax表示32位寄存器，%ax表示低16位，在低16位的寄存器中：%ah表示高八位，%al表示第八位</li>
</ul>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="1005-s-立即数寻址"><a href="#1005-s-立即数寻址" class="headerlink" title="1005.s 立即数寻址"></a>1005.s 立即数寻址</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312134223502.png"><br>movl $8,%eax; </p>
<ul>
<li>$是立即数，表示8</li>
<li>movl是移动的意思，将8赋值给%eax；<br>最终的运行结果如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312140455507.png"></li>
</ul>
<hr>
<h4 id="1006-s-寄存器寻址"><a href="#1006-s-寄存器寻址" class="headerlink" title="1006.s 寄存器寻址"></a>1006.s 寄存器寻址</h4><ul>
<li>movl 用于传送<strong>32</strong>位的长子值</li>
<li>movw 用于传送<strong>16</strong>位的子值</li>
<li>movb 用于传送<strong>8</strong>位的子值<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312141244989.png"><br><strong>不能把movw的w改为l，因为%bx是16位的寄存器，如果改为l试图把32位的传给16位是错误的</strong>。可以写mov &#x2F; movw<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312174829067.png"><br>命令为 movw $0x5678,%dx ; 意思是传16个字节(w)的数据到寄存器dx里，结果如我们所愿，如果用%dh&#x2F;%dl便会报错，因为%dh&#x2F;%dl是8位的寄存器;同样，也不能movw $0x5678,%edx，因为edx是32位的，所以只能写32位的地址。如下图，所以要用对应的寄存器和对应位数的mov指令或只写mov去传递数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312175249233.png"></li>
</ul>
<h4 id="1007-s-绝对寻址（直接寻址）"><a href="#1007-s-绝对寻址（直接寻址）" class="headerlink" title="1007.s 绝对寻址（直接寻址）"></a>1007.s 绝对寻址（直接寻址）</h4><p>movl 0x08048054,%exc，直接把这个内存地址赋给%exc。可以使用x&#x2F;4bx 08048054来查看以8054起的四个地址内容。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190744306.png" alt="查看内存内容"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190225523.png"><br>内存之中<strong>既可以存放数据，也可以存放指令</strong>。如图，b9是指令，从后往前看08、04、80、55就是数据。</p>
<h4 id="1008-s-间接寻址"><a href="#1008-s-间接寻址" class="headerlink" title="1008.s 间接寻址"></a>1008.s 间接寻址</h4><p>movl (%ebx),%eax 和寄存器寻址的区别在于第一个寄存器套上了括号，表示不是把寄存器%ebx的值赋给%eax，而是寄存器存放的数据的地址存放的内容赋给%eax。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191539026.png"><br>第一步，立即数寻址，把立即数08048054放到%ecx<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191713316.png"><br>第二步，查看08048054内存中存放的数据是什么，并将其传入<strong>16位</strong>的%ax中，得到结果0x8056，为什么是8056？因为56是低位，80是高位</p>
<h4 id="1009-s-变址寻址"><a href="#1009-s-变址寻址" class="headerlink" title="1009.s 变址寻址"></a>1009.s 变址寻址</h4><p>movl (%ebx,%edx),%eax 在1008的基础上，把括号内两个寄存器的值加起来，用这个内存地址去找里面的数据，然后把数据传给%eax。</p>
<h4 id="1010-s-比例变址寻址"><a href="#1010-s-比例变址寻址" class="headerlink" title="1010.s 比例变址寻址"></a>1010.s 比例变址寻址</h4><p>movl (%ebx,%ecx,0x2),%eax<br>%ebx为基址，%ecx与第三个参数(第三个参数只能为1，2，4，8，左移运算符)<strong>相乘</strong>并与基址相加，最后赋值给%eax。</p>
<h4 id="1012-s-获取变量在内存的地址"><a href="#1012-s-获取变量在内存的地址" class="headerlink" title="1012.s 获取变量在内存的地址"></a>1012.s 获取变量在内存的地址</h4><p>leal 5(%edx, %edx, 2), %eax   &#x2F;&#x2F;假设%edx的值为x, 这行代码会将%eax的值设置为”3x+5″.</p>
<h4 id="1013-s-栈操作指令"><a href="#1013-s-栈操作指令" class="headerlink" title="1013.s 栈操作指令"></a>1013.s 栈操作指令</h4><p>栈：先进后出<br>栈顶指针：保存在%esp寄存器中<br>压栈push出栈pop<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325154443719.png"><br>栈是往低处生长的。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155048996.png"><br>e0-4 &#x3D;dc 栈顶指针往前偏移了<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155207739.png"><br>压栈后栈顶现在存放的是88888888</p>
<h4 id="1014-s-跳转指令"><a href="#1014-s-跳转指令" class="headerlink" title="1014.s 跳转指令"></a>1014.s 跳转指令</h4><p>直接跳转指令</p>
<ul>
<li>jmp lable</li>
<li>jmp 0x0804909a</li>
<li>jmp *%eax</li>
<li>*lable<br>条件跳转指令<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325161023037.png"></li>
</ul>
<h2 id="数的表示与处理"><a href="#数的表示与处理" class="headerlink" title="数的表示与处理"></a>数的表示与处理</h2><h3 id="整数表达"><a href="#整数表达" class="headerlink" title="整数表达"></a>整数表达</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172553621.png"><br>无符号整数就是大于等于0的数，4为无符号整数的取值范围为0-15。</p>
<h4 id="补码形式"><a href="#补码形式" class="headerlink" title="补码形式"></a>补码形式</h4><p>最高位的权重是负数<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172840669.png"><br>具体例子如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172941441.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173019514.png"><br>对于相同的数，映射关系不同，得到的数也不同，下图是有符号数和无符号数的例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173154420.png"></p>
<h4 id="无符号数与有符号数的转换"><a href="#无符号数与有符号数的转换" class="headerlink" title="无符号数与有符号数的转换"></a>无符号数与有符号数的转换</h4><p>他们的二进制表示都相同，但如果是有符号数的话，第一位会乘负权重；如果是无符号数就是正常。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173537847.png"></p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>无符号数加法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325175049195.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Network</title>
    <url>/2025/03/19/Network/</url>
    <content><![CDATA[<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><p>The following content is about the basic knowledge of computer network.</p>
<h2 id="Breif-introduction"><a href="#Breif-introduction" class="headerlink" title="Breif introduction"></a>Breif introduction</h2><p>Such as smartphone, tv, safe system, car and so on.All of this are called <strong>host</strong> or <strong>end system</strong>. The end system is linked by <strong>communication link</strong>(通信链路) and <strong>packet switch</strong>(分组交换机).<br>Different communication links such as <strong>电缆、光纤、无线电频谱</strong> can spread the data with different speed. The transmission rate are measured by <strong>bit&#x2F;s or bps</strong>.These message packet(信息包) are called <strong>packet</strong>(分组).<br><em>The packet seems like truck, all of the truck trans the goods to the destination by highspeed road. The communication links like the road, the packet like the truck, and the packet switch like the fork in the road, and the end system like the building.</em><br>The end system connect the Internet by <strong>ISP</strong>(Internet Service Provider).<br>The end system, packet switch and the other part of Internet are <strong>following a series of protocol</strong>(协议). <strong>These protocols control the internet message’s receive and send</strong>. Such as TCP(Transmission Control protocol，传输控制协议) and IP(Internet protocol,网际协议) are <strong>the most important protocols in the internet</strong>.IP protocol defines the rules of sending and receiving message winin router and end system.The main protocol of Internet is called <strong>TCP&#x2F;IP</strong>.<br><strong>A socket interface</strong>(套接字接口) refers to a programming interface that allows communication between different computer systems over a network. For example, you want to write a letter for your friend, you can’t just write the letter and throw it out of the window and think he&#x2F;she can receive it. You need to put the letter into the envelop and write the full name, address, and postcode of your friend. Close the envelop and post a stamp and throw it into the post office. So all of these are the socket interface of postface, you need to obey it so that you can send your letter.</p>
<h2 id="What-is-protocol"><a href="#What-is-protocol" class="headerlink" title="What is protocol?"></a>What is protocol?</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319181124581.png"><br>Let’s begin at the human protocol. If you want to  say hi to the other, you need to first say ‘hi’ and wait for his response. If he gives your certain response, you can continue say what your want. But if he does’t want to response you, you can’t continue your work.<br>Now look at the picture, you tap the web’s url. You computer send a connection request message to the Web server and wait for the respond. The Web server receives that and return a connection response message. Then the computer sends a GET message, declaring what it wants to fetch from the Web server.<br>So the protocol defines the message’s format and order between two or more than two communication entity, and sending or receiving a message or something else.</p>
<h2 id="The-media"><a href="#The-media" class="headerlink" title="The media"></a>The media</h2><p>A bit from a series of connection link and router can arrive at the other end system. Each <strong>send-receive couple</strong> send the electromagnetic and pulse through a physical media. Such as 双绞铜线，同轴电缆，多模光纤缆. The physical media has two types: the guided media and the unguided media. For the first one, The waves go along with the solid media like 光缆，双绞铜线或同轴电缆.For the other, the waves spread through air or outter space. Such as WLAN or digital satellite channels.</p>
<h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185139123.png"></p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185234778.png"></p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185333613.png"></p>
<h3 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a>陆地无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185413035.png"></p>
<h3 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185439185.png"></p>
<h2 id="The-kernel-of-network"><a href="#The-kernel-of-network" class="headerlink" title="The kernel of network"></a>The kernel of network</h2><p>In various network application, the end system(also called host) exchanges messgae to each other. The messgae can implement a control function or contain the data. For sending a message to the destination host, the source end system cuts the long message into the little data brick. This operation called packet. Every packet can be transmited by connection link or packet switch between the source and destination. The time of transmiting is the length of bits(R) dividing the rate of connection link(R). So the time is (L&#x2F;R).</p>
<h3 id="packet-exchange"><a href="#packet-exchange" class="headerlink" title="packet exchange"></a>packet exchange</h3><p><strong>store and forward transmission</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191400491.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191419708.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191428022.png"><br><strong>The queuing delay and packet loss</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191821692.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191916889.png"><br><strong>The forwarding table and routing protocol</strong><br>The router gets the packet from a connection link linked to it, but how does it know where to trans the packet to the destination?<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319192733925.png"></p>
<h2 id="The-Internet-of-Internet"><a href="#The-Internet-of-Internet" class="headerlink" title="The Internet of Internet"></a>The Internet of Internet</h2><p>Lots of ISPs connect with each other, the low-level ISP connect to the high ISP. <strong>Peer to Peer(对等，两个运营商传输和接收尽量相同的bits，不让对方赚钱)</strong><br>IXP(Internet Exchange Point) is a meeting point, the peer ISP does’nt pay the extra fees.<br><strong>多宿(别吊死在一棵树上)</strong>:low-level ISP seeks for higher ISP to connect to make sure its capacity of connection. It can avoid the trouble caused by one of the ISP, it can use the other ISP.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319195757272.png"></p>
<h2 id="Time-Delay"><a href="#Time-Delay" class="headerlink" title="Time Delay"></a>Time Delay</h2><p>We have four types of time delay.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201045033.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201115287.png"><br><em>dtotal &#x3D; dproc + dqueue + dtrans + dprop</em></p>
<h2 id="Five-protocols"><a href="#Five-protocols" class="headerlink" title="Five protocols"></a>Five protocols</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319203624856.png"><br>我说张三你是帅哥，张三的身体是主机，耳朵是端口，我选择只传输给张三一个人，然后选择走哪条路（连接层就是链路层），如果他在泰国人就可以飞机过去，在国内就火车过去，电信号就通过电缆过去，最后物理层传输。</p>
<h1 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h1><p>There are two types of appliication architectures, one is <strong>client-server architecture</strong>, and the other is P2P.</p>
<h2 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h2><p>A forever-opening host is called <em>server</em>. It serves lots of other client hosts’ request. When the server receives the request for a objection form a client, it sends the objection back as the response. When we are in the client-server architecture, the client can’t communicate with the other client. Just like the two webserver can’t communicate with each other. The sever has a solid, well-known ip, and is forever-opening. So client can always send packets to the ip to communicate with it. In this system, the famous application includes the Web, FTP, Telnet and E-mail. In general, a single sever host can’t content all of the requests. So <strong>data center</strong> which has lots of hosts is used to create strong virtual server.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320113426164.png"></p>
<h2 id="Process-Communication"><a href="#Process-Communication" class="headerlink" title="Process Communication"></a>Process Communication</h2><p>In operating system, actually communicaition is a process instead of application. The processes in two different end system send message to communicate through computer network. The sending message process generates and sends the message to the net. The receiving process receives the message, and maybe send the message back to response. </p>
<h3 id="The-client-and-sever-process"><a href="#The-client-and-sever-process" class="headerlink" title="The client and sever process"></a>The client and sever process</h3><p>The web applications consist of couple of process. In Web application, a client webserver process exchanges the message with the Web server process. For each group of communication process, <strong>a process is called client, and the other is called server</strong>.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320114830448.png"></p>
<h3 id="The-process’s-interface-of-computer-network"><a href="#The-process’s-interface-of-computer-network" class="headerlink" title="The process’s interface of computer network"></a>The process’s interface of computer network</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115300248.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115304351.png"></p>
<h3 id="Process-Find-Address"><a href="#Process-Find-Address" class="headerlink" title="Process Find Address"></a>Process Find Address</h3><p>If we want wo send a letter to the destination, the destination needs to have an address. A host’s process sends packet to another host’s process. We need to define two label: ①The address of host;②The destination host’s receiving process’s identifier.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115840795.png"></p>
<h2 id="Four-factors-of-transmission-serve"><a href="#Four-factors-of-transmission-serve" class="headerlink" title="Four factors of transmission serve"></a>Four factors of transmission serve</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120312829.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120317239.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120323470.png"></p>
<h2 id="Transmission-Layer-Protocol"><a href="#Transmission-Layer-Protocol" class="headerlink" title="Transmission Layer Protocol"></a>Transmission Layer Protocol</h2><p>TCP &#x2F; UDP<br>TCP和UDP之间的区别与联系：就像打电话和写信，你打电话能知道他是谁，打给谁，挂断之后即时有反馈，而写信在你寄出去的一瞬间你不能确保信是否会寄到他那里，以及什么时候才能寄到，信的内容是否完整（丢包）。UDP就是用于可以容忍一点点丢包，比如实时竞技游戏，视频通话。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>A：是B吗？我要跟你通信，听得到我说话吗？<br>B：可以通信，你听得到我说话吗？<br>A：我也听得到。</p>
<p><em>其实二次握手就可以建立链接，三次握手是为了互相确认对方的序列号，四次挥手是因为服务端有未发送完的数据。所以需要服务端连续发两次。同时客户端最后的等待也是为了确保服务端收到ASK请求fin<del>ask</del>fin~ask,如果过了等待时间则认为服务端已经关闭（没有关闭的话会有ASK）</em></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>C：我困了，先不聊了吧<br>S：还有几件事，说完我们就睡觉……<br>……（说完之后）<br>S：好了，说完了，我挂线了<br>C：好，你挂吧<br>S挂断电话<br>C说完之后就直接睡觉了，不知道电话挂没挂断，在几分钟后听到手机没有声音传来了，即使不用睁眼也知道S挂断了</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http(HyperText Transfer Protocol)<br>HTTP（超文本传输协议）是互联网上用来传递信息的一种规则。可以把它想象成一种通讯方式，它定义了如何发送和接收网页内容，比如文本、图片和视频等。想象一下，当你在网上浏览器里输入一个网址或点击一个链接时，你的浏览器就通过HTTP向网站的服务器发送一个请求，就像是在说：“嘿，我想看这个网页。”服务器收到这个请求后，如果网页可用，它就用同样的HTTP规则回应，发送网页的内容回来。简单来说，HTTP像是你和网站之间的对话规则，确保双方都能理解对方发送的消息。这就是你能够浏览网页和观看在线视频的原因之一。若想<strong>高效识别用户</strong>，引入了cookies，cookies就像门禁卡，我新建了一个房子，刚开始来的给一张卡刷进来，后面来的时候就拿着这张卡，网页就可以识别到你这个人做了什么。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320132409503.png"></p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>链路层协议的任何设备均成为<strong>节点</strong>，节点包括主机、路由器、交换机、和WIFI接入点。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320135508535.png"><br>数据链路层有三个重要的问题：封装成帧、差错检测、可靠传输。</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320140209418.png"></p>
]]></content>
  </entry>
  <entry>
    <title>FindJob</title>
    <url>/2025/03/20/FindJob/</url>
    <content><![CDATA[<h2 id="这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。"><a href="#这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。" class="headerlink" title="这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。"></a>这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。</h2><p>2025.3.20 回顾指针，常量指针，指针常量，引用，内存访问，结构体指针（地址传参和值传参）。</p>
]]></content>
  </entry>
  <entry>
    <title>论文笔记</title>
    <url>/2025/03/28/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>COFFEE<br>c:cross-layer optimization for fast and efficient executions of the SK algorithm on HPC systems with clusters of compute nodes<br>在有计算节点集群的HPC系统上快速高效执行SK算法。<br><strong>算法中：行、列都可以重新缩放</strong>，<strong>列缩放相较行缩放极其缓慢</strong>。<br>在多节点上的性能比单节点提升最高7.5倍，平均2倍；与天河一号的MPI Allreduce算法比，最高2.9，平均1.6.<br>SK算法：a simple but very useful iterative method to approach the double stochastic matrix of Sinkhorn’s theorem by alternately rescaling all rows and all columns of the given matrix.<br>对矩阵进行缩放列。</p>
<p>现存的SK算法大多用去搞强化学习了（应用层），或者去加速收敛，很少有研究从计算机系统架构的角度考虑改进算法，特别是高性能计算（HPC）系统。HPC有他自己独特的计算、存储以及交流能力，看看是否能发挥全部潜力。SK算法在四个代表性应用的时间占比都超过一半（BALS的卷积也这样）所以就去优化。</p>
<p><strong>这篇论文用MPI，通过多核、多节点集群加速SK算法。</strong><br>先分析经典算法在天河1上。<br>列缩放的时间远超行缩放，原因是<strong>通过列缩放进行的内存访问是高度非连续的，这导致了较高的缓存未命中率。</strong><br>解决方法：<strong>探险重新设计列缩放以及信息阻塞</strong>去减少缓存未命中；设计微核并且重新设计指令去<strong>增加并行性</strong></p>
<p>优化思想：通用矩阵乘法、分层<br>分层的思想在MPI Allreduce算法（MPI_Allreduce 是 MPI（消息传递接口）中的一个函数，用于在所有进程之间<strong>进行归约操作并广播结果。</strong>）的相关优化中非常常见。</p>
<p>选择SALaR（？）作为基准去研究。发现：实现Allreduce可以与SK算法的其他任务进行overlap（重叠）进一部提高性能   </p>
<h2 id="本篇文章的主要contribution"><a href="#本篇文章的主要contribution" class="headerlink" title="本篇文章的主要contribution"></a>本篇文章的主要contribution</h2><ul>
<li>我们分析了 SK 算法在 HPC 集群上的执行行为，并观察到两个主要的性能挑战。首先是其列重新缩放表现出高度非连续的内存访问模式，这导致非常高的缓存未命中率，从而大大降低了整体性能。第二，即使采用 Foster 的方法设计，列重新缩放也会严重限制并行性</li>
<li>我们提出了 COFFEE，这是一种新颖的方法，它实现了多级优化设计，以优化 HPC 系统中大规模 SK 算法的处理（第 IV 节）。我们通过增强 MPI Allreduce 来提高并行效率，采用有效的领导者-工作者机制，尽可能重叠节点间(intra-node)通信、节点内通信和节点内计算</li>
<li>我们在天河一号超级计算机上评估了 COFFEE 的原型实现，证明了其与 SOTA 解决方案相比具有显著的性能优势（第六节）。我们的实验结果表明，COFFEE 分别在单节点和多节点环境中带来了高达 7.5 倍和 2.9 倍的性能提升。</li>
</ul>
<h2 id="SK算法"><a href="#SK算法" class="headerlink" title="SK算法"></a>SK算法</h2><p>双随机矩阵,sk算法就是在行列都归一化后，每行元素相加都为1，每列元素相加也都为1<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328202355119.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sinkhorn</span>(<span class="params">A, max_iter=<span class="number">1000</span>, tol=<span class="number">1e-6</span></span>):</span><br><span class="line">    A = np.array(A, dtype=np.float64)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        A_prev = A.copy()</span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 行归一化</span></span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 列归一化</span></span><br><span class="line">        <span class="keyword">if</span> np.allclose(A, A_prev, atol=tol):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">A = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">3</span>, <span class="number">4</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>]])</span><br><span class="line">B = sinkhorn(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Row sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Col sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328203003067.png"></p>
<p>选SK算法而不是和其他算法有两重原因：</p>
<ul>
<li>现在主流的线性代数库（如 BLAS、NumPy、PyTorch 等）在进行矩阵乘法时，底层通常使用的是最基础的“三重循环”实现方式，而不是像 Strassen 或 Coppersmith-Winograd 这样的快速乘法算法。就像基本的矩阵乘法实现一样，最原始的 Sinkhorn-Knopp（SK）算法也<strong>更容易从计算机系统架构的角度进行优化</strong>。</li>
<li>现有的 SK 算法研究主要集中于通过<strong>减少矩阵缩放迭代次数</strong>来加快收敛速度​​，但我们的目标是<strong>减少每次迭代的时间</strong>。</li>
</ul>
<p>我们不再去限制每一行&#x2F;每一列的和接近1，而是去最后计算的时候让行&#x2F;列和为1，在计算结果之前不需要让它接近1。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328205256791.png"></p>
<p>Intel团队用Python。为了在超算上运行，我们选C实现，是他们SOTApython的重写，有循环展开和数据并行优化，并且性能不逊于他们。</p>
<p>串行处理行列缩放,明显看到列用了十几倍的时间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328212937491.png"></p>
<h2 id="介绍典型的并行算法"><a href="#介绍典型的并行算法" class="headerlink" title="介绍典型的并行算法"></a>介绍典型的并行算法</h2><p>关键点：如何分割数据和任务让交流<strong>少一些</strong>，让计算任务更<strong>稳定</strong>。<br>处理方法：把矩阵按行划分成多个子矩阵，每个处理器只负责其中一些行，这样在<strong>行归一化</strong>的时候每个处理器只需要处理自己的行，不需要通信；最后让通信发生在<strong>列归一化</strong>阶段，这部分可以统一优化。这样目的是<strong>把本地能算的留在本地，只在必要时跨节点通信</strong>。<br>算法执行被拆成四步：</p>
<ul>
<li>每个进程独立地对自己那一块行子矩阵进行行归一化（和算法1的第1–10行一样），不需要通信；</li>
<li>每个进程计算自己那部分子矩阵的列和；</li>
<li>调用 MPI_Allreduce 汇总所有进程的列和，得到全矩阵每列的总和；</li>
<li>每个进程根据上一步得到的列缩放因子，独立地对自己那块子矩阵做列归一化。<br>这样做能最大限度减少通信，仅在列缩放因子计算这一步使用 MPI，有利于并行效率。</li>
</ul>
<h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p>在计算并行效率的时候，列缩放时处理器数为16的效率也骤降？<br>原因：<strong>行缩放</strong>的时候不需要进行通信，所有的处理器被平衡地加载；但到<strong>列缩放</strong>的时候处理器在等数据。<br><em>The reason is that the row rescaling is communication free and all the processors are load balanced. While for the column rescaling, the Allreduce used to find the column sum performs a lot of inter-node and intra-node communication, so that some processors are in the process of waiting for data</em> </p>
<h2 id="Motivation-of-COFFEE"><a href="#Motivation-of-COFFEE" class="headerlink" title="Motivation of COFFEE"></a>Motivation of COFFEE</h2><p>我们看到了在并行处理行缩放时候节点内的通信花费了太多时间，大大降低效率；因此我们想利用节点的不同通信特点，然后提升效率。</p>
<p>算法设计-微核设计-MPI优化</p>
<h2 id="CPU-ORIENTED-OPTIMIZATION"><a href="#CPU-ORIENTED-OPTIMIZATION" class="headerlink" title="CPU-ORIENTED OPTIMIZATION"></a>CPU-ORIENTED OPTIMIZATION</h2><p>列重排算法设计（Algorithm1和2的对比）</p>
<h2 id="Micro-kernel-redesign"><a href="#Micro-kernel-redesign" class="headerlink" title="Micro-kernel redesign"></a>Micro-kernel redesign</h2><p>采用SIMD：SIMD（Single Instruction, Multiple Data，单指令多数据流）是一种并行计算技术，它让一个指令同时处理多个数据。常用于图像处理、音频处理、科学计算等场景，加速处理速度，提升性能。<br>采用AVX2指令集：AVX2（Advanced Vector Extensions 2）是Intel推出的SIMD指令集扩展，属于x86架构的一部分。它在AVX的基础上增强了整数运算能力，支持256位宽的YMM寄存器，可以并行处理更多数据，广泛用于图像处理、机器学习等高性能计算中。<br>修改汇编指令</p>
<h2 id="MPI-optimization"><a href="#MPI-optimization" class="headerlink" title="MPI optimization"></a>MPI optimization</h2><h3 id="节点内Reduce算法优化"><a href="#节点内Reduce算法优化" class="headerlink" title="节点内Reduce算法优化"></a>节点内Reduce算法优化</h3><p>二叉树效率低是因为每个处理器开销不同，尤其在根节点，其他处理器都空闲（idle），<strong>加载不均</strong>。<br>为了解决这种严重的负载不均衡问题，我们重新设计了SK算法的Reduce实现，将本地和数组分成几部分。在节点内Reduce之后，每个worker保留本地最终和的一部分并以非阻塞方式将其发送给leader。我们的节点内Reduce实现基于MPI标准原语MPI_Send和MPI_Recv，与MPICH库中Reduce的实现一致。我们没有使用打包技术，因为要传递的数据几乎是连续的，打包带来的额外开销超过了使用它带来的性能提升。</p>
<h3 id="节点间AllReduce算法优化"><a href="#节点间AllReduce算法优化" class="headerlink" title="节点间AllReduce算法优化"></a>节点间AllReduce算法优化</h3><p>我们使用最流行的 Ring 算法实现 Allreduce，以生成列重新缩放的全局最终总和。Ring Allreduce 的一个缺点是它没有考虑节点的层次结构。一般来说，节点之间的带宽远低于节点内的带宽。因此，最近提出了分层 Ring Allreduce。<br>图 7 显示了我们基于分层环的优化。<br>主要思想是重叠节点内 Reduce 和节点间 Allreduce 的时间。我们将本地和数组分成几个数据块。如前所述，对数据块进行 allreduce 有三个连续步骤。首先，工作者对本地和的块执行节点内 Reduce，并将本地最终总和发送给领导者（图 7 中时间 1 的红色箭头）。接下来，领导者对全局最终总和执行节点间 Allreduce（图 7 中时间 2 的红色箭头）。最后，领导者将全局最终总和广播给其工作者（图 7 中时间 3 的红色箭头）。发现不同数据块的顺序步骤可以重叠。例如，图 7 中的时间 2 表示第 i 个数据块的节点间 Allreduce（红色箭头）和第 (i + 1) 个数据块的节点内 Reduce（黑色箭头）可以同时处理。因此，我们在为 SK 算法实现 Allreduce 时将管道的思想结合到分层环中。</p>
<h3 id="重叠通信和计算优化"><a href="#重叠通信和计算优化" class="headerlink" title="重叠通信和计算优化"></a>重叠通信和计算优化</h3><p>当领导者执行 Allreduce 时，工作者必须停滞。我们利用这段停滞时间让工作者修改节点内的矩阵。在我们对 SK 算法的优化 Allreduce 设计中，矩阵修改的计算被添加到流水线中。<br><strong>同时完成 Allreduce 的通信任务和修改子矩阵的计算任务</strong></p>
<h2 id="experiment-evaluation"><a href="#experiment-evaluation" class="headerlink" title="experiment evaluation"></a>experiment evaluation</h2><h3 id="Experimental-Setup"><a href="#Experimental-Setup" class="headerlink" title="Experimental Setup"></a>Experimental Setup</h3><p>为了评估 COFFEE 的有效性，我们将其两个版本进行比较，即面向 CPU 的优化（第 IV 节），表示为 COFFEE-CPU，以及面向 MPI 的优化（第 V 节），表示为 COFFEE-MPI，与 SK 算法的两个现有实现进行比较，一个使用 Ring Allreduce 算法（MPICH-Ring），另一个在 MPICH 环境中使用 SALaR（MPICH-SALaR）<br>高密度矩阵（非零元素占 95%）、中等密度矩阵（非零元素占 50%）、稀疏矩阵（非零元素占 5%）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250330172903583.png"><br>只去算非零矩阵。</p>
<h3 id="CPU-Oriented-Optimization"><a href="#CPU-Oriented-Optimization" class="headerlink" title="CPU-Oriented Optimization"></a>CPU-Oriented Optimization</h3><p>在AMD平台上使用GCC编译器运行的SK算法通过我们的优化获得了最大的改进。在ARM平台上使用Clang编译器，SK算法的典型实现的性能在所有平台上都是最好的，但我们的优化在M &#x3D; N &#x3D; 16,000时仍实现了3.3倍的加速比。</p>
<h3 id="MPI-Oriented-Optimization"><a href="#MPI-Oriented-Optimization" class="headerlink" title="MPI-Oriented Optimization"></a>MPI-Oriented Optimization</h3><h2 id="conclusion-and-further-work"><a href="#conclusion-and-further-work" class="headerlink" title="conclusion and further work"></a>conclusion and further work</h2><p>SK算法在机器学习等领域的重要性日益凸显。本文提出并实现了一种针对SK算法实现的计算和通信的跨层优化设计，称为COFFEE。与大多数现有的通过减少缩放迭代次数来加快收敛速度​​的工作不同，COFFEE着重于通过缩短每次缩放迭代来加快收敛速度​​。我们对SK算法实现中影响性能的问题进行了深入研究。发现列缩放会导致较高的缓存未命中率和较低的并行效率。我们使用列缩放重新设计、数据分块和微内核设计等跨层优化来加速列缩放。我们还根据SK算法的特点优化了MPI Reduce和Allreduce，以提高并行效率。最后，我们在天河一号超级计算机上验证了COFFEE 的有效性。未来我们计划进一步探索和利用行缩放和列缩放之间的相关性。此外，我们计划结合GPU，充分利用异构并行计算架构，进一步提高 COFFEE 的性能。最后，我们计划研究 COFFEE 在 SK 算法稀疏矩阵上的性能，其中数据不是以数组格式存储的。</p>
]]></content>
  </entry>
  <entry>
    <title>LearningHPC</title>
    <url>/2025/03/28/LearningHPC/</url>
    <content><![CDATA[<h2 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants\0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现图片的打开。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172122965.png"><br>因为在python里面\t或者是\n是转义字符，<strong>直接加r表示这就是原始语义</strong>。</p>
<p>如果要读取一个文件夹里的许多图片，需要用到os库，然后使用列表的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dir_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants&quot;</span></span><br><span class="line">img_path_list = os.listdir(dir_path)</span><br></pre></td></tr></table></figure>
<p>最后达到右边的效果<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172705602.png"></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2025/03/30/LeetCode/</url>
    <content><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>2025.3.30<br><img src="https://leetcode.cn/problems/make-the-string-great/submissions/617067145/"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">makeGood</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">abs</span>(res.<span class="built_in">back</span>() - c) == <span class="number">32</span>) &#123;</span><br><span class="line">            res.<span class="built_in">pop_back</span>(); <span class="comment">// 删除上一个相反大小写的字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果栈空，直接插入；如果栈非空，比较当前插入的字符和栈内的字符ascii码差值是否为32，<strong>32为大小写关系</strong>。</p>
<p><img src="https://leetcode.cn/problems/left-and-right-sum-differences/description/" alt="左右元素和的差值"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftRightDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + nums[i + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            res[i] = <span class="built_in">abs</span>(left[i] - right[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://leetcode.cn/problems/non-decreasing-array/description/" alt="非递减数列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                    nums[i<span class="number">+1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> nums[i] = nums[i<span class="number">+1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键在于你要去改，通过当前数的左右两边数来判断是要去改这个数大还是改这个数小，改完之后接着往下去比。<br>3 4 2 3，到了4，4大于2，发现num[i-1] &gt; num[i+1] ，如果想要满足题目的非递减，那就要把num[i+1] &#x3D; num[i]，把这个数字改大，现在序列变成了3 4 4 3，到了下一个i，4&gt;3，这时候cnt++，就跳出循环了。<br>1 4 2 3，到了4，发现要把num[i]改小，所以num[i] &#x3D; num[i+1]。</p>
<p><img src="https://leetcode.cn/problems/reverse-bits/" alt="颠倒二进制串"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(n&amp;<span class="number">1</span>);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>|stk[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用了位运算，第一个for循环让这整个字符串和1与（1写成二进制是000…001，所以只会剩下最后一位），然后把最后一位插入stk里；第二个for循环先让res左移一位，不然会最后多一个0，因为初始化的时候我们已经给了一个0给他了，然后再和数组进行或运算。</p>
]]></content>
  </entry>
</search>
