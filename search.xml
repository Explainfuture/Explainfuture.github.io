<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章！</title>
    <url>/2025/03/08/FirstBlog/</url>
    <content><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><ul>
<li><strong>运算器</strong>进行信息处理；</li>
<li><strong>寄存器</strong>进行信息存储；</li>
<li><strong>控制器</strong>协调各种器件进行工作；</li>
<li><strong>内部总线</strong>实现CPU内各个器件之间的联系。</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"1.png","alt":"img","title":""}]</div>
  </div>
<h2 id="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"><a href="#8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？" class="headerlink" title="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"></a>8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？</h2><p>把16位寄存器分成<strong>AH</strong>和<strong>AL</strong>两个独立的8位寄存器使用；<br>同样，32位或64位的寄存器也可以分，从而实现兼容性。<br>比如AX中现在存储0101010110101010，可以分为AH<strong>01010101</strong>和AL<strong>10101010</strong>来存储</p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="汇编指令-控制CPU完成的操作"><a href="#汇编指令-控制CPU完成的操作" class="headerlink" title="汇编指令                控制CPU完成的操作"></a>汇编指令                控制CPU完成的操作</h3><ul>
<li>mov ax,18                  将18送入AX</li>
<li>mov ah,78                  将78送入AH</li>
<li>add ax,8                   将AX中的值和8相加并把值存入AX</li>
<li>mov ax,bx                  将BX中的值赋值给AX</li>
<li>add ax,bx                  将AX和BX中的内容相加并把值存于AX<br><strong>注意：汇编指令不区分大小写，MOV也行</strong></li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"2.png","alt":"img","title":""}]</div>
  </div>
<p>在进行低八位运算的时候，比如最后一行85+93，结果等于158，但发生了溢出，只能显示58，1舍弃而不是进位到高位。</p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在存储空间中都有唯一的位置。8086CPU有20位地址总线，可传送20位地址，寻址能力为1MB（2的20次方）。8086是<strong>16位</strong>的CPU，16位地址表示的是地址总线的宽度，即CPU可以直接访问的地址范围。如果地址总线是16位，那么可表示的地址数量为2的十六次方&#x3D;65536个字节（即 64KB）。这意味着 CPU 最多只能寻址 64KB 的内存空间。<br>使用地址加法器将两个16位地址合成一个20位的物理地址。一个叫做<strong>段地址</strong>，另一个叫做<strong>偏移地址</strong>。<br><strong>段地址✖16 + 偏移地址 &#x3D; 物理地址，也称之为左移四位（二进制中），在十六进制里左移1位即可。</strong><br>最后得到的20位物理地址被地址总线传送到存储器里。<br>描述存储单元的方法（物理地址为21F60H，段地址为2000H，则偏移地址为1F60H）</p>
<ul>
<li>数据存放在内存2000：1F60单元中</li>
<li>数据存放在内存的2000段中的1F60H中</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"3.png","alt":"img","title":""}]</div>
  </div>]]></content>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2025/03/09/Thread/</url>
    <content><![CDATA[<h1 id="C-11多线程编程"><a href="#C-11多线程编程" class="headerlink" title="C++11多线程编程"></a>C++11多线程编程</h1><hr>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程就是正在运行的程序</li>
<li>线程就是进程中的进程</li>
<li>多线程可以提高效率。</li>
<li>线程的多少取决于CPU的<strong>核数</strong><br>如下图，如果是串行的话就必须顺序执行，但如果并行的话你就可以在同一时间内干多个事情。但同时要注意你的“<strong>核数</strong>”，你不能同时刷抖音和听音乐，因为你没有四个耳朵，亦或者说你的手机同一时间内只能处理一个应用播放声音。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread1.png" alt="图片"></li>
</ul>
<h1 id="C-11-Thread"><a href="#C-11-Thread" class="headerlink" title="C++11 Thread"></a>C++11 Thread</h1><ul>
<li>准备工具 Visual Studio</li>
<li>线程库 thread</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用thread创建一个线程"><a href="#使用thread创建一个线程" class="headerlink" title="使用thread创建一个线程"></a>使用thread创建一个线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HelloWorld&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行调试后，会得到下面结果：<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread2.png" alt="图片"><br>我们发现报错了，为什么会这样呢？</p>
<hr>
<p>可以理解为main里是<strong>主线程</strong>，一开始我们便创建了一个<strong>子线程</strong>，并让其执行PrintHelloWorld的函数。当<strong>子线程</strong>没有执行完毕的时候，主线程已执行完毕。<strong>主线程不会等待子线程执行完毕</strong>，可能子线程才执行到Hello，主程序已经return 0了，所以出现报错；<strong>所以说主线程和子线程是并发运行的！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;HelloworldMain&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
<p>当我们再次加入一行代码时发现，先输出的是<strong>主线程</strong>的HelloworldMain,接下来才是<strong>子线程</strong>的Helloworld。从这里我们可以看出：<strong>创建线程是需要时间的</strong>。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread3.png" alt="图片"></p>
<h2 id="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"><a href="#如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？" class="headerlink" title="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"></a>如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？</h2><h3 id="函数thread-join"><a href="#函数thread-join" class="headerlink" title="函数thread.join()"></a><strong>函数thread.join()</strong></h3><p>在 C++ 中，std::thread::join() 的作用是 等待<strong>子线程执行完毕</strong>，然后<strong>主线程才继续执行</strong>。如果没有 join()，主线程可能会在子线程执行完成之前就结束，导致未定义行为程序报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworldMain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当我们添加了thread1.join()之后，相当于告诉主线程：“大哥你先等我弄完你再往下走，别丢下我！” （<strong>演示注释掉thread1.join()的情况</strong>）<br>join的作用是：<strong>确保子线程完成</strong>，执行顺序可控，但是会<strong>阻塞</strong>主线程，直到子线程完成。<br>阻塞示例 （joinable()用于判断线程是否可以使用join函数，返回的是一个bool值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread1</span><span class="params">(print)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (thread<span class="number">1.</span><span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数thread-detach"><a href="#函数thread-detach" class="headerlink" title="函数thread.detach()"></a><strong>函数thread.detach()</strong></h3><p>让子线程“脱离”主线程，主线程不再管理它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>你可以干你的事情，我也可以干我的事情，不管你了。像请客吃饭，请客的人把单买了之后说我先走一步，你们随意。对比上面的阻塞，我们发现detach是<strong>并发</strong>的。</p>
]]></content>
      <categories>
        <category>c++多线程</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread2</title>
    <url>/2025/03/09/Thread2/</url>
    <content><![CDATA[<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><h2 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h2><p>当多线程去共享同一个数据的时候，会造成争夺</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码发现，a的值没有如我们预期所认为是20000，而是随机的数字。这是因为线程在读取同一个数据的时候发生了争夺。<br>解决办法：当一个线程拿了数据，其他线程禁止拿，也就是互斥锁：线程访问共享资源前，先<strong>加锁</strong>（lock），用完后<strong>解锁</strong>（unlock）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>(); <span class="comment">//在这个线程即将访问数据的时候上锁</span></span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//在访问完成后解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多线程安全：如果多线程程序每一次的运行结果和单线程运行的结果是一样的，那么你的线程就是安全的。</strong></p>
<h2 id="互斥量死锁"><a href="#互斥量死锁" class="headerlink" title="互斥量死锁"></a>互斥量死锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法，当某个线程获取到了m1，那就让他获取m2，按照这样的规则，所有的线程都得先有m1才有m2，那其他线程拿不到m1自然也拿不到m2，所以调换func_2的m1、m2顺序即可。</p>
<h2 id="lock-guard与unique-lock"><a href="#lock-guard与unique-lock" class="headerlink" title="lock_guard与unique_lock"></a>lock_guard与unique_lock</h2><p>std::lock_guard是C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p>
<ul>
<li>当构造函数被调用时，该互斥量会被<code>自动锁定</code></li>
<li>当析构函数被调用时，该互斥量会被<code>自动解锁</code></li>
<li>std::lock_guard对象不能复制或移动，因此它<code>只能在局部作用域中使用</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lg</span>(mtx);</span><br><span class="line">		shared_data++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock_guard<mutex>lg(mtx)的作用就相当于mtx.lock() 且 mtx.unlock().<br>有五个用法：</mutex></p>
<h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="手动解锁"><a href="#手动解锁" class="headerlink" title="手动解锁"></a>手动解锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 提前解锁</span></span><br><span class="line">    <span class="comment">// 此处不再受互斥锁保护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="延迟加锁"><a href="#延迟加锁" class="headerlink" title="延迟加锁"></a>延迟加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;  <span class="comment">// 不自动加锁</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();  <span class="comment">// 需要时再手动加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="尝试加锁"><a href="#尝试加锁" class="headerlink" title="尝试加锁"></a>尝试加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;  <span class="comment">// 判断是否加锁成功</span></span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 锁未获取成功，执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁转移"><a href="#互斥锁转移" class="headerlink" title="互斥锁转移"></a>互斥锁转移</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx)</span></span>;  <span class="comment">// 获取锁</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock2 = std::<span class="built_in">move</span>(lock1);  <span class="comment">// lock1 转移给 lock2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311104759163.png" alt="生产者与消费者"><br>生产者与消费者模型可以这样比喻：生产者是小鸡，任务队列是鸡蛋篮子，消费者是饲养员。有源源不断的任务从生产者发出，由消费者解除，也类似于银行排队系统。<br>当任务队列为<strong>空</strong>的时候，消费者无法去取任务，因此会进入<strong>等待</strong>的状态。那此时老板会下发任务，如何让消费者知道有任务？需要<strong>通知</strong>，让消费者知道我该往里面取任务了。<br>condition_variable有两种</p>
<ul>
<li>notify_one 唤醒消费者中的<em>一个线程</em>来干活</li>
<li>notify-all 唤醒消费者中的<em>所有线程</em>来干活<br><strong>区别在于：通知只发一次，但是对象不同，唤醒一条线程和所有线程的区别</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt;g_queue;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait函数g_cv.wait(lock, predicate)的作用：</p>
<ul>
<li>当前线程进入等待状态，直到 predicate 返回 true，也就是说第二个判断条件是true就往下执行</li>
<li>lock 是一个 std::unique_lock<a href="std::mutex">std::mutex</a>，用于保护临界区资源。</li>
<li>predicate 是一个 Lambda 表达式，返回 true 时线程继续执行，否则会一直等待。<br>两个代码是等价的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!g_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 条件不满足，释放 lock 并进入等待状态</span></span><br><span class="line">    g_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条件满足，继续执行后续代码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 g_queue 为空时，线程会阻塞（等待）。</li>
<li>当 g_queue 非空时，线程继续执行，不会进入等待状态。</li>
</ul>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>除了可以用互斥锁来维护共享变量外，还可以通过原子操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">std::atomic &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在初始化的时候，不允许使用<code>std::atomic&lt;int&gt; a = 0</code>，因为原子操作不允许拷贝复制，应该用默认的构造函数<code>std::atomic&lt;int&gt; a(0)或std::atomic&lt;int&gt; a&#123;0&#125;</code><br>把共享的数据设置为原子变量，更好地维护线程安全，还可以提升运行速度。</p>
<p>小班演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_queue;  <span class="comment">//容器要包含类型</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();  <span class="comment">//每次加任务的时候通知一下</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		flag++;</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Comsumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Comsumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11跨平台线程池"><a href="#C-11跨平台线程池" class="headerlink" title="C++11跨平台线程池"></a>C++11跨平台线程池</h1>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Practise</title>
    <url>/2025/03/10/C-Practise/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="auto：在C-中，auto可以自动推导类型。"><a href="#auto：在C-中，auto可以自动推导类型。" class="headerlink" title="auto：在C++中，auto可以自动推导类型。"></a>auto：在C++中，auto可以自动推导类型。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//有两种方式可以遍历STL容器</span></span><br><span class="line">- <span class="keyword">for</span> (std::vector::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">- <span class="keyword">for</span> (<span class="keyword">auto</span> vtest : v)</span><br></pre></td></tr></table></figure>
<p>&amp;为引用，加&amp;与否取决于是否要修改原值或避免拷贝</p>
<ul>
<li>需要修改并输出修改后的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 = v1<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;v1&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>建议都加std::</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(n,c)</span>  <span class="comment">//可以生成一个包含n个c的字符串。</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string a.<span class="built_in">find</span>() <span class="comment">//可以找一个你想要东西的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">abbrevName</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[<span class="number">0</span>]);</span><br><span class="line">  s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[name.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)<span class="number">+1</span>]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><p>释放动态的指针，如果释放一个值，就是delete p;如果释放的是一个数组，就是delete []p;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 new 分配一个单个整数</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单个int: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 用 delete 释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 new[] 分配一个整数数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 相当于 int arr[5];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组内容: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 用 delete[] 释放数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="STL——set"><a href="#STL——set" class="headerlink" title="STL——set"></a>STL——set</h3><p>set 有insert，erase，count，find,size等用法，通常用于查找的时候不用find（因为要返回迭代器的值），而是用count，set底层是红黑树，可以实现自动除重，比如insert(6)两次，只会有一个，所以count()的值只会是0和1；用于判断是否存储在里面。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312112552261.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">insert</span>();</span><br><span class="line">set.<span class="built_in">erase</span>();</span><br><span class="line">set.<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure>
<p>unordered_set和set大体上一样，但是是用哈希表实现的，所以里面是无序的，但是查找很快,O(1)级，set的查找是O(logN);</p>
<p>set插入vector的元素很方便，使用迭代器，同时通过assign分配新值给nums替换旧值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; <span class="built_in">s</span> (nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">		nums.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span> nums.<span class="built_in">size</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ns = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n!=ns) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>判断前后两次的size是否相同，不同则有重复插入。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一个映射，由Key-&gt;Value，内部是用pair实现。<br>常见的用法有</p>
<ul>
<li>m[] &#x3D; ;</li>
<li>m.erase();</li>
<li>m.count(); &#x2F;&#x2F;用于查找有没有值，return1&#x2F;0;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312120338656.png"><br>可以看到map也像set一样会自动排序，且后来者会覆盖，count返回的是0和1。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外层循环a.size()-1次，内层循环a.size()-i-1次;加引用和不加引用的区别在于：<strong>通过引用传递，函数内部对向量的修改会直接反映在原始向量上，这正是冒泡排序需要的效果，即直接在原数组上排序。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;a[j<span class="number">+1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[j<span class="number">+1</span>];</span><br><span class="line">				a[j<span class="number">+1</span>] = a[j];</span><br><span class="line">				a[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一种<strong>数据类型</strong>，在32为系统性size &#x3D; 4，64 &#x3D; 8.指针存放的是内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>意思是p指针现在存储的是a的地址，可以使用解引用号<em>来访问*<em>p存储的这个地址的值</em></em>。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>const为常量，加在指针前就称之为常量指针 const int *p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;a;</span><br><span class="line">*p = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p><strong>这是一个非法的操作</strong>，常量指针可以<strong>改变指向的地址</strong>，但<strong>不能改变指向地址的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>
<p>这是一个合法的操作，现在p指向的就是b的地址。</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>指针常量和常量指针作用刚好相反，要这样理解：<strong>const后面跟着谁谁就无法改变</strong>，在指针常量中，int *const p，const后面跟着的是地址，所以地址就不能改；在常量指针中，const int *p，const后面跟的是int值，所以值不可以改。<br>所以当const int *const p两个都不可以改。快速记忆：遇到英文翻译中文，const int *p,const是常量，后面是指针，所以常量指针;int *const p,先遇到指针，再遇到常量，所以叫指针常量。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用就是取别名，本质是指针，让b的地址和a的地址相同，但记住在这里引用类似于常量指针，不允许再更改成其他的地址了，但可以改值。<strong>引用必须初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>
<h3 id="引用不要返回局部变量"><a href="#引用不要返回局部变量" class="headerlink" title="引用不要返回局部变量"></a>引用不要返回局部变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次的时候可以正常输出10，但第二次就不行了，因为局部变量存放在栈区，会被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static关键字让他是静态变量，存放在<strong>全局区</strong>，全局区上的数据在程序结束后释放。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类有<strong>属性</strong>和<strong>行为</strong>，比如一个学生类，属性就是学生的名字&#x2F;学生的学号，行为就是打印出名字和学号，也可以用行为来给学生的属性赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_num;</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;m_num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员私有化之后可以实现只读&#x2F;只写&#x2F;可读可写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_age = <span class="number">18</span>;</span><br><span class="line">		string m_name;</span><br><span class="line">		string m_lover;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (age&gt;<span class="number">150</span>||age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m_age = age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student s;</span><br><span class="line">	s.<span class="built_in">set_age</span>(<span class="number">160</span>);</span><br><span class="line">	s.<span class="built_in">get_age</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_x = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_y = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_y;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_x;</span><br><span class="line">		<span class="type">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_r</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_r = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_center</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_center = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">point <span class="title">getm_center</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_center;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_r;</span><br><span class="line">		point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Relation</span><span class="params">(circle &amp;c,point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dx = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_x</span>()-p.<span class="built_in">getm_x</span>();</span><br><span class="line">	<span class="type">int</span> dy = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_y</span>()-p.<span class="built_in">getm_y</span>();</span><br><span class="line">	cout&lt;&lt;dx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dy;</span><br><span class="line">	<span class="type">int</span> rdistance = c.<span class="built_in">getm_r</span>()*c.<span class="built_in">getm_r</span>();</span><br><span class="line">	<span class="type">int</span> distance = dx*dx+dy*dy;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (distance==rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆上&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(distance&gt;rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆外&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;在圆内&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	point p;</span><br><span class="line">	circle c;</span><br><span class="line">	c.<span class="built_in">setm_r</span>(<span class="number">10</span>);</span><br><span class="line">	point center;</span><br><span class="line">	center.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	center.<span class="built_in">setm_y</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">setm_center</span>(center); </span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	p.<span class="built_in">setm_y</span>(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Relation</span>(c,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>没有返回值，不用写void，函数名与类名相同，构造函数可以有参数，可以发生重载，创建对象的时候会自动调用，而且只调用一次。<br>析构函数前加一个~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;构造&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;析构&quot;</span>;</span><br><span class="line">	 &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	person p1;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以省略冗余的代码，继承父类。<br>继承语法： class 子类 : 继承方式 父类<br>class cpp : public header<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183703034.png">;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183742270.png">;<br>子类可以缩小权限范围，但不能扩大权限范围。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321191947414.png"></p>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>类初始化在构造函数后面打一个冒号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这一行代码等价于下面这一行代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xx, <span class="type">int</span> yy)</span><br><span class="line">        &#123;</span><br><span class="line">            x = xx;</span><br><span class="line">            y = yy;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Constructor of Point&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是区别不同<br>上面两段代码对应于初始化类成员的两种方式：(1)使用初始化列表；(2)在构造函数体内进行赋值操作。<br>但严格来说，上面两段代码只是能实现相同的功能(初始化Point类的对象)，它们的本质并不相同，下面来说明原因。<br>构造函数的执行分为两个阶段：<br>(1)执行初始化列表：初始化类中的数据成员；<br>(2)执行构造函数体：一般是对类中的数据成员进行赋值操作。<br>初始化与赋值是不同的，所以上面两段代码只是功能上相同，但本质并不相同，前一个是初始化，后一个是赋值。</p>
<h2 id="STL–deque"><a href="#STL–deque" class="headerlink" title="STL–deque"></a>STL–deque</h2><p>deque（double ended queue）双端队列 好处：<strong>两端都开口</strong>，想要在头部插入元素很方便。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402104311358.png"></p>
<h3 id="有四种拷贝构造"><a href="#有四种拷贝构造" class="headerlink" title="有四种拷贝构造"></a>有四种拷贝构造</h3><ul>
<li>deque<T>deqT <strong>默认构造</strong></T></li>
<li>deque<T>d1(d); <strong>拷贝构造</strong></T></li>
<li>deque<T>d2(d.begin(),d.end()) 把[begin,end)区间的元素给d2</T></li>
<li>deque<T>d3(10,100) &#x2F;&#x2F;10个100 将n个elem拷贝给自身</T></li>
</ul>
<h3 id="有三种赋值"><a href="#有三种赋值" class="headerlink" title="有三种赋值"></a>有三种赋值</h3><ul>
<li>deque<int> d &#x3D; d1 等号赋值</int></li>
<li>deque<int> d3; d3.assign(d1.begin(),d1.end()) </int></li>
<li>d3.assign(10,100) 给10个100<br>和vector一样。</li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>函数原型：<br>deque.empty(); &#x2F;&#x2F;判断容器是否为空<br>deque.size(); &#x2F;&#x2F;返回容器中元素的个数<br>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。<br>deque.resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>两端插入操作：<br>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据<br>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据<br>pop_back(); &#x2F;&#x2F;删除容器最后一个数据<br>pop_front(); &#x2F;&#x2F;删除容器第一个数据<br>指定位置操作：<br>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。<br>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。<br>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg，end)区间的数据，无返回值。<br>clear();&#x2F;&#x2F;清空容器的所有数据<br>erase(beg,end); &#x2F;&#x2F;删除[beg，end)区间的数据，返回下一个数据的位置。<br>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>sort(d.begin(),d.end())</p>
<h2 id="STL–queue"><a href="#STL–queue" class="headerlink" title="STL–queue"></a>STL–queue</h2><p>先进先出，很像尾插法。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402113216514.png"><br><strong>不允许遍历！只能访问队头队尾！</strong><br>入队：q.push() 出队：q.pop()<br>基本操作<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402113412632.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;compare_int_int&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;compare_double_double&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* //strcmp会逐个比较</span></span><br><span class="line"><span class="comment">const char* a = &quot;apple&quot;;</span></span><br><span class="line"><span class="comment">const char* b = &quot;apricot&quot;;</span></span><br><span class="line"><span class="comment">strcmp(a, b); // 比较 &#x27;a&#x27; vs &#x27;a&#x27; → &#x27;p&#x27; vs &#x27;p&#x27; → &#x27;p&#x27; vs &#x27;r&#x27; → 返回负数（&#x27;p&#x27; &lt; &#x27;r&#x27;）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* a = <span class="string">&quot;hello&quot;</span>; <span class="comment">//在内存中是&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;，a是一个指针，指向&#x27;h&#x27;的地址。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b)</span> <span class="comment">//const char* a 是一个指针，指向一个字符串的起始地址，字符串本质上是以 \0 结尾的 char 数组。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;compare_char*_char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">compare</span>(<span class="number">10.0</span>, <span class="number">20.0</span>);</span><br><span class="line">	<span class="built_in">compare</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>算法（一）</title>
    <url>/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><p>介绍常用的算法</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有三个关键量，right、left、middle；<code>middle = (right - left)&gt;&gt;1</code>，其中<code>&gt;&gt;</code>为右移运算符，将right - left结果的二进制位向右移一位，&gt;&gt;n右移n位，举个例子</p>
<ul>
<li>8 - 4 &#x3D; 4，4的二进制位为0100，右移一位变为0010，代表十进制2。</li>
<li>7 - 2 &#x3D; 5，5的二进制位为0101，右移一位变为0010，代表十进制2。<br>可以看出，右移运算符的作用是<code>将两数相减并向下取整得到结果</code><br>为什么要用右移运算符而不用&#x2F;2？</li>
<li>右移运算 &gt;&gt; 通常比除法 &#x2F; 更快，因为位运算是底层硬件直接支持的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left)&gt;&gt;<span class="number">1</span>); <span class="comment">//left每一次加上新的中间值</span></span><br><span class="line">			<span class="keyword">if</span> (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&lt;target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</strong><br><strong>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</strong><br>采用二分法，注意停止条件，当left&gt;right就停止了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (right&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> p = <span class="number">1.0</span>*middle*middle;</span><br><span class="line">            <span class="keyword">if</span> (p==x) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span> (p&lt;x)&#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311182900217.png"></p>
<h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><p>滑动窗口类似于双指针，用于去求最短子序列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311202740831.gif"><br>j是终止位置，很像毛毛虫往前拱，吃到了，然后尾巴再上来。<br>LeetCode 209</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum&gt;=target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                x = x &gt; subLength ? subLength : x;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == INT32_MAX? <span class="number">0</span> : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口例题2<br>The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:</p>
<p>maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4});<br>&#x2F;&#x2F;should be 6: {4, -1, 2, 1}<br>Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</p>
<p>Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist&#x2F;subarray.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSequence</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, maxSum = <span class="number">0</span>;  <span class="comment">// 初始化最大和为 0（符合题目要求）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; arr.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">        sum += arr[right];  <span class="comment">// 扩展窗口</span></span><br><span class="line">        </span><br><span class="line">        maxSum = std::<span class="built_in">max</span>(maxSum, sum);  <span class="comment">// 更新最大子数组和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前窗口的和变成负数，移动左指针</span></span><br><span class="line">        <span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的一步在while(sum&lt;0),会把之前为负数的窗口给舍弃掉，1 + -3 &#x3D; -2，-2 -1 &#x3D; -3，left左移动一位，-3 -（-3） &#x3D; 0，left左移一位，所以left变成了3；从3又继续开始遍历。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>说实话贪心算法并没有固定的套路。<br><strong>所以唯一的难点就是如何通过局部最优，推出整体最优。</strong><br>LeetCode455<a href="https://leetcode.cn/problems/assign-cookies/">分饼干</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g.<span class="built_in">size</span>()==<span class="number">0</span>||s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span> (s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span> (g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;g.<span class="built_in">size</span>()&amp;&amp;j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]&lt;=s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>计算机系统</title>
    <url>/2025/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h2><h3 id="80386通用寄存器"><a href="#80386通用寄存器" class="headerlink" title="80386通用寄存器"></a>80386通用寄存器</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312130401047.png"></p>
<ul>
<li>%ax :accumulate 累加寄存器</li>
<li>%bx :base 基址寄存器</li>
<li>%cx :count 计数寄存器</li>
<li>%dx :divide 放除法的商和余数</li>
<li>%eax : extend 扩展 表示32位的寄存器<br>%eax表示32位寄存器，%ax表示低16位，在低16位的寄存器中：%ah表示高八位，%al表示第八位</li>
</ul>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="1005-s-立即数寻址"><a href="#1005-s-立即数寻址" class="headerlink" title="1005.s 立即数寻址"></a>1005.s 立即数寻址</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312134223502.png"><br>movl $8,%eax; </p>
<ul>
<li>$是立即数，表示8</li>
<li>movl是移动的意思，将8赋值给%eax；<br>最终的运行结果如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312140455507.png"></li>
</ul>
<hr>
<h4 id="1006-s-寄存器寻址"><a href="#1006-s-寄存器寻址" class="headerlink" title="1006.s 寄存器寻址"></a>1006.s 寄存器寻址</h4><ul>
<li>movl 用于传送<strong>32</strong>位的长子值</li>
<li>movw 用于传送<strong>16</strong>位的子值</li>
<li>movb 用于传送<strong>8</strong>位的子值<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312141244989.png"><br><strong>不能把movw的w改为l，因为%bx是16位的寄存器，如果改为l试图把32位的传给16位是错误的</strong>。可以写mov &#x2F; movw<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312174829067.png"><br>命令为 movw $0x5678,%dx ; 意思是传16个字节(w)的数据到寄存器dx里，结果如我们所愿，如果用%dh&#x2F;%dl便会报错，因为%dh&#x2F;%dl是8位的寄存器;同样，也不能movw $0x5678,%edx，因为edx是32位的，所以只能写32位的地址。如下图，所以要用对应的寄存器和对应位数的mov指令或只写mov去传递数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312175249233.png"></li>
</ul>
<h4 id="1007-s-绝对寻址（直接寻址）"><a href="#1007-s-绝对寻址（直接寻址）" class="headerlink" title="1007.s 绝对寻址（直接寻址）"></a>1007.s 绝对寻址（直接寻址）</h4><p>movl 0x08048054,%exc，直接把这个内存地址赋给%exc。可以使用x&#x2F;4bx 08048054来查看以8054起的四个地址内容。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190744306.png" alt="查看内存内容"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190225523.png"><br>内存之中<strong>既可以存放数据，也可以存放指令</strong>。如图，b9是指令，从后往前看08、04、80、55就是数据。</p>
<h4 id="1008-s-间接寻址"><a href="#1008-s-间接寻址" class="headerlink" title="1008.s 间接寻址"></a>1008.s 间接寻址</h4><p>movl (%ebx),%eax 和寄存器寻址的区别在于第一个寄存器套上了括号，表示不是把寄存器%ebx的值赋给%eax，而是寄存器存放的数据的地址存放的内容赋给%eax。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191539026.png"><br>第一步，立即数寻址，把立即数08048054放到%ecx<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191713316.png"><br>第二步，查看08048054内存中存放的数据是什么，并将其传入<strong>16位</strong>的%ax中，得到结果0x8056，为什么是8056？因为56是低位，80是高位</p>
<h4 id="1009-s-变址寻址"><a href="#1009-s-变址寻址" class="headerlink" title="1009.s 变址寻址"></a>1009.s 变址寻址</h4><p>movl (%ebx,%edx),%eax 在1008的基础上，把括号内两个寄存器的值加起来，用这个内存地址去找里面的数据，然后把数据传给%eax。</p>
<h4 id="1010-s-比例变址寻址"><a href="#1010-s-比例变址寻址" class="headerlink" title="1010.s 比例变址寻址"></a>1010.s 比例变址寻址</h4><p>movl (%ebx,%ecx,0x2),%eax<br>%ebx为基址，%ecx与第三个参数(第三个参数只能为1，2，4，8，左移运算符)<strong>相乘</strong>并与基址相加，最后赋值给%eax。</p>
<h4 id="1012-s-获取变量在内存的地址"><a href="#1012-s-获取变量在内存的地址" class="headerlink" title="1012.s 获取变量在内存的地址"></a>1012.s 获取变量在内存的地址</h4><p>leal 5(%edx, %edx, 2), %eax   &#x2F;&#x2F;假设%edx的值为x, 这行代码会将%eax的值设置为”3x+5″.</p>
<h4 id="1013-s-栈操作指令"><a href="#1013-s-栈操作指令" class="headerlink" title="1013.s 栈操作指令"></a>1013.s 栈操作指令</h4><p>栈：先进后出<br>栈顶指针：保存在%esp寄存器中<br>压栈push出栈pop<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325154443719.png"><br>栈是往低处生长的。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155048996.png"><br>e0-4 &#x3D;dc 栈顶指针往前偏移了<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155207739.png"><br>压栈后栈顶现在存放的是88888888</p>
<h4 id="1014-s-跳转指令"><a href="#1014-s-跳转指令" class="headerlink" title="1014.s 跳转指令"></a>1014.s 跳转指令</h4><p>直接跳转指令</p>
<ul>
<li>jmp lable</li>
<li>jmp 0x0804909a</li>
<li>jmp *%eax</li>
<li>*lable<br>条件跳转指令<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325161023037.png"></li>
</ul>
<h2 id="数的表示与处理"><a href="#数的表示与处理" class="headerlink" title="数的表示与处理"></a>数的表示与处理</h2><h3 id="整数表达"><a href="#整数表达" class="headerlink" title="整数表达"></a>整数表达</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172553621.png"><br>无符号整数就是大于等于0的数，4为无符号整数的取值范围为0-15。</p>
<h4 id="补码形式"><a href="#补码形式" class="headerlink" title="补码形式"></a>补码形式</h4><p>最高位的权重是负数<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172840669.png"><br>具体例子如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172941441.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173019514.png"><br>对于相同的数，映射关系不同，得到的数也不同，下图是有符号数和无符号数的例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173154420.png"></p>
<h4 id="无符号数与有符号数的转换"><a href="#无符号数与有符号数的转换" class="headerlink" title="无符号数与有符号数的转换"></a>无符号数与有符号数的转换</h4><p>他们的二进制表示都相同，但如果是有符号数的话，第一位会乘负权重；如果是无符号数就是正常。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173537847.png"></p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>无符号数加法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325175049195.png"></p>
<h2 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h2><h3 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h3><p>求一个负数的补码：比如-25</p>
<ul>
<li>先转换成原码 10011001 （<strong>有符号数</strong>最高位为标志位，代表-128（八位的话））</li>
<li>负数的反码等于<strong>除标志位各个位置取反</strong> 11100110</li>
<li>最后得到补码，补码就是在反码的基础上+1 11100111 转成16进制为E7H。</li>
</ul>
<h3 id="指令寄存器"><a href="#指令寄存器" class="headerlink" title="指令寄存器"></a>指令寄存器</h3><p>直接寻址的无条件转移指令功能是将指令中的地址码送入<strong>PC</strong>，<strong>PC决定下一条指令执行的地址。</strong></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="定点数的表示方法"><a href="#定点数的表示方法" class="headerlink" title="定点数的表示方法"></a>定点数的表示方法</h4><ul>
<li>定点小数 ：小数点在符号位和数值位（<strong>决定正负数之间</strong>）比如0.875（10），转换成二进制-&gt;0.111(B)，补够8位0（小数点隐含在这个位置）01110000；如果是-0.875就是11110000，符号位还是带权。</li>
<li>定点整数 ：小数点在最低位后，比如32(10)-&gt;100000(B)，补够8位，00100000，因为是正数，所以符号位为0；如果是-32，就10100000，这是原码，负数在计算机中以<strong>补码的形式存放</strong>，所以我们将其除符号位的所有位置反转得到<strong>反码11011111</strong>，再在反码的基础上+1得到补码11100000.</li>
</ul>
<h4 id="浮点数法的表示方法"><a href="#浮点数法的表示方法" class="headerlink" title="浮点数法的表示方法"></a>浮点数法的表示方法</h4><p>浮点数分为符号位、阶码、尾数三个部分<br>类似于科学计数法，比如112.5(10)来表示为1.125<em>10²<br>先将112.5转成二进制数，1110000.1(B) &#x3D; 可以表示为1.1100001</em>2^6，不能写为6，要写成110，这个指数就叫做<strong>阶码</strong>。1100001就叫做<strong>尾数</strong>（小数点后的数）<br>阶码要加127，6+127 &#x3D; 133再转成二进制<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250415204713980.png"><br>第二个例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250415204903548.png"><br>[ 符号位 | 阶码8位 | 尾数23位 ]<br>在浮点数编码表示中，(<strong>基数</strong>)在机器数中不出现，是隐含的。</p>
<p>下列叙述中概念正确地是( D )</p>
<p>A 定点补码运算时,其符号位不参加运算 &#x2F;&#x2F;都参与，否则加法无法处理正负数<br>B 浮点运算中,尾数部分只进行乘法和除法运算 &#x2F;&#x2F;位数部分可以进行<strong>加减乘除</strong><br>C 浮点数的正负由阶码的正负符号决定  &#x2F;&#x2F;由*<strong>符号位</strong>决定<br>D 在定点小数一位除法中为了避免溢出被除数的绝对值一定要小于除<br>数的绝对值</p>
<ul>
<li>当尾数用<strong>补码</strong>表示的时候，数符（符号位）和<strong>尾数第一位</strong>相反，则代表这个数<strong>规格化</strong></li>
</ul>
<p>假设初始值：%dh&#x3D;CD，%eax&#x3D;98765432,则执行 movzbl %dh ,%eax<br>这样一条指令后，%eax 的值为( D )<br>A %eax&#x3D; 987654CD<br>B %eax&#x3D; CD765432<br>C %eax&#x3D; FFFFFFCD<br>D %eax&#x3D; 000000CD<br>movzbl 指令的<strong>目标寄存器</strong>是 32 位的 %eax，而这条指令的设计就是：把源操作数（一个 8 位数）零扩展成 32 位，然后整个写入目标寄存器（%eax）中，覆盖原内容。</p>
<p>假设初始值：%dh&#x3D;CD，%eax&#x3D;98765432,则执行 movsbl %dh ,%eax<br>这样一条指令后，%eax 的值为( C )<br>A %eax&#x3D; 987654CD<br>B %eax&#x3D; CD765432<br>C %eax&#x3D; FFFFFFCD<br>D %eax&#x3D; 000000CD<br>movsbl %dh, %eax 是一条有符号扩展指令，会将 %dh 中的 8 位值 CD（即二进制 11001101，表示负数）扩展为 32 位，扩展时高位补符号位（即补 1），得到 FFFFFFCD，并覆盖写入整个 %eax，所以最终 %eax &#x3D; FFFFFFCD。</p>
<p>假设在 C 程序中有 int *a , int n ,如果值 a 在寄存器%ecx 中，n 在%edx<br>中，下面哪个指令计算的是 a[n] ？（ C ）<br>A ret (%ecx,%edx,4)<br>B leal (%ecx,%edx,4),%eax ret<br>C mov (%ecx,%edx,4),%eax ret<br>D mov (%ecx,%edx,1),%eax ret </p>
<p>int a[i] &#x3D; a + sizeof(int)<em>n，其中int的大小为4，<strong>mov是读取内存中的值，访问内存</strong>，而leal是*<em>计算地址</em></em>，结果存寄存器，不访问内存。<br>leal(%ecx,%edx,4),%eax : 计算地址ecx + 4<em>edx并存入eax中。<br>mov(%ecx,%edx,4),%eax ：计算地址并从*<em>这个地址中读取内容</em></em></p>
<p>并不是任何十进制小数都可用二进制表示 ，比如0.1（10）标识出来的就是一个无限不循环小数</p>
<p>下列指令不会改变条件码的值的是(D)<br>A testl %eax,%eax<br>B addl %eax,%eax<br>C cmpl %esi,%dsi<br>D jge .L2<br>test是按位与，add加，cmp比较，都会改变条件码，jg条件跳转。</p>
<p>下列汇编指令中正确的是（ A ）<br>A movl $0x4050,%eax<br>B movl(%eax),4(%esp)<br>C movl %eax,$0x123<br>D movb $0xF,%ebx<br>我们上课所学的汇编是将左边的传给右边，A将0x4050这个地址传给eax保存，B读取了eax所存放的地址，但是mov指令是要传递给寄存器的，所以应该是movl (%eax),%ebx</p>
<p>将一个 4 位数值-5 截断到 3 位数的结果为<br>先转为补码，-5的原码为1101，反码为1010，补码为1011，截断成三位数（<strong>舍弃最高位</strong>）称为011，变为3</p>
<p>将一个<strong>双字节</strong>的内容压入（32位），栈帧-4；</p>
<p>EAX是一个32位的寄存器，AX用来表示低16位，AH用来表示低16位的高8位，AL用来表示低16位的低8位。</p>
<p>算数右移（SAR）规则：<strong>保留符号位（最高位）右移其它位，末位丢弃</strong><br>原数： 11001110<br>SAR1： 11100111</p>
<p>对整数运算z&#x3D;x+y,设置条件码OF的表达式为D (x &lt; 0 &#x3D;&#x3D; y &lt; 0) &amp;&amp; (z &lt; 0 !&#x3D; x &lt; 0)  </p>
<ul>
<li>正溢出：x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; z &lt; 0（正溢出）</li>
<li>负溢出：x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; z &gt;&#x3D; 0（负溢出）</li>
</ul>
<p>在补码的加法中发生了负溢出的是<br>C x+y &#x3D; x+y-2^w<br>若 w 位补码中两个负数相加，结果却变成正数 ⇒ 发生负溢出，此时实际数学值超出了补码能表示的负数范围。当加法结果超出这个范围，补码会 回绕（wrap around），造成：负溢出 ⇒ 减去 2^w，正溢出 ⇒ 加上 2^w。</p>
<p>对整数运算z&#x3D;x+y,设置条件码CF的表达式为：（unsigned）z  &lt; （unsigned）x<br>CF:无符号加减法的进位（无符号溢出）<br>OF:溢出（有符号溢出）<br>SF:运算结果的正负<br>ZF:零标志位</p>
<p>假设AL&#x3D;5H，要使得AL&#x3D;0FAH，应执行的命令是( )。<br>5H &#x3D; 0000 0101 (二进制)<br>0000 0101  (原始值 AL &#x3D; 0x05)<br>取反后：  1111 1010  (AL &#x3D; 0xFA)</p>
<h2 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h2><h3 id="lea-（Load-effective-address）"><a href="#lea-（Load-effective-address）" class="headerlink" title="lea （Load effective address）"></a>lea （Load effective address）</h3><p>lea指令可以用来执行简单的算术操作<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250610203136852.png"></p>
<h3 id="字节存放顺序"><a href="#字节存放顺序" class="headerlink" title="字节存放顺序"></a>字节存放顺序</h3><p>一个多字节应该怎样在内存中存放？分为大端法和小端法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250610210804576.png"><br>小端法习题，低位字节存放在低地址<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250610211431175.png"></p>
<ul>
<li><strong>4GB</strong>虚拟页式存储系统，按<strong>字节</strong>编址，页面大小为<strong>4KB</strong><ul>
<li>4GB &#x3D; pow(2,32)；按字节编址，也就是一个B是一个地址，有2的32次方这么多地址</li>
</ul>
</li>
</ul>
<h2 id="存储访问"><a href="#存储访问" class="headerlink" title="存储访问"></a>存储访问</h2><ul>
<li>CPU先去Cache里找主存中的副本，如果没有再去主存找，找到了的话就将数据生成一份副本放入Cache(局部性原理)<br>主存的数据块大小成为块，Cache数据块大小称为行，主存与Cache之间是以数据块为单位进行数据交换的，主存与Cache的数据块大小是相同的，所以主存地址与其对应的Cache地址，他们的块内地址是相同的。</li>
<li>Cache行中需要添加一个标记为T，用于指明改行的数据块是来源于主存中的哪一个副本<br>TLBI（TLB的索引）在VPN的低位</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Network</title>
    <url>/2025/03/19/Network/</url>
    <content><![CDATA[<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><p>The following content is about the basic knowledge of computer network.</p>
<h2 id="Breif-introduction"><a href="#Breif-introduction" class="headerlink" title="Breif introduction"></a>Breif introduction</h2><p>Such as smartphone, tv, safe system, car and so on.All of this are called <strong>host</strong> or <strong>end system</strong>. The end system is linked by <strong>communication link</strong>(通信链路) and <strong>packet switch</strong>(分组交换机).<br>Different communication links such as <strong>电缆、光纤、无线电频谱</strong> can spread the data with different speed. The transmission rate are measured by <strong>bit&#x2F;s or bps</strong>.These message packet(信息包) are called <strong>packet</strong>(分组).<br><em>The packet seems like truck, all of the truck trans the goods to the destination by highspeed road. The communication links like the road, the packet like the truck, and the packet switch like the fork in the road, and the end system like the building.</em><br>The end system connect the Internet by <strong>ISP</strong>(Internet Service Provider).<br>The end system, packet switch and the other part of Internet are <strong>following a series of protocol</strong>(协议). <strong>These protocols control the internet message’s receive and send</strong>. Such as TCP(Transmission Control protocol，传输控制协议) and IP(Internet protocol,网际协议) are <strong>the most important protocols in the internet</strong>.IP protocol defines the rules of sending and receiving message winin router and end system.The main protocol of Internet is called <strong>TCP&#x2F;IP</strong>.<br><strong>A socket interface</strong>(套接字接口) refers to a programming interface that allows communication between different computer systems over a network. For example, you want to write a letter for your friend, you can’t just write the letter and throw it out of the window and think he&#x2F;she can receive it. You need to put the letter into the envelop and write the full name, address, and postcode of your friend. Close the envelop and post a stamp and throw it into the post office. So all of these are the socket interface of postface, you need to obey it so that you can send your letter.</p>
<h2 id="What-is-protocol"><a href="#What-is-protocol" class="headerlink" title="What is protocol?"></a>What is protocol?</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319181124581.png"><br>Let’s begin at the human protocol. If you want to  say hi to the other, you need to first say ‘hi’ and wait for his response. If he gives your certain response, you can continue say what your want. But if he does’t want to response you, you can’t continue your work.<br>Now look at the picture, you tap the web’s url. You computer send a connection request message to the Web server and wait for the respond. The Web server receives that and return a connection response message. Then the computer sends a GET message, declaring what it wants to fetch from the Web server.<br>So the protocol defines the message’s format and order between two or more than two communication entity, and sending or receiving a message or something else.</p>
<h2 id="The-media"><a href="#The-media" class="headerlink" title="The media"></a>The media</h2><p>A bit from a series of connection link and router can arrive at the other end system. Each <strong>send-receive couple</strong> send the electromagnetic and pulse through a physical media. Such as 双绞铜线，同轴电缆，多模光纤缆. The physical media has two types: the guided media and the unguided media. For the first one, The waves go along with the solid media like 光缆，双绞铜线或同轴电缆.For the other, the waves spread through air or outter space. Such as WLAN or digital satellite channels.</p>
<h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185139123.png"></p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185234778.png"></p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185333613.png"></p>
<h3 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a>陆地无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185413035.png"></p>
<h3 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185439185.png"></p>
<h2 id="The-kernel-of-network"><a href="#The-kernel-of-network" class="headerlink" title="The kernel of network"></a>The kernel of network</h2><p>In various network application, the end system(also called host) exchanges messgae to each other. The messgae can implement a control function or contain the data. For sending a message to the destination host, the source end system cuts the long message into the little data brick. This operation called packet. Every packet can be transmited by connection link or packet switch between the source and destination. The time of transmiting is the length of bits(R) dividing the rate of connection link(R). So the time is (L&#x2F;R).</p>
<h3 id="packet-exchange"><a href="#packet-exchange" class="headerlink" title="packet exchange"></a>packet exchange</h3><p><strong>store and forward transmission</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191400491.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191419708.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191428022.png"><br><strong>The queuing delay and packet loss</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191821692.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191916889.png"><br><strong>The forwarding table and routing protocol</strong><br>The router gets the packet from a connection link linked to it, but how does it know where to trans the packet to the destination?<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319192733925.png"></p>
<h2 id="The-Internet-of-Internet"><a href="#The-Internet-of-Internet" class="headerlink" title="The Internet of Internet"></a>The Internet of Internet</h2><p>Lots of ISPs connect with each other, the low-level ISP connect to the high ISP. <strong>Peer to Peer(对等，两个运营商传输和接收尽量相同的bits，不让对方赚钱)</strong><br>IXP(Internet Exchange Point) is a meeting point, the peer ISP does’nt pay the extra fees.<br><strong>多宿(别吊死在一棵树上)</strong>:low-level ISP seeks for higher ISP to connect to make sure its capacity of connection. It can avoid the trouble caused by one of the ISP, it can use the other ISP.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319195757272.png"></p>
<h2 id="Time-Delay"><a href="#Time-Delay" class="headerlink" title="Time Delay"></a>Time Delay</h2><p>We have four types of time delay.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201045033.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201115287.png"><br><em>dtotal &#x3D; dproc + dqueue + dtrans + dprop</em></p>
<h2 id="Five-protocols"><a href="#Five-protocols" class="headerlink" title="Five protocols"></a>Five protocols</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319203624856.png"><br>我说张三你是帅哥，张三的身体是主机，耳朵是端口，我选择只传输给张三一个人，然后选择走哪条路（连接层就是链路层），如果他在泰国人就可以飞机过去，在国内就火车过去，电信号就通过电缆过去，最后物理层传输。</p>
<h1 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h1><p>There are two types of appliication architectures, one is <strong>client-server architecture</strong>, and the other is P2P.</p>
<h2 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h2><p>A forever-opening host is called <em>server</em>. It serves lots of other client hosts’ request. When the server receives the request for a objection form a client, it sends the objection back as the response. When we are in the client-server architecture, the client can’t communicate with the other client. Just like the two webserver can’t communicate with each other. The sever has a solid, well-known ip, and is forever-opening. So client can always send packets to the ip to communicate with it. In this system, the famous application includes the Web, FTP, Telnet and E-mail. In general, a single sever host can’t content all of the requests. So <strong>data center</strong> which has lots of hosts is used to create strong virtual server.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320113426164.png"></p>
<h2 id="Process-Communication"><a href="#Process-Communication" class="headerlink" title="Process Communication"></a>Process Communication</h2><p>In operating system, actually communicaition is a process instead of application. The processes in two different end system send message to communicate through computer network. The sending message process generates and sends the message to the net. The receiving process receives the message, and maybe send the message back to response. </p>
<h3 id="The-client-and-sever-process"><a href="#The-client-and-sever-process" class="headerlink" title="The client and sever process"></a>The client and sever process</h3><p>The web applications consist of couple of process. In Web application, a client webserver process exchanges the message with the Web server process. For each group of communication process, <strong>a process is called client, and the other is called server</strong>.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320114830448.png"></p>
<h3 id="The-process’s-interface-of-computer-network"><a href="#The-process’s-interface-of-computer-network" class="headerlink" title="The process’s interface of computer network"></a>The process’s interface of computer network</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115300248.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115304351.png"></p>
<h3 id="Process-Find-Address"><a href="#Process-Find-Address" class="headerlink" title="Process Find Address"></a>Process Find Address</h3><p>If we want wo send a letter to the destination, the destination needs to have an address. A host’s process sends packet to another host’s process. We need to define two label: ①The address of host;②The destination host’s receiving process’s identifier.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115840795.png"></p>
<h2 id="Four-factors-of-transmission-serve"><a href="#Four-factors-of-transmission-serve" class="headerlink" title="Four factors of transmission serve"></a>Four factors of transmission serve</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120312829.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120317239.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120323470.png"></p>
<h2 id="Transmission-Layer-Protocol"><a href="#Transmission-Layer-Protocol" class="headerlink" title="Transmission Layer Protocol"></a>Transmission Layer Protocol</h2><p>TCP &#x2F; UDP<br>TCP和UDP之间的区别与联系：就像打电话和写信，你打电话能知道他是谁，打给谁，挂断之后即时有反馈，而写信在你寄出去的一瞬间你不能确保信是否会寄到他那里，以及什么时候才能寄到，信的内容是否完整（丢包）。UDP就是用于可以容忍一点点丢包，比如实时竞技游戏，视频通话。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>A：是B吗？我要跟你通信，听得到我说话吗？<br>B：可以通信，你听得到我说话吗？<br>A：我也听得到。</p>
<p><em>其实二次握手就可以建立链接，三次握手是为了互相确认对方的序列号，四次挥手是因为服务端有未发送完的数据。所以需要服务端连续发两次。同时客户端最后的等待也是为了确保服务端收到ASK请求fin<del>ask</del>fin~ask,如果过了等待时间则认为服务端已经关闭（没有关闭的话会有ASK）</em></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>C：我困了，先不聊了吧<br>S：还有几件事，说完我们就睡觉……<br>……（说完之后）<br>S：好了，说完了，我挂线了<br>C：好，你挂吧<br>S挂断电话<br>C说完之后就直接睡觉了，不知道电话挂没挂断，在几分钟后听到手机没有声音传来了，即使不用睁眼也知道S挂断了</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http(HyperText Transfer Protocol)<br>HTTP（超文本传输协议）是互联网上用来传递信息的一种规则。可以把它想象成一种通讯方式，它定义了如何发送和接收网页内容，比如文本、图片和视频等。想象一下，当你在网上浏览器里输入一个网址或点击一个链接时，你的浏览器就通过HTTP向网站的服务器发送一个请求，就像是在说：“嘿，我想看这个网页。”服务器收到这个请求后，如果网页可用，它就用同样的HTTP规则回应，发送网页的内容回来。简单来说，HTTP像是你和网站之间的对话规则，确保双方都能理解对方发送的消息。这就是你能够浏览网页和观看在线视频的原因之一。若想<strong>高效识别用户</strong>，引入了cookies，cookies就像门禁卡，我新建了一个房子，刚开始来的给一张卡刷进来，后面来的时候就拿着这张卡，网页就可以识别到你这个人做了什么。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320132409503.png"></p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>链路层协议的任何设备均成为<strong>节点</strong>，节点包括主机、路由器、交换机、和WIFI接入点。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320135508535.png"><br>数据链路层有三个重要的问题：封装成帧、差错检测、可靠传输。</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320140209418.png"></p>
]]></content>
  </entry>
  <entry>
    <title>论文笔记</title>
    <url>/2025/03/28/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="COFFEE"><a href="#COFFEE" class="headerlink" title="COFFEE"></a>COFFEE</h1><p>c:cross-layer optimization for fast and efficient executions of the SK algorithm on HPC systems with clusters of compute nodes<br>在有计算节点集群的HPC系统上快速高效执行SK算法。<br><strong>算法中：行、列都可以重新缩放</strong>，<strong>列缩放相较行缩放极其缓慢</strong>。<br>在多节点上的性能比单节点提升最高7.5倍，平均2倍；与天河一号的MPI Allreduce算法比，最高2.9，平均1.6.<br>SK算法：a simple but very useful iterative method to approach the double stochastic matrix of Sinkhorn’s theorem by alternately rescaling all rows and all columns of the given matrix.<br>对矩阵进行缩放列。</p>
<p>现存的SK算法大多用去搞强化学习了（应用层），或者去加速收敛，很少有研究从计算机系统架构的角度考虑改进算法，特别是高性能计算（HPC）系统。HPC有他自己独特的计算、存储以及交流能力，看看是否能发挥全部潜力。SK算法在四个代表性应用的时间占比都超过一半（BALS的卷积也这样）所以就去优化。</p>
<p><strong>这篇论文用MPI，通过多核、多节点集群加速SK算法。</strong><br>先分析经典算法在天河1上。<br>列缩放的时间远超行缩放，原因是<strong>通过列缩放进行的内存访问是高度非连续的，这导致了较高的缓存未命中率。</strong><br>解决方法：<strong>探险重新设计列缩放以及信息阻塞</strong>去减少缓存未命中；设计微核并且重新设计指令去<strong>增加并行性</strong></p>
<p>优化思想：通用矩阵乘法、分层<br>分层的思想在MPI Allreduce算法（MPI_Allreduce 是 MPI（消息传递接口）中的一个函数，用于在所有进程之间<strong>进行归约操作并广播结果。</strong>）的相关优化中非常常见。</p>
<p>选择SALaR（？）作为基准去研究。发现：实现Allreduce可以与SK算法的其他任务进行overlap（重叠）进一部提高性能   </p>
<h2 id="本篇文章的主要contribution"><a href="#本篇文章的主要contribution" class="headerlink" title="本篇文章的主要contribution"></a>本篇文章的主要contribution</h2><ul>
<li>我们分析了 SK 算法在 HPC 集群上的执行行为，并观察到两个主要的性能挑战。首先是其列重新缩放表现出高度非连续的内存访问模式，这导致非常高的缓存未命中率，从而大大降低了整体性能。第二，即使采用 Foster 的方法设计，列重新缩放也会严重限制并行性</li>
<li>我们提出了 COFFEE，这是一种新颖的方法，它实现了多级优化设计，以优化 HPC 系统中大规模 SK 算法的处理（第 IV 节）。我们通过增强 MPI Allreduce 来提高并行效率，采用有效的领导者-工作者机制，尽可能重叠节点间(intra-node)通信、节点内通信和节点内计算</li>
<li>我们在天河一号超级计算机上评估了 COFFEE 的原型实现，证明了其与 SOTA 解决方案相比具有显著的性能优势（第六节）。我们的实验结果表明，COFFEE 分别在单节点和多节点环境中带来了高达 7.5 倍和 2.9 倍的性能提升。</li>
</ul>
<h2 id="SK算法"><a href="#SK算法" class="headerlink" title="SK算法"></a>SK算法</h2><p>双随机矩阵,sk算法就是在行列都归一化后，每行元素相加都为1，每列元素相加也都为1<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328202355119.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sinkhorn</span>(<span class="params">A, max_iter=<span class="number">1000</span>, tol=<span class="number">1e-6</span></span>):</span><br><span class="line">    A = np.array(A, dtype=np.float64)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        A_prev = A.copy()</span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 行归一化</span></span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 列归一化</span></span><br><span class="line">        <span class="keyword">if</span> np.allclose(A, A_prev, atol=tol):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">A = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">3</span>, <span class="number">4</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>]])</span><br><span class="line">B = sinkhorn(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Row sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Col sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328203003067.png"></p>
<p>选SK算法而不是和其他算法有两重原因：</p>
<ul>
<li>现在主流的线性代数库（如 BLAS、NumPy、PyTorch 等）在进行矩阵乘法时，底层通常使用的是最基础的“三重循环”实现方式，而不是像 Strassen 或 Coppersmith-Winograd 这样的快速乘法算法。就像基本的矩阵乘法实现一样，最原始的 Sinkhorn-Knopp（SK）算法也<strong>更容易从计算机系统架构的角度进行优化</strong>。</li>
<li>现有的 SK 算法研究主要集中于通过<strong>减少矩阵缩放迭代次数</strong>来加快收敛速度​​，但我们的目标是<strong>减少每次迭代的时间</strong>。</li>
</ul>
<p>我们不再去限制每一行&#x2F;每一列的和接近1，而是去最后计算的时候让行&#x2F;列和为1，在计算结果之前不需要让它接近1。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328205256791.png"></p>
<p>Intel团队用Python。为了在超算上运行，我们选C实现，是他们SOTApython的重写，有循环展开和数据并行优化，并且性能不逊于他们。</p>
<p>串行处理行列缩放,明显看到列用了十几倍的时间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328212937491.png"></p>
<h2 id="介绍典型的并行算法"><a href="#介绍典型的并行算法" class="headerlink" title="介绍典型的并行算法"></a>介绍典型的并行算法</h2><p>关键点：如何分割数据和任务让交流<strong>少一些</strong>，让计算任务更<strong>稳定</strong>。<br>处理方法：把矩阵按行划分成多个子矩阵，每个处理器只负责其中一些行，这样在<strong>行归一化</strong>的时候每个处理器只需要处理自己的行，不需要通信；最后让通信发生在<strong>列归一化</strong>阶段，这部分可以统一优化。这样目的是<strong>把本地能算的留在本地，只在必要时跨节点通信</strong>。<br>算法执行被拆成四步：</p>
<ul>
<li>每个进程独立地对自己那一块行子矩阵进行行归一化（和算法1的第1–10行一样），不需要通信；</li>
<li>每个进程计算自己那部分子矩阵的列和；</li>
<li>调用 MPI_Allreduce 汇总所有进程的列和，得到全矩阵每列的总和；</li>
<li>每个进程根据上一步得到的列缩放因子，独立地对自己那块子矩阵做列归一化。<br>这样做能最大限度减少通信，仅在列缩放因子计算这一步使用 MPI，有利于并行效率。</li>
</ul>
<h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p>在计算并行效率的时候，列缩放时处理器数为16的效率也骤降？<br>原因：<strong>行缩放</strong>的时候不需要进行通信，所有的处理器被平衡地加载；但到<strong>列缩放</strong>的时候处理器在等数据。<br><em>The reason is that the row rescaling is communication free and all the processors are load balanced. While for the column rescaling, the Allreduce used to find the column sum performs a lot of inter-node and intra-node communication, so that some processors are in the process of waiting for data</em> </p>
<h2 id="Motivation-of-COFFEE"><a href="#Motivation-of-COFFEE" class="headerlink" title="Motivation of COFFEE"></a>Motivation of COFFEE</h2><p>我们看到了在并行处理行缩放时候节点内的通信花费了太多时间，大大降低效率；因此我们想利用节点的不同通信特点，然后提升效率。</p>
<p>算法设计-微核设计-MPI优化</p>
<h2 id="CPU-ORIENTED-OPTIMIZATION"><a href="#CPU-ORIENTED-OPTIMIZATION" class="headerlink" title="CPU-ORIENTED OPTIMIZATION"></a>CPU-ORIENTED OPTIMIZATION</h2><p>列重排算法设计（Algorithm1和2的对比）</p>
<h2 id="Micro-kernel-redesign"><a href="#Micro-kernel-redesign" class="headerlink" title="Micro-kernel redesign"></a>Micro-kernel redesign</h2><p>采用SIMD：SIMD（Single Instruction, Multiple Data，单指令多数据流）是一种并行计算技术，它让一个指令同时处理多个数据。常用于图像处理、音频处理、科学计算等场景，加速处理速度，提升性能。<br>采用AVX2指令集：AVX2（Advanced Vector Extensions 2）是Intel推出的SIMD指令集扩展，属于x86架构的一部分。它在AVX的基础上增强了整数运算能力，支持256位宽的YMM寄存器，可以并行处理更多数据，广泛用于图像处理、机器学习等高性能计算中。<br>修改汇编指令</p>
<h2 id="MPI-optimization"><a href="#MPI-optimization" class="headerlink" title="MPI optimization"></a>MPI optimization</h2><h3 id="节点内Reduce算法优化"><a href="#节点内Reduce算法优化" class="headerlink" title="节点内Reduce算法优化"></a>节点内Reduce算法优化</h3><p>二叉树效率低是因为每个处理器开销不同，尤其在根节点，其他处理器都空闲（idle），<strong>加载不均</strong>。<br>为了解决这种严重的负载不均衡问题，我们重新设计了SK算法的Reduce实现，将本地和数组分成几部分。在节点内Reduce之后，每个worker保留本地最终和的一部分并以非阻塞方式将其发送给leader。我们的节点内Reduce实现基于MPI标准原语MPI_Send和MPI_Recv，与MPICH库中Reduce的实现一致。我们没有使用打包技术，因为要传递的数据几乎是连续的，打包带来的额外开销超过了使用它带来的性能提升。</p>
<h3 id="节点间AllReduce算法优化"><a href="#节点间AllReduce算法优化" class="headerlink" title="节点间AllReduce算法优化"></a>节点间AllReduce算法优化</h3><p>我们使用最流行的 Ring 算法实现 Allreduce，以生成列重新缩放的全局最终总和。Ring Allreduce 的一个缺点是它没有考虑节点的层次结构。一般来说，节点之间的带宽远低于节点内的带宽。因此，最近提出了分层 Ring Allreduce。<br>图 7 显示了我们基于分层环的优化。<br>主要思想是重叠节点内 Reduce 和节点间 Allreduce 的时间。我们将本地和数组分成几个数据块。如前所述，对数据块进行 allreduce 有三个连续步骤。首先，工作者对本地和的块执行节点内 Reduce，并将本地最终总和发送给领导者（图 7 中时间 1 的红色箭头）。接下来，领导者对全局最终总和执行节点间 Allreduce（图 7 中时间 2 的红色箭头）。最后，领导者将全局最终总和广播给其工作者（图 7 中时间 3 的红色箭头）。发现不同数据块的顺序步骤可以重叠。例如，图 7 中的时间 2 表示第 i 个数据块的节点间 Allreduce（红色箭头）和第 (i + 1) 个数据块的节点内 Reduce（黑色箭头）可以同时处理。因此，我们在为 SK 算法实现 Allreduce 时将管道的思想结合到分层环中。</p>
<h3 id="重叠通信和计算优化"><a href="#重叠通信和计算优化" class="headerlink" title="重叠通信和计算优化"></a>重叠通信和计算优化</h3><p>当领导者执行 Allreduce 时，工作者必须停滞。我们利用这段停滞时间让工作者修改节点内的矩阵。在我们对 SK 算法的优化 Allreduce 设计中，矩阵修改的计算被添加到流水线中。<br><strong>同时完成 Allreduce 的通信任务和修改子矩阵的计算任务</strong></p>
<h2 id="experiment-evaluation"><a href="#experiment-evaluation" class="headerlink" title="experiment evaluation"></a>experiment evaluation</h2><h3 id="Experimental-Setup"><a href="#Experimental-Setup" class="headerlink" title="Experimental Setup"></a>Experimental Setup</h3><p>为了评估 COFFEE 的有效性，我们将其两个版本进行比较，即面向 CPU 的优化（第 IV 节），表示为 COFFEE-CPU，以及面向 MPI 的优化（第 V 节），表示为 COFFEE-MPI，与 SK 算法的两个现有实现进行比较，一个使用 Ring Allreduce 算法（MPICH-Ring），另一个在 MPICH 环境中使用 SALaR（MPICH-SALaR）<br>高密度矩阵（非零元素占 95%）、中等密度矩阵（非零元素占 50%）、稀疏矩阵（非零元素占 5%）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250330172903583.png"><br>只去算非零矩阵。</p>
<h3 id="CPU-Oriented-Optimization"><a href="#CPU-Oriented-Optimization" class="headerlink" title="CPU-Oriented Optimization"></a>CPU-Oriented Optimization</h3><p>在AMD平台上使用GCC编译器运行的SK算法通过我们的优化获得了最大的改进。在ARM平台上使用Clang编译器，SK算法的典型实现的性能在所有平台上都是最好的，但我们的优化在M &#x3D; N &#x3D; 16,000时仍实现了3.3倍的加速比。</p>
<h3 id="MPI-Oriented-Optimization"><a href="#MPI-Oriented-Optimization" class="headerlink" title="MPI-Oriented Optimization"></a>MPI-Oriented Optimization</h3><h2 id="conclusion-and-further-work"><a href="#conclusion-and-further-work" class="headerlink" title="conclusion and further work"></a>conclusion and further work</h2><p>SK算法在机器学习等领域的重要性日益凸显。本文提出并实现了一种针对SK算法实现的计算和通信的跨层优化设计，称为COFFEE。与大多数现有的通过减少缩放迭代次数来加快收敛速度​​的工作不同，COFFEE着重于通过缩短每次缩放迭代来加快收敛速度​​。我们对SK算法实现中影响性能的问题进行了深入研究。发现列缩放会导致较高的缓存未命中率和较低的并行效率。我们使用列缩放重新设计、数据分块和微内核设计等跨层优化来加速列缩放。我们还根据SK算法的特点优化了MPI Reduce和Allreduce，以提高并行效率。最后，我们在天河一号超级计算机上验证了COFFEE 的有效性。未来我们计划进一步探索和利用行缩放和列缩放之间的相关性。此外，我们计划结合GPU，充分利用异构并行计算架构，进一步提高 COFFEE 的性能。最后，我们计划研究 COFFEE 在 SK 算法稀疏矩阵上的性能，其中数据不是以数组格式存储的。</p>
<h1 id="HSMU-SpGEMM"><a href="#HSMU-SpGEMM" class="headerlink" title="HSMU-SpGEMM"></a>HSMU-SpGEMM</h1><p>High Shared Memory Utilization for Parallel Sparse General Matrix-Matrix Multiplication on Modern GPUs<br>在现代 GPU 上实现并行稀疏通用矩阵-矩阵乘法的高共享内存利用率(utilization)</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统的基于哈希的方法无法在减少哈希冲突和有效利用快速共享内存之间取得平衡，这严重损害了在 GPU 上执行 SpGEMM 的性能。设计了一种<strong>累加器</strong>，四个通用库在三种架构上面跑，**HSMU有显著的加速优势。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Gustavson算法在GPU上用于实现快速并行稀疏矩阵乘法时有两个流程：<strong>符号阶段(symbolic stage)<strong>以及</strong>数值阶段(numeric stage)</strong> </p>
<ul>
<li>符号阶段的主要任务是去确定矩阵C中非零元素的数量(NNZ)，以便在数值计算的时候<strong>预先分配内存</strong></li>
<li>数值阶段在已分配的内存上<strong>进行实际的乘法和累加</strong>，是整个SpGEMM<strong>最耗时的部分</strong><br>高效的累加器设计对数值阶段的性能至关重要。<br>单纯<strong>增加</strong>哈希表的容量会降低GPU共享内存的利用率。<br>主流SpGEMM库的不足</li>
<li>Nsparse 虽利用最大 NNZ 设置哈希表长度以提高共享内存利用率，但哈希冲突严重，性能下降</li>
<li>spECK 通过分配 1.5× 空间减少冲突但造成约 34% 内存浪费</li>
<li>OpSparse 建议设为 2× 最大 NNZ，性能好但共享内存利用率仅达 50%<br><strong>HSMU-SpGEMM 通过为每个累加器内核维护一个按列排序的数组（长度为分配行的最大 NNZ）来避免哈希冲突，并针对小规模与大规模矩阵设计不同的符号阶段，从而在优化 GPU 共享内存利用率下的同时保持低冲突率，实现高性能 SpGEMM。</strong></li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Gustavson 算法具有天然的并行性，因为它可以独立计算矩阵 C 的每一行。在数值阶段，矩阵 A 中每个非零元素 𝑎𝑖𝑗会与矩阵 B 中对应行𝑏𝑗∗的非零元素相乘，生成大量中间结果，这些结果的列索引与 B 中元素的列索引一致。最终，通过累加器将这些中间结果累加到矩阵 C 的相应位置。累加器的具体设计将在下一小节介绍。<br>分为两种累加器：<strong>稠密型</strong>和<strong>稀疏型</strong></p>
<ul>
<li><p>稠密累加器使用稠密数组存储中间结果，通常由三个向量组成：一个存储实际数值，一个用于标记列索引是否插入，另一个记录列索引。这种方法在处理稠密行时效率高，但对稀疏行内存需求大、性能较差。</p>
</li>
<li><p>稀疏累加器则按累加方式分为三类：基于合并、ESC 和哈希的累加器。</p>
</li>
<li><p>基于合并的稀疏累加器在 RMerge和 bhSPARSE等库中实现。这些累加器执行多次迭代，每次迭代将一个 NZ(Non-zero) 元素垂直合并到最终的稀疏向量中。由于在合并过程中使用了大小相同的临时数组，因此基于合并的稀疏累加器对于密度变化较大的矩阵表现出<strong>较低的内存利用率</strong>。</p>
</li>
<li><p>ESC 方法在处理生成大量中间产品的矩阵时存在不足。由于存储和分类大量中间产品会产生大量的空间开销和时间成本，因此效率低下。</p>
</li>
</ul>
<h2 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h2><p>除了寄存器文件之外，共享内存是 GPU 上最快的内存类型。共享内存的主要优点是它<strong>允许多个线程共享数据</strong>，这使得共享内存成为高效并行计算的关键 GPU 组件。共享内存可供单个线程块内的所有线程访问，并且可以将其视为可编程缓存或暂存器，在其中放置经常访问的数据。但是，GPU 上的共享内存容量有限。所以高性能共享内存是非常重要的对于现代GPU。</p>
<h1 id="MOTIVATION-OF-THE-WORK"><a href="#MOTIVATION-OF-THE-WORK" class="headerlink" title="MOTIVATION  OF THE WORK"></a>MOTIVATION  OF THE WORK</h1><h2 id="Principles-of-Hash-based-Accumulators"><a href="#Principles-of-Hash-based-Accumulators" class="headerlink" title="Principles of Hash-based Accumulators"></a>Principles of Hash-based Accumulators</h2><p>现有的哈希累加器要去平衡<strong>共享内存利用率</strong>和<strong>哈希碰撞率</strong></p>
<h2 id="Philosophy-of-HSMU-SpGEMM-Accumulator-Design"><a href="#Philosophy-of-HSMU-SpGEMM-Accumulator-Design" class="headerlink" title="Philosophy of HSMU-SpGEMM Accumulator Design"></a>Philosophy of HSMU-SpGEMM Accumulator Design</h2><ul>
<li>引入一个预排序列索引数组（sorted column indices array）表示 C 的非零列。使用 findInSorted(colIp, sortedColArray) 函数来定位每个中间乘积，直接查找中间乘积该落在哪个已知列上。<strong>完全消除哈希冲突，查找位置准确，无需哈希函数或冲突处理。</strong></li>
</ul>
<h1 id="HSMU-SPGEMM"><a href="#HSMU-SPGEMM" class="headerlink" title="HSMU-SPGEMM"></a>HSMU-SPGEMM</h1><h2 id="HSMU-SpGEMM-Accumulator-Design"><a href="#HSMU-SpGEMM-Accumulator-Design" class="headerlink" title="HSMU-SpGEMM Accumulator Design"></a>HSMU-SpGEMM Accumulator Design</h2><p>采用<strong>二分查找</strong>而不是哈希，<strong>可以低开销，高效率，并且很稳定</strong>。<br>有以下好处</p>
<ul>
<li>哈希法相对于二分查找法的最大优势在于，在哈希表中添加或删除项目的成本要低得多。然而，在 HSMU-SpGEMM 中，排序数组是在符号阶段预先确定的，因此我们的新累加器不需要在数字阶段更改排序数组。因此，二分查找法中维护排序结构的缺点不存在；</li>
<li>哈希表的一个缺点是，当发生碰撞时，它会影响其他哈希位置，并可能导致链式碰撞，导致哈希性能低下。而对于二分查找，其性能稳定，最坏情况为O（logN）。在这种情况下，二分查找优于哈希查找方法；</li>
<li>二分查找更适合于范围查询等复杂操作。在这种情况下，每个线程通过不断更新变量pos逐渐缩小共享col数组上的搜索范围，从而在一定程度上减少查找次数；尽管如此，对于密集和大数据，二分查找的最坏时间复杂度为O(logN)，而哈希表的理想时间为O(1)。时间复杂度的增加可能会在某些情况下降低我们的累加器设计的搜索性能。</li>
</ul>
<h2 id="Generate-the-Sorted-Ccol-Array"><a href="#Generate-the-Sorted-Ccol-Array" class="headerlink" title="Generate the Sorted Ccol Array"></a>Generate the Sorted Ccol Array</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250408135942607.png"><br>先生成maskB，对于每一行B，非零元素位置标记为1，其他为0。<br><strong>不太懂</strong>生成maskC的原理。</p>
]]></content>
  </entry>
  <entry>
    <title>LearningHPC</title>
    <url>/2025/03/28/LearningHPC/</url>
    <content><![CDATA[<h2 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants\0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现图片的打开。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172122965.png"><br>因为在python里面\t或者是\n是转义字符，<strong>直接加r表示这就是原始语义</strong>。</p>
<p>如果要读取一个文件夹里的许多图片，需要用到os库，然后使用列表的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dir_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants&quot;</span></span><br><span class="line">img_path_list = os.listdir(dir_path)</span><br></pre></td></tr></table></figure>
<p>最后达到右边的效果<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172705602.png"></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2025/03/30/LeetCode/</url>
    <content><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h3 id="2025-3-30"><a href="#2025-3-30" class="headerlink" title="2025.3.30"></a>2025.3.30</h3><p><a href="https://leetcode.cn/problems/make-the-string-great/submissions/617067145/">栈专题</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">makeGood</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">abs</span>(res.<span class="built_in">back</span>() - c) == <span class="number">32</span>) &#123;</span><br><span class="line">            res.<span class="built_in">pop_back</span>(); <span class="comment">// 删除上一个相反大小写的字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果栈空，直接插入；如果栈非空，比较当前插入的字符和栈内的字符ascii码差值是否为32，<strong>32为大小写关系</strong>。</p>
<p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/description/">左右元素和的差值</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftRightDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + nums[i + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            res[i] = <span class="built_in">abs</span>(left[i] - right[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/non-decreasing-array/description/">非递减数列</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                    nums[i<span class="number">+1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> nums[i] = nums[i<span class="number">+1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键在于你要去改，通过当前数的左右两边数来判断是要去改这个数大还是改这个数小，改完之后接着往下去比。<br>3 4 2 3，到了4，4大于2，发现num[i-1] &gt; num[i+1] ，如果想要满足题目的非递减，那就要把num[i+1] &#x3D; num[i]，把这个数字改大，现在序列变成了3 4 4 3，到了下一个i，4&gt;3，这时候cnt++，就跳出循环了。<br>1 4 2 3，到了4，发现要把num[i]改小，所以num[i] &#x3D; num[i+1]。</p>
<h3 id="2025-3-31"><a href="#2025-3-31" class="headerlink" title="2025.3.31"></a>2025.3.31</h3><p><a href="https://leetcode.cn/problems/reverse-bits/">颠倒二进制串</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(n&amp;<span class="number">1</span>);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>|stk[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用了位运算，第一个for循环让这整个字符串和1与（1写成二进制是000…001，所以只会剩下最后一位），然后把最后一位插入stk里；第二个for循环先让res左移一位(<strong>左移相当于后面补0，0补再多的0还是0</strong>)，不然会最后多一个0，因为初始化的时候我们已经给了一个0给他了，然后再和数组进行或运算。</p>
<p><a href="https://leetcode.cn/problems/power-of-two/description/">2的幂</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>今天运气真的好，又遇到了一道<strong>位运算</strong>，而且这个设计的真的很巧妙，以后遇到二进制&#x2F;幂要想到<strong>位运算</strong>。 比如8和7，8是1000，7是0111，只要他是2的幂，就一定和他的差与为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入两个整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = a &amp; b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个数 (&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;) 的二进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二个数 (&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;) 的二进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;两个数相与的结果: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(result) &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用这个程序来看看二进制出来的结果。</p>
<p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">汉明距离</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>) cnt++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已经初步掌握位运算了，还是挺开心。</p>
<p><a href="https://leetcode.cn/problems/ransom-note/description/">赎金信</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            a[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            a[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (a[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实就是字符统计，统计看看资源够不够，但是这一题我一开始犯了一个错误，我定义的是<strong>char</strong>类型的数组，这有一个很严重的问题，char存储只能-127 ~ 128，如果同一个数多了，比如128，那再遇到下一个这个字母数组的值马上变成-127，问题就在这！<br>然后是要用<strong>字母-‘a’</strong>，因为a的ASCII码值为97，z的码值为122，差最多就是25，所以创一个26大小的就可以了。</p>
<p><a href="https://leetcode.cn/problems/hamming-distance/description/">汉明距离</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> xorR = x^y;</span><br><span class="line">        <span class="keyword">while</span> (xorR&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += xorR&amp;<span class="number">1</span>;</span><br><span class="line">            xorR&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是使用异或，不同位异或结果是1，然后统计1的个数就可以了。<br><a href="https://leetcode.cn/problems/n-th-tribonacci-number/description/">第N个泰波那契数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="type">int</span> temp = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是斐波那契额递归的优化版，用递归太耗费时间了，我们在n大于3的时候用for循环，找到规律f(n) &#x3D; f(n-3)+f(n-2)+f(n-1)，最后输出f(n)</p>
<h3 id="2025-4-1"><a href="#2025-4-1" class="headerlink" title="2025.4.1"></a>2025.4.1</h3><p><a href="https://leetcode.cn/problems/valid-mountain-array/description/">有效地山脉数组</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (size&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span>&lt;size &amp;&amp; arr[i]&lt;arr[i<span class="number">+1</span>]) i++;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span> || i == size<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span>&lt;size &amp;&amp; arr[i]&gt;arr[i<span class="number">+1</span>]) i++;</span><br><span class="line">            <span class="keyword">return</span> i == size<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>先从头开始往上爬，找峰顶</li>
<li>再从峰顶往下走；</li>
<li>最后判断是否正好走到结尾。</li>
</ul>
<p><a href="https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/description/">元素计数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">num</span> (nums);</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = num[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> min = num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> cnnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i&lt;nums.<span class="built_in">size</span>() ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]!=max &amp;&amp; num[i]!= min) cnnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是去找非最大和非最小的元素。<br><a href="https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/description/">数字小镇中的捣蛋鬼</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSneakyNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            count[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(a.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希表，键值对的问题。<br><strong>特别注意</strong>：unordered_map不能通过下标去访问，而是通过<strong>键</strong>去访问数据的<br><a href="https://leetcode.cn/problems/happy-number/">快乐数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getValue</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum)!=s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">insert</span>(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>find返回的是<strong>迭代器</strong>的值，迭代器可以理解为一个指向该元素的<strong>指针</strong>，当迭代器返回的值是a.end()代表<strong>没有找到这个元素</strong>，所以我们在判断条件中使用<strong>s.find(num)<strong>得到的是一个迭代器的值，而不是布尔值，如果它不等于s.end()，那就说明已经存在了。 <em>s.end()指向的是最后一个元素的下一个位置</em><br>当我们进入</strong>无限循环</strong>的时候去想想<strong>哈希表</strong>的思路，哈希表可以快速查找。</p>
<p><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            res =a^res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>①任何数和自己异或就是0，最后剩下的那个数就是只出现过一次。<br>②用map，出现就值+1，去遍历值为1的。<br><a href="https://leetcode.cn/problems/majority-element-ii/">多数元素Ⅱ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> times = nums.<span class="built_in">size</span>() / <span class="number">3</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : nums) &#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; times) &#123;</span><br><span class="line">                a.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希表使用的已经比较熟练了，现在问题在于对map的取键值对语法总是忘记，以后就规范用auto，auto自动推导为迭代器，然后用.访问符就可以访问键&#x2F;值了。</p>
<h3 id="2025-4-2"><a href="#2025-4-2" class="headerlink" title="2025.4.2"></a>2025.4.2</h3><p><a href="https://leetcode.cn/problems/isomorphic-strings/description/">同构字符串</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,<span class="type">char</span>&gt; ms,mt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> a = s[i],b = t[i];</span><br><span class="line">            <span class="keyword">if</span> (ms.<span class="built_in">count</span>(a)&amp;&amp;ms[a]!=b || mt.<span class="built_in">count</span>(b)&amp;&amp;mt[b]!=a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ms[a] = b;</span><br><span class="line">            mt[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希表的运用，双射，如果我在a中找到了这个字符，并且我的映射不等于b中的字符，就return false<br><a href="https://leetcode.cn/problems/word-pattern/description/">单词规律</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector &lt;string&gt; <span class="built_in">Split</span>(string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span>(iss&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            words.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,string&gt; m;</span><br><span class="line">        unordered_map &lt;string,<span class="type">char</span>&gt; m1;</span><br><span class="line">        vector&lt;string&gt; cc = <span class="built_in">Split</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;pattern.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.<span class="built_in">size</span>()!=cc.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> a = pattern[i];</span><br><span class="line">            string b = cc[i];</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(a)&amp;&amp;m[a]!=b || m<span class="number">1.</span><span class="built_in">count</span>(b)&amp;&amp;m1[b]!=a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[a] = b;</span><br><span class="line">            m1[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>istringstream 是 C++ 标准库 <sstream> 中的类，用于从字符串中像从流（例如 cin）中一样提取数据。它常用于字符串的“切割”或格式化读取。</sstream></p>
<ul>
<li>iss &gt;&gt; word 会跳过空格，自动提取下一个以空格分隔的单词。</li>
<li>也可以提取数字等，比如：int x; iss &gt;&gt; x;</li>
<li>适合用来解析以空格、换行等分隔的字符串数据。<br>要保证他是双向映射的，所以需要两个哈希表来维护。</li>
</ul>
<h3 id="2025-4-9"><a href="#2025-4-9" class="headerlink" title="2025.4.9"></a>2025.4.9</h3><p><a href="https://leetcode.cn/problems/unique-paths/description/">不同路径</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line">        <span class="comment">//vector &lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,1));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span> (i==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> dp[i][j] = dp[i][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以先从一维的动态规划数组理解，斐波那契数列1 1 2 3 5 8……dp[0] &#x3D; 1，dp[1] &#x3D; 1,从2开始往后的就是dp[i] &#x3D; dp[i-1]+dp[i-2]<br>现在是二维的图，就要去分成小的子问题，用子问题倒推回最难的问题，画一个表格就一目了然了。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250409174221016.png"><br>看这张图，只能向右或者向下移动，那我们把机器人旁边的格子设为终点，机器人有几条路可以到终点呢？只有一条，机器人斜对角也就是dp[i-1][j-1] &#x3D; dp[i][j-1] + dp[i-1][j]两种方案合起来。</p>
<h3 id="2025-4-10"><a href="#2025-4-10" class="headerlink" title="2025.4.10"></a>2025.4.10</h3><p><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用<strong>快慢指针法</strong>，先判断当前这个数字是不是想要的值，如果不是就让它往后滚动。</p>
<p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">反转字符串中的元音字母</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvowel</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">        <span class="keyword">return</span> (c==<span class="string">&#x27;a&#x27;</span> || c==<span class="string">&#x27;e&#x27;</span> || c==<span class="string">&#x27;i&#x27;</span> || c==<span class="string">&#x27;o&#x27;</span> || c==<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left &amp;&amp; !<span class="built_in">isvowel</span>(s[left])) left++;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left &amp;&amp; !<span class="built_in">isvowel</span>(s[right])) right--;</span><br><span class="line">            <span class="keyword">if</span> (right&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用双指针来实现，两边都去找元音，都找到了就交换。</p>
<h3 id="2025-4-11"><a href="#2025-4-11" class="headerlink" title="2025.4.11"></a>2025.4.11</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">反转链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    	ListNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">    	ListNode *cur = head;</span><br><span class="line">    	<span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		ListNode *temp = cur-&gt;next;</span><br><span class="line">    		cur-&gt;next = p;</span><br><span class="line">    		p = cur;</span><br><span class="line">    		cur = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>采用<strong>头插法</strong>，不要自己空想一个头出来！！！！！现在全世界没人比我更懂链表！</p>
<h3 id="2025-4-12"><a href="#2025-4-12" class="headerlink" title="2025.4.12"></a>2025.4.12</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">移除链表元素</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        ListNode *q = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        q = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">                ListNode *cur = p-&gt;next;</span><br><span class="line">                q-&gt;next = cur;  <span class="comment">// 这里更新了q指向的节点，跳过p</span></span><br><span class="line">                <span class="keyword">delete</span> p;       <span class="comment">// 删除p节点</span></span><br><span class="line">                p = cur;        <span class="comment">// p继续前进</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;  <span class="comment">// 返回新头节点</span></span><br><span class="line">        <span class="keyword">delete</span> dummy;  <span class="comment">// 删除虚拟头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在应该彻底搞懂链表到底是什么了，其实不是链表的知识不懂，是<strong>函数传参</strong>出现了问题，这个函数传进来的<strong>是一个head节点，它指向链表的头部</strong>，而不是传一个链表进来，函数前几行定义了一个虚拟的头节点，让前后两个指针往后遍历。最后返回的时候不能return q，因为q节点已经遍历完链表了啊。</p>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">删除链表倒数的第N个节点</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        ListNode *q = dummy;</span><br><span class="line">        <span class="type">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *toDelete = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = toDelete-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelete;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在已经把函数传参的问题解决了，以后要多画图，像今天蓝桥杯画图就解决出来了，然后是找到倒数第N个节点，我们先虚构出一个头节点，让一个指针先走N步，然后两个指针一起往后挪动，如果前面的指针下一个是空，那说明我们后面出发的指针下一位置就是要删除节点了，我们就采用删除节点的方法，创建一个新指针指向要被删除的节点，再把链表连接起来。</p>
<h3 id="2025-4-13"><a href="#2025-4-13" class="headerlink" title="2025.4.13"></a>2025.4.13</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *newlink = dummy;</span><br><span class="line">        ListNode *p = list1;</span><br><span class="line">        ListNode *q = list2;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &gt;= q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                newlink = newlink-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;val &gt;= p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                newlink = newlink-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newlink-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newlink-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *res = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>今天对链表的掌握程度更上一层楼了，记住要画图进行需求分析，这样不容易乱，还有在堆内存的释放。</p>
<p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">逆波兰表达式求值</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left+right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left - right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left*right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left/right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;</span><br><span class="line">                (a[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;/&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> right = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> left = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> val = <span class="built_in">cal</span>(left,right,a[<span class="number">0</span>]);</span><br><span class="line">                    s.<span class="built_in">push</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(a));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>逆波兰表达式也就是后缀求值，遇到数字就入栈，遇到符号就从栈里面取出两个数字进行运算。先pop出来的值作为等号右边的值，后pop出来的是等号左边的值。</p>
<p><a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a><br>希尔排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> gap = nums.<span class="built_in">size</span>()/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = gap;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> val = nums[i];</span><br><span class="line">                <span class="type">int</span> j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> ( ; j&gt;=<span class="number">0</span> ; j-=gap)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val &gt;= nums[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums[j+gap] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + gap] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后面慢慢更其它的。</p>
<h3 id="2025-4-14"><a href="#2025-4-14" class="headerlink" title="2025.4.14"></a>2025.4.14</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">反转字符串中的单词</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (ss&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        string sres;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                sres += res[i]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sres +=res[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用istringstream读取原字符串，然后将分割出来的单词插入进数组，反向遍历。<br><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">删除字符串中的所有相邻重复项</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;<span class="type">char</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">            	res.<span class="built_in">push</span>(s[i]);	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (res.<span class="built_in">top</span>()==s[i])</span><br><span class="line">            	&#123;</span><br><span class="line">                res.<span class="built_in">pop</span>();</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">            	&#123;</span><br><span class="line">                res.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            	&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(!res.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans += res.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>栈的应用，很简单。<br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">相交链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt2++;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 &gt;= cnt2)</span><br><span class="line">        &#123;</span><br><span class="line">            p = headA;</span><br><span class="line">            q = headB;</span><br><span class="line">            <span class="type">int</span> dif = cnt1 - cnt2;</span><br><span class="line">            <span class="keyword">while</span> (dif &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt2 &gt; cnt1)</span><br><span class="line">        &#123;</span><br><span class="line">            p = headA;</span><br><span class="line">            q = headB;</span><br><span class="line">            <span class="type">int</span> dif1 = cnt2 - cnt1;</span><br><span class="line">            <span class="keyword">while</span> (dif1 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                dif1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相交链表很有意思，在它们<strong>没有相交之前</strong>，如果第一个链表比第二个链表长，那就让长链表的指针先往下走这些差值，然后开始进行比较。<br><a href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">1.</span><span class="built_in">begin</span>(),num<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">2.</span><span class="built_in">begin</span>(),num<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxsize = <span class="built_in">max</span>(num<span class="number">1.</span><span class="built_in">size</span>(),num<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">res</span>(maxsize<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxsize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = i &lt; num<span class="number">1.</span><span class="built_in">size</span>() ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = i &lt; num<span class="number">2.</span><span class="built_in">size</span>() ? num2[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            res[i] += a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxsize<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]&gt;=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i<span class="number">+1</span>] += (res[i])/<span class="number">10</span>;</span><br><span class="line">                res[i]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string resS;</span><br><span class="line">        <span class="type">int</span> j = res.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;res[j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            resS += <span class="built_in">to_string</span>(res[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是在问你，如果超出了long long范围的加法，你怎么办？<br>用两个字符串来倒序相加，加进结果数组，如果这个数字大于等于10表明要进位，那就&#x2F;&#x3D;10，然后留下进位后的数，<strong>最后找前导0，找第一个非0元素，没找到就一直–</strong></p>
<h3 id="2025-4-15"><a href="#2025-4-15" class="headerlink" title="2025.4.15"></a>2025.4.15</h3><p><a href="https://leetcode.cn/problems/sort-list/description/">排序链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        ListNode *q = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *dummy = q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            dummy-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num);</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>排序用快排，先将链表中的所有数字取出来放到vector里，然后sort排序，最后使用for (int)遍历，不要用i来遍历，因为vector会自动扩容</p>
<h3 id="2025-4-16"><a href="#2025-4-16" class="headerlink" title="2025.4.16"></a>2025.4.16</h3><p><a href="https://leetcode.cn/problems/unique-number-of-occurrences/">独一无二的出现次数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b:m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.first!=b.first &amp;&amp; a.second==b.second)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用哈希表存储每一个数字出现的次数，然后两重循环遍历个数。<br><a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">第一个出现两次的字母</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (it==m.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">emplace</span>(a,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路：去遍历哈希表里是否有过这个字母（数字），如果没有，就把它添加进去，如果有，就说明是我们刚刚添加过的，它就是第二次出现的！<br><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中第k个最大元素</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;q.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用优先队列来实现，默认的优先队列是一个大顶堆，我们用大根堆来找前k个最小的数，如果想要设置为小根堆，需要priority_queue&lt;int,vector<int>,greater<int>&gt;，这是去找前k个最大的数；最后我们return q.top()即可得到第k个最大&#x2F;最小的数</int></int></p>
<h3 id="2025-4-18"><a href="#2025-4-18" class="headerlink" title="2025.4.18"></a>2025.4.18</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">树的前序、中序、后续遍历</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode *node,vector&lt;<span class="type">int</span>&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InOrder</span>(node-&gt;left,ans);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="built_in">InOrder</span>(node-&gt;right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">InOrder</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也是终于进入到树了，采用递归的思想去解决问题。</p>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node,<span class="type">int</span> level,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (node==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span> (level == ans.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    	ans[level].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    	<span class="built_in">dfs</span>(node-&gt;left,level<span class="number">+1</span>,ans);</span><br><span class="line">	    <span class="built_in">dfs</span>(node-&gt;right,level<span class="number">+1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里使用的是vector&lt;vector<int>&gt;,使用ans.size()返回的是这个二维数组的（行）层数，一开始行数为0，就创建一行，接下来递归调用，在当前level层里push node的数值。</int></p>
<p><a href="https://leetcode.cn/problems/subsets/description/">子集</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Res</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt; &amp;nums,vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">Res</span>(i<span class="number">+1</span>,nums,path);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="built_in">Res</span>(i<span class="number">+1</span>,nums,path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">Res</span>(<span class="number">0</span>,nums,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>今天开始学习回溯算法，回溯其实就是一直递归，递归到了子集树的叶子节点就处理这个子集，如果没有递归到这个子集，就处理<strong>选择</strong>或者<strong>不选择</strong></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>下标访问的复杂度为O(1)</li>
<li>末尾位置增加删除元素时间复杂度为O(1)  删除就是–，增加就是++</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>非末尾元素增加位置需要<strong>大量的数据移动</strong></li>
<li><strong>搜索的复杂度是O(n)</strong>  注意搜索和访问不是一个东西，搜索是遍历寻找这个值，而访问是a[0]–a[n-1]，在<strong>无序数组</strong>中采用遍历，是<strong>线性搜索</strong>；在<strong>有序数组</strong>中采用二分，复杂度为O(logn)</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>内存利用率高，不需要大块连续内存</li>
<li>插入和删除节点不需要移动其它节点，时间复杂度O(1)</li>
<li>不需要专门进行扩容操作</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>内存占用量大，每一个节点多出存放地址的空间</li>
<li>节点内存不连续，无法进行内存随机访问</li>
<li>链表搜索效率不高，只能从头节点开始逐节点遍历</li>
</ul>
<h4 id="内存碎片化"><a href="#内存碎片化" class="headerlink" title="内存碎片化"></a>内存碎片化</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411081508857.png"><br>现在我们有100M的内存空间（堆上），<strong>内存的释放是一块一块的，谁用完了谁就被释放了</strong>，如果将中间的20M和最右边的10M手动释放掉；我们就得到了两块内存碎片；现在我们有30M的空闲空间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411081846625.png"><br>如果现在进程运行需要25M的内存空间，我们能不能分配25M的数组呢？ <strong>不能</strong>，数组的内存是绝对连续的<br>在<strong>内存碎片</strong>过多的情况下，无法开辟大数组，这时候就可以用<strong>链表</strong>，每一个节点都是独立new出来的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411082625810.png"><br>从头节点访问到最后一个节点，最后一个节点的地址域为<strong>NULL</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> data = <span class="number">0</span>) : <span class="built_in">data_</span>(data),<span class="built_in">Next_</span>(<span class="literal">nullptr</span>)&#123;&#125; </span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">    Node *Next_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体其实就是一个public的类，现在写了一个<strong>Node</strong>的构造函数，如果不传参默认data就是0。为什么后面要加一个大括号？因为前面在初始化，初始化已经完成了，后面是函数体{}可以是空的。<br>不要总去判断当前节点的下一节点<strong>是否为空</strong>，老老实实判断当前节点是否为空，除非你真的要去找末尾节点。</p>
<h3 id="链表接口"><a href="#链表接口" class="headerlink" title="链表接口"></a>链表接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> data = <span class="number">0</span>):<span class="built_in">data_</span>(data),<span class="built_in">next_</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">	<span class="type">int</span> data_;</span><br><span class="line">	Node *next_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clink</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Clink</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//给head初始化，指向头节点 </span></span><br><span class="line">			head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Clink</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			Node *p = head;</span><br><span class="line">			<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				head = head-&gt;next_;</span><br><span class="line">				<span class="keyword">delete</span> p;</span><br><span class="line">				p = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//尾插法 复杂度O(n) 因为要遍历整个链表 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">InsertTail</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">//先找到当前链表的末尾节点</span></span><br><span class="line">			Node *p = head;</span><br><span class="line">			<span class="keyword">while</span>(p-&gt;next_!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = p-&gt;next_;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//生成新节点 </span></span><br><span class="line">			Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">			p-&gt;next_ = node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 头插法 复杂度O(1) 因为直接找到头节点的下一节点 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">InsertHead</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">			node-&gt;next_ = head-&gt;next_;</span><br><span class="line">			head-&gt;next_ = node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 链表单个节点删除 用双节点法 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			Node *q = p; <span class="comment">//q永远跟在p后面 </span></span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">				&#123;</span><br><span class="line">					q-&gt;next_ = p-&gt;next_;</span><br><span class="line">					<span class="keyword">delete</span> p;</span><br><span class="line">					<span class="keyword">return</span>; </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					q = p; </span><br><span class="line">					p = p-&gt;next_;</span><br><span class="line">						</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			Node *q = head;</span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">				&#123;</span><br><span class="line">					q-&gt;next_ = p-&gt;next_;</span><br><span class="line">					<span class="keyword">delete</span> p; <span class="comment">//delete只是释放指针指向的内存，指针本身不改变 </span></span><br><span class="line">					p = q-&gt;next_;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					q = p;</span><br><span class="line">					p = p-&gt;next_;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 打印链表 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;p-&gt;data_&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">				p = p-&gt;next_;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//搜索</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					p = p-&gt;next_;	</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">//指向链表的头节点 </span></span><br><span class="line">		Node *head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Clink c;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> val = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">		c.<span class="built_in">InsertHead</span>(val);</span><br><span class="line">		cout&lt;&lt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	c.<span class="built_in">InsertHead</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">InsertHead</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">InsertTail</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">show</span>();</span><br><span class="line">	c.<span class="built_in">RemoveAll</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>数组：下标访问&#x2F;随机访问多、搜索</li>
<li>链表：增加、删除多<br>不过还是要看插入哪里，如果插入中间位置都是O(n)</li>
</ul>
<p><strong>后续我自己rewrite发现语法出问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">mylink</span>()&#123;</span><br><span class="line">			<span class="function">Node <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="comment">//head = new Node();</span></span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">mylink</span>()&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>我一开始写的是没有注释的 <em>Node head()</em> 这样程序无法运行，为什么呢？因为这是一个<strong>函数声明</strong>，返回值为Node的函数声明！<strong>并没有创造出对象！<strong>所以我们需要new一个对象出来！<br>而且不要</strong>空想一个头节点</strong>，题目如果给你链表是:1,2,3,4,5。那就是这样，第一个节点就是头节点。</p>
<ul>
<li>单链表逆序 <strong>头插法</strong></li>
<li>单链表求倒数第k个节点 <strong>双指针，第一个指针先移动k</strong></li>
<li>合并两个有序的单链表 <strong>双指针比较大小</strong></li>
<li></li>
<li></li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出</p>
<h3 id="栈接口"><a href="#栈接口" class="headerlink" title="栈接口"></a>栈接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 c++stack push,pop, </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">SeqStack</span>(<span class="type">int</span> size = <span class="number">10</span>) : <span class="built_in">mtop</span>(<span class="number">0</span>),<span class="built_in">mcap</span>(size)</span><br><span class="line">		&#123;</span><br><span class="line">			mpStack = <span class="keyword">new</span> <span class="type">int</span>[mcap];</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">SeqStack</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> []mpStack;</span><br><span class="line">			mpStack = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//入栈 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mtop==mcap)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">expand</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			mpStack[mtop++] = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出栈</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mtop==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>;</span><br><span class="line">			mtop--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取栈顶元素</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mtop==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> mpStack[mtop<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//栈空</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mtop==<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mtop;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[mcap*<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;mcap;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				p[i] = mpStack[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> []mpStack;</span><br><span class="line">			mpStack = p;</span><br><span class="line">			mcap = <span class="number">2</span>*mcap;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> *mpStack;</span><br><span class="line">		<span class="type">int</span> mtop; <span class="comment">//栈顶位置 </span></span><br><span class="line">		<span class="type">int</span> mcap; <span class="comment">//栈空间大小 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="function">SeqStack <span class="title">stack</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		stack.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	stack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;stack.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		stack.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>环形队列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250413145914558.png"><br>不能用++，留下一个位置来判断是否为空</p>
<ul>
<li>入队:(rear+1)%length</li>
<li>出队（first+1）%length</li>
<li>满 (rear+1)%length &#x3D;first</li>
<li>空rear &#x3D; rear</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul>
<li>冒泡排序：相邻两两元素比较，值大&#x2F;小的元素往下交换；缺点：数据交换次数太多</li>
<li>选择排序：每次在剩下的数据选择最大&#x2F;最小的数据和当前元素进行交换；缺点：交换次数仍然多</li>
<li>插入排序：**如果数据趋于有序，那么插入排序是所有排序算法中效率最高的算法！**插入排序效率&gt;冒泡&amp;&amp;选择，不仅没有交换，而且比较的次数也少。</li>
<li>希尔排序：插入排序PLUS，从全局先将数据调整为趋于有序。对数据<strong>进行分组插入排序</strong></li>
<li>快速排序：<strong>选取一个基准数</strong>，把小于基准数的元素放到基准数左边，大于基准数的元素放在右边；<strong>然后对基准数两边的序列进行同样的操作</strong>（递归）</li>
<li>归并排序: 二路归并</li>
<li></li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;arr.<span class="built_in">size</span>()-i<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&gt;arr[j<span class="number">+1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j],arr[j<span class="number">+1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> a: arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bubble</span>(arr);</span><br><span class="line">	<span class="built_in">show</span>(arr);</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>冒泡排序就是像气泡一样，慢慢往下沉或慢慢往上浮，j循环是数组的大小-i-1;对于函数传参，我们如果定义普通的数组的话，传(int arr[],int n)，数组名就是一个指针。<br>复杂度：<strong>外层循环O(n)，内层循环也是一个O(n)，O(n方)</strong><br>为什么j是size-1-i，因为<strong>a[j]要和a[j+1]来比较，所以有-1</strong>，每一次排序都会排好一个数，所以-i，第一次没排好，第二次排了1个少循环一次。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> maxIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i;j&lt;arr.<span class="built_in">size</span>();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&gt;arr[maxIndex]) maxIndex = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i],arr[maxIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存放<strong>最大值&#x2F;最小值的</strong>下标，比较结束后用下标来索引交换。<br>复杂度O(n)<em>O(n)，是一个*<em>不稳定的排序算法</em></em> &#x2F;&#x2F;5 5 3,第一个5和3交换后这个5跑去后面了。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> val = arr[i];</span><br><span class="line">		<span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val&gt;=arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j<span class="number">+1</span>] = arr[j];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j<span class="number">+1</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250413173038592.png"><br>为什么i要从1开始？因为之前的序列默认有序了，定义j在外面是为下面能成功访问j。<br>时间复杂度最坏O(n)*O(n)，最好O(n)；空间O(1)。稳定性好，</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>()/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = gap;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> val = arr[i];</span><br><span class="line">			<span class="type">int</span> j = i-gap;</span><br><span class="line">			<span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j-=gap)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (val&gt;=arr[j])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				arr[j+gap] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">		arr[j+gap] = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)*O(n)最坏，最好O(n)，不稳定。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = arr[l]; <span class="comment">//最左边的当作基准数</span></span><br><span class="line">	<span class="comment">//l == r的位置就是放基准数的位置 </span></span><br><span class="line">	<span class="keyword">while</span> (l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp;arr[r] &gt; val)</span><br><span class="line">		&#123;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[l] = arr[r];</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;r&amp;&amp;arr[l]&lt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[r] = arr[l];</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[l] = val;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="built_in">Partition</span>(arr,begin,end);</span><br><span class="line">	<span class="built_in">QuickSort</span>(arr,begin,pos<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">QuickSort</span>(arr,pos<span class="number">+1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(a,<span class="number">0</span>,a.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>函数传参的时候是要传起始位置，而不是具体的a[0]。<br>时间复杂度O(nlogn)，空间复杂度O(logn) 二叉树递归所占用的栈内存<br>是<strong>不稳定</strong>的排序</p>
<p>快速排序的优化</p>
<ul>
<li>排的越来越有序的时候，找一个合适的地方调用插入排序，因为插入排序是效率最高的当趋于有序的时候</li>
<li>采用<strong>三数取中</strong>法，L，R，Mid（（l+r）&#x2F;），取这三个数值在中间的数作为基准数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[mid]) <span class="built_in">swap</span>(arr[l], arr[mid]);</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[r]) <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[r]) <span class="built_in">swap</span>(arr[mid], arr[r]);</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[mid]); <span class="comment">// 将中位数放到最左边</span></span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">medianOfThree</span>(arr, l, r);</span><br><span class="line">    <span class="comment">// 原先 Partition 的逻辑保持不变</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; val) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[l++] = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; val) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[r--] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = val;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后的算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INSERTION_SORT_THRESHOLD = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[mid]) <span class="built_in">swap</span>(arr[l], arr[mid]);</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[r]) <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[r]) <span class="built_in">swap</span>(arr[mid], arr[r]);</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[mid]); <span class="comment">// 中位数放到最左边</span></span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">medianOfThree</span>(arr, l, r);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; val) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[l++] = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; val) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[r--] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = val;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= l &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt;= INSERTION_SORT_THRESHOLD) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">Partition</span>(arr, begin, end);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, begin, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, pos + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HybridSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">InsertionSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含了三数取中 + 插入排序的优化。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414121639433.png"><br>归 ： 递归 要先递，才能归。<br>并 ： 合在一起<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414122146161.png"><br>递归到结束（<strong>每个子树都只有一个元素</strong>）后要进行合并，合并要开辟新的内存空间，直到所有的子树都能合并起来，要一直开辟内存，很耗内存。<br><strong>要递归的时候函数传参需要传起始位置和终止位置，就像快排那样传参</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector &lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[r-l<span class="number">+1</span>];  <span class="comment">//38 62 99     75 81   4-0+1=5</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = l;</span><br><span class="line">	<span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i]&lt;=arr[j])</span><br><span class="line">		&#123;</span><br><span class="line">			p[index++] = arr[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p[index++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">	&#123;</span><br><span class="line">		p[index++] = arr[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		p[index++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再把合并好的大段有序结果，拷贝回arr[r,l]区间内 </span></span><br><span class="line">	<span class="keyword">for</span> (i = l,j = <span class="number">0</span>;i &lt;=r;i++,j++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = p[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> []p;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin&gt;=end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//要先进行递，才能进行归</span></span><br><span class="line">	<span class="type">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr,begin,mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">	<span class="comment">//再归并，把两个小段有序的序列合并成大段</span></span><br><span class="line">	<span class="built_in">Merge</span>(arr,begin,mid,end); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个稳定的算法</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="二叉堆-大根堆-小根堆"><a href="#二叉堆-大根堆-小根堆" class="headerlink" title="二叉堆&amp;大根堆&amp;小根堆"></a>二叉堆&amp;大根堆&amp;小根堆</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414125441474.png"><br><strong>完全二叉树的最后一层叶子节点</strong>靠左排列，用数组存放的数在逻辑上可以被视为完全二叉树，2i+<br>1和2i+2<br>大根堆和小根堆只是基于二叉堆的基础规定了当前节点和两个孩子节点值的大小关系。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414125908109.png"></p>
<ul>
<li><p>叶子节点（树枝的末端，没有子节点）找到第一个非叶子节点：(末位元素下标-1)&#x2F;2</p>
</li>
<li><p>大根堆：arr[i] &gt; arr[i<em>2+1]&amp;&amp;arr[i] &gt; arr[i</em>2+2]</p>
</li>
<li><p>小根堆：arr[i] &lt; arr[i<em>2+1]&amp;&amp;arr[i] &lt; arr[i</em>2+2]<br>操作堆的时候像队列&#x2F;栈一样，只能操作堆顶元素</p>
</li>
<li><p>STL里的sort算法用的是什么排序？<br>快速排序 + 插入排序 （32的时候转为插入） + 堆排序（递归深度过深）</p>
</li>
<li><p>快速排序的时间复杂度不是稳定的nlogn，如何解决恶化问题<br>1.转插入排序 2.三数取中，选择合适的基准数</p>
</li>
<li><p>递归过深会引发什么问题？<br>函数开销变大，导致栈内存溢出，程序挂掉</p>
</li>
<li><p>怎么控制递归深度？如果达到递归深度了还没排完序怎么办？<br>转换成非递归的排序方式，如堆排序，好坏都是nlogn。</p>
</li>
</ul>
<h4 id="二叉堆代码"><a href="#二叉堆代码" class="headerlink" title="二叉堆代码"></a>二叉堆代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:<span class="comment">//using是定义类型别名，这里定义了一个Comp的比较大小函数 </span></span><br><span class="line">		<span class="keyword">using</span> Comp = function&lt;<span class="built_in">bool</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;; </span><br><span class="line">		<span class="built_in">PriorityQueue</span>(<span class="type">int</span> cap = <span class="number">20</span>,Comp comp = <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) <span class="comment">//默认大根堆 </span></span><br><span class="line">			:<span class="built_in">size_</span>(<span class="number">0</span>)</span><br><span class="line">			,<span class="built_in">cap_</span>(cap)</span><br><span class="line">			,<span class="built_in">comp_</span>(comp)</span><br><span class="line">			&#123;</span><br><span class="line">				que_ = <span class="keyword">new</span> <span class="type">int</span>[cap];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">PriorityQueue</span>(Comp comp) <span class="comment">//小根堆，通过传比较器对象实现 </span></span><br><span class="line">			:<span class="built_in">size_</span>(<span class="number">0</span>)</span><br><span class="line">			,<span class="built_in">cap_</span>(<span class="number">20</span>)</span><br><span class="line">			,<span class="built_in">comp_</span>(comp)</span><br><span class="line">			&#123;</span><br><span class="line">				que_ = <span class="keyword">new</span> <span class="type">int</span>[cap_];</span><br><span class="line">			&#125;</span><br><span class="line">		~<span class="built_in">PriorityQueue</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> []que_;</span><br><span class="line">			que_ = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//入堆</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (size_==cap_)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*cap_];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;cap_;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					p[i] = que_[i];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">delete</span> []que_;</span><br><span class="line">				que_ = p;</span><br><span class="line">				cap_ = <span class="number">2</span>*cap_;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (size_==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//只有一个元素不用上浮调整。 </span></span><br><span class="line">				que_[size_] = val; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//有多个元素，插入位于大小位置的下标 </span></span><br><span class="line">				<span class="built_in">ShiftUp</span>(size_,val);</span><br><span class="line">			&#125;</span><br><span class="line">			size_++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (size_ == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">&quot;The container is empty&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			size_--;</span><br><span class="line">			<span class="keyword">if</span> (size_ &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//删除堆顶元素，还有剩余的元素，进行下沉</span></span><br><span class="line">				<span class="built_in">ShiftDown</span>(<span class="number">0</span>,que_[size_]); </span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_==<span class="number">0</span>;&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> que_[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> size_;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (i &gt; <span class="number">0</span>) <span class="comment">//最多计算到根节点 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> father = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">comp_</span>(val,que_[father]))</span><br><span class="line">				&#123;</span><br><span class="line">					que_[i] = que_[father];</span><br><span class="line">					i = father;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			que_[i] = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (i&lt;size_/<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> child = <span class="number">2</span>*i <span class="number">+1</span>;</span><br><span class="line">				<span class="keyword">if</span> (child + <span class="number">1</span> &lt;size_&amp;&amp;<span class="built_in">comp_</span>(que_[child<span class="number">+1</span>],que_[child]))</span><br><span class="line">				&#123;</span><br><span class="line">					child = child + <span class="number">1</span>; <span class="comment">//如果右孩子的值大于左孩子，child记录右孩子的下标</span></span><br><span class="line">					 </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">comp_</span>(que_[child],val))</span><br><span class="line">				&#123;</span><br><span class="line">					que_[i] = que_[child];</span><br><span class="line">					i = child;</span><br><span class="line">				 &#125;</span><br><span class="line">				 <span class="keyword">else</span></span><br><span class="line">				 &#123;</span><br><span class="line">				 	<span class="keyword">break</span>; <span class="comment">//已经满足了堆的性质，提前出 </span></span><br><span class="line">				 &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			que_[i] = val;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> *que_; <span class="comment">//指向动态扩容的数组 </span></span><br><span class="line">		<span class="type">int</span> size_; <span class="comment">//元素个数</span></span><br><span class="line">		<span class="type">int</span> cap_; <span class="comment">//数组的总空间大小</span></span><br><span class="line">		Comp comp_; <span class="comment">//比较器对象 </span></span><br><span class="line">		</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//PriorityQueue que; //第一个构造函数 </span></span><br><span class="line">	<span class="function">PriorityQueue <span class="title">que</span><span class="params">([](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&lt;b;&#125;)</span></span>;<span class="comment">//第二个构造函数 </span></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		que.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;que.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>快速的查询时要第一时间想到哈希表。</p>
<ul>
<li>有序的关联容器：set\map （红黑树实现，O(logn)）</li>
<li>无序的关联容器：unordered_set\unordered_map （哈希表O(1)）</li>
</ul>
<h3 id="通过哈希函数（除留余数法实现）"><a href="#通过哈希函数（除留余数法实现）" class="headerlink" title="通过哈希函数（除留余数法实现）"></a>通过哈希函数（除留余数法实现）</h3><ul>
<li>如何解决哈希冲突？<br>1.线性探测法 2.链地址法<br>3.设置哈希表的长度为素数，可以尽可能的减少哈希冲突</li>
<li><pre><code>如果你长度为8，有很多能mod8的数都会被存到同一个位置；如果是素数，则会减少一些。
</code></pre>
</li>
</ul>
<p>4.设置哈希表装载因子（已用个数&#x2F;容量）</p>
<ul>
<li>一般是0.75，超过了0.75后就要将哈希表<strong>扩容</strong>，扩容会从素数表里面找下一个质数作为新的容量，原来哈希表中的元素需要在新的哈希表中<strong>重新哈希</strong></li>
</ul>
<p>查找<br>未发生哈希冲突 O(1) 比如18%7 &#x3D; 4，去看arr[4]有无18；如果发生了哈希冲突，就要往后去遍历，O(n)可能是线性探测.<br>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">	STATE_UNUSE, </span><br><span class="line">	STATE_DELETE, <span class="comment">//在哈希表中，我们删除元素不用置成0，而是设置状态 </span></span><br><span class="line">	STATE_USING,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要用vector，vector会自动扩容，我们自己用指针来 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bucket</span>&#123;</span><br><span class="line">	<span class="built_in">Bucket</span>(<span class="type">int</span> key = <span class="number">0</span>,State state = STATE_UNUSE)</span><br><span class="line">		:<span class="built_in">key_</span> (key),<span class="built_in">state_</span>(state)&#123;&#125;</span><br><span class="line">	<span class="type">int</span> key_; <span class="comment">//存储的数据 </span></span><br><span class="line">	State state_; <span class="comment">//桶的当前状态 </span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个类，先去处理成员变量 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">HashTable</span>(<span class="type">int</span> size = primes_[<span class="number">0</span>],<span class="type">double</span> LoadFactor = <span class="number">0.75</span>)</span><br><span class="line">			:<span class="built_in">useBucketNum_</span>(<span class="number">0</span>)</span><br><span class="line">			,<span class="built_in">loadFactor_</span>(LoadFactor)</span><br><span class="line">			,<span class="built_in">primeIdx_</span>(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把用户传入的size调整到最近的比较大的素数上（因为用户可能传入非素数）	</span></span><br><span class="line">			<span class="keyword">if</span> (size != primes_[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (;primeIdx_&lt;PRIME_SIZE;primeIdx_++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (primes_[primeIdx_]&gt;size)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (primeIdx_ == PRIME_SIZE)</span><br><span class="line">					&#123;</span><br><span class="line">						primeIdx_--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tableSize_ = primes_[primeIdx_];</span><br><span class="line">			table_ = <span class="keyword">new</span> Bucket[tableSize_];</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">HashTable</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> []table_;</span><br><span class="line">			table_ = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">double</span> factor = useBucketNum_*<span class="number">1.0</span> / tableSize_;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;factor:&quot;</span>&lt;&lt;factor&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">if</span> (factor &gt; loadFactor_)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">expand</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="type">int</span> idx = key % tableSize_;</span><br><span class="line">		<span class="type">int</span> i = idx;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (table_[i].state_!=STATE_USING)</span><br><span class="line">			&#123;</span><br><span class="line">				table_[i].state_ = STATE_USING;</span><br><span class="line">				table_[i].key_ = key;</span><br><span class="line">				useBucketNum_++;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i = (i + <span class="number">1</span>)%tableSize_;</span><br><span class="line">		&#125;<span class="keyword">while</span> (i!=idx);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			if (table_[idx].state_!= STATE_USING)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				table_[idx].state_ = STATE_USING;</span></span><br><span class="line"><span class="comment">				table_[idx].key_ = key;</span></span><br><span class="line"><span class="comment">				return true;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			//如果第一个位置是被using的，那就从idx往下找，让数组成环 </span></span><br><span class="line"><span class="comment">			for (int i = (idx+1)%tableSize_;i!=idx;i=(i+1)%tableSize_)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				if (table_[i].state_!=STATE_USING)</span></span><br><span class="line"><span class="comment">				&#123;</span></span><br><span class="line"><span class="comment">						</span></span><br><span class="line"><span class="comment">				&#125; 		</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">			<span class="comment">//代码重复冗余，用dowhile优化，因为一开始就要做一次判断 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> idx = key % tableSize_;</span><br><span class="line">			<span class="type">int</span> i = idx;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (table_[i].state_==STATE_USING&amp;&amp;table_[i].key_==key)</span><br><span class="line">				&#123;</span><br><span class="line">					table_[i].state_ = STATE_DELETE;</span><br><span class="line">					useBucketNum_--;</span><br><span class="line">				&#125;</span><br><span class="line">				i = (i<span class="number">+1</span>)%tableSize_;</span><br><span class="line">			&#125;<span class="keyword">while</span> (table_[i].state_!=STATE_UNUSE&amp;&amp;i !=idx ); <span class="comment">//遇到了unuse说明发生冲突后也没往后插了 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> idx = key % tableSize_;</span><br><span class="line">			<span class="type">int</span> i = idx;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (table_[i].state_==STATE_USING&amp;&amp;table_[i].key_==key)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i = (i<span class="number">+1</span>)%tableSize_;</span><br><span class="line">			&#125;<span class="keyword">while</span> (table_[i].state_!=STATE_UNUSE &amp;&amp; i != idx); <span class="comment">//遇到了unuse说明发生冲突后也没往后插了 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			++primeIdx_;</span><br><span class="line">			<span class="keyword">if</span> (primeIdx_ == PRIME_SIZE)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">&quot;HashTable is large enought and it can&#x27;t be expanded&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Bucket *newTable = <span class="keyword">new</span> Bucket[primes_[primeIdx_]];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;tableSize_;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (table_[i].state_==STATE_USING) <span class="comment">//旧表中有效的数据重新哈希 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> idx = table_[i].key_ % primes_[primeIdx_];</span><br><span class="line">					<span class="type">int</span> k = idx;</span><br><span class="line">					<span class="keyword">do</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (newTable[k].state_!=STATE_USING)</span><br><span class="line">						&#123;</span><br><span class="line">							newTable[k].state_ = STATE_USING;</span><br><span class="line">							newTable[k].key_ = table_[i].key_;</span><br><span class="line">							<span class="keyword">break</span>; </span><br><span class="line">						&#125;</span><br><span class="line">						k = (k<span class="number">+1</span>) % primes_[primeIdx_];</span><br><span class="line">					&#125; <span class="keyword">while</span>(k!=idx);</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> []table_;</span><br><span class="line">			table_ = newTable;</span><br><span class="line">			tableSize_ = primes_[primeIdx_];</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Bucket *table_; <span class="comment">//指向动态开辟的哈希表</span></span><br><span class="line">		<span class="type">int</span> tableSize_; <span class="comment">//哈希表的长度</span></span><br><span class="line">		<span class="type">int</span> useBucketNum_; <span class="comment">//已经使用的桶的数量</span></span><br><span class="line">		<span class="type">double</span> loadFactor_; <span class="comment">//装载因子</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PRIME_SIZE = <span class="number">10</span>;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> primes_[PRIME_SIZE];<span class="comment">//素数表</span></span><br><span class="line">		<span class="type">int</span> primeIdx_; <span class="comment">//当前素数的下标  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> HashTable::primes_[PRIME_SIZE] = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">97</span>,<span class="number">251</span>,<span class="number">443</span>,<span class="number">911</span>,<span class="number">1471</span>,<span class="number">42773</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HashTable htable;</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">21</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;htable.<span class="built_in">find</span>(<span class="number">14</span>)&lt;&lt;endl;</span><br><span class="line">	htable.<span class="built_in">erase</span>(<span class="number">14</span>);</span><br><span class="line">	cout&lt;&lt;htable.<span class="built_in">find</span>(<span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h3><h4 id="查重"><a href="#查重" class="headerlink" title="查重"></a>查重</h4><p>查重或者统计重复的次数，查询的<strong>效率高</strong>但是<strong>占用内存空间较大</strong>。<br>找<strong>第一个重复出现的数字</strong><br>用unordered_set来查，先遍历数组，然后用find函数去查询是否哈希表里是否存在有这个数（find返回的是迭代器的值，如果没找到就返回哈希表的末尾）如果没有就会insert，有的话就会输出。切记，在map和set这里尽量都用auto，不要用下标访问。<br><strong>找第一个和找所有的其实就是加不加break</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unordered_set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> val : a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = s.<span class="built_in">find</span>(val);</span><br><span class="line">		<span class="keyword">if</span> (it!=s.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;*it;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> s.<span class="built_in">insert</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找所有重复出现的元素以及重复的次数，用unordered_map，没找到，就把这个数字插入（用emplace方法），找到了，迭代器的second++（值++）；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p : a)</span><br><span class="line">	&#123;</span><br><span class="line">		m[p]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> q : m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (q.second&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;q.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.second&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h4><p>top K问题：大小根堆来过滤，大根堆过滤前top k小的数据；小根堆过滤前top k大的数据<br>用<strong>大根堆</strong>来找前k个最小的元素；用<strong>小根堆</strong>来找前k个最大的元素。<br>64 45 52 80 66 68 0 2 18 75<br>这十个先把前三个数组成一个大根堆，然后到第四个80，80比堆顶元素64大，说明一定比这个堆里的所有元素都大，所以往下继续找，一直到0，0比堆顶元素小，我们就调整，依次这样。<br>最后复杂度为logk * O(n)但是logk是常数级，所以最终我们以O(n)复杂度的找到topK元素。</p>
<p>快排分割法。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BST树（Binary-Search-Tree-二叉搜索树）"><a href="#BST树（Binary-Search-Tree-二叉搜索树）" class="headerlink" title="BST树（Binary Search Tree 二叉搜索树）"></a>BST树（Binary Search Tree 二叉搜索树）</h3><ul>
<li>对于二叉树上的每一个节点：<strong>左孩子的值&lt;父节点的值&lt;右孩子的值</strong></li>
<li>每一层的节点最多的个数2^(L-1)，第三层就是4个，第四层就是8个；</li>
<li>所有节点的个数N与层数的关系：等比数列求和 &#x3D; 2^L-1 &#x3D; N，2^L &#x3D; N+1，两边取对数L &#x3D; log2N</li>
</ul>
<h4 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h4><ul>
<li>1.没有孩子的节点 父节点地址域为nullptr</li>
<li>2.有一个孩子 孩子写入父节点地址域</li>
<li>3.删除的节点有两个孩子 ：找待删除	节点的<strong>前驱节点或后继节点</strong>，用前驱&#x2F;后继将要删除的节点值覆盖掉，然后直接删除前驱&#x2F;后继就可以了。<br>前驱：左子树里最大的 后继：右子树里最小的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250418100102229.png"></li>
</ul>
<h3 id="二叉树的递归操作"><a href="#二叉树的递归操作" class="headerlink" title="二叉树的递归操作"></a>二叉树的递归操作</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250418111746902.png"><br>左右根</p>
<h4 id="基于后序遍历，使用递归操作来判断树的层数"><a href="#基于后序遍历，使用递归操作来判断树的层数" class="headerlink" title="基于后序遍历，使用递归操作来判断树的层数"></a>基于后序遍历，使用递归操作来判断树的层数</h4><p>int GetL(Node *node)<br>{<br>	if (node!&#x3D;nullptr)<br>	{<br>		PostOrder(node-&gt;left);<br>		PostOrder(node-&gt;right);<br>		return left &gt; right ? left + 1: right + 1;<br>	}<br>}</p>
<h4 id="基于后序遍历递归操作求层数，可以用来求节点的个数"><a href="#基于后序遍历递归操作求层数，可以用来求节点的个数" class="headerlink" title="基于后序遍历递归操作求层数，可以用来求节点的个数"></a>基于后序遍历递归操作求层数，可以用来求节点的个数</h4><p>int num(Node *node)<br>{<br>	if (node &#x3D;&#x3D; nullptr) return 0;<br>	int left &#x3D; num(node-&gt;left);<br>	int right &#x3D; num(node-&gt;right);<br>	return left + right +1;	<br>}</p>
<h2 id="五大算法"><a href="#五大算法" class="headerlink" title="五大算法"></a>五大算法</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>算法思想：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度搜索解空<br>间树。当搜索到某一节点时，要先判断该节点是否包含问题的解，如果包含就从该节点出发继续深度搜<br>索下去，否则逐层向上回溯。一般在搜索的过程中都会添加相应的剪枝函数，避免无效解的搜索，提高<br>算法效率。<br>解空间：解空间就是所有解的可能取值构成的空间，一个解往往包含了得到这个解的每一步，往往就是<br>对应解空间树中一条从根节点到叶子节点的路径。子集树和排列树都是一种解空间，它们不是真实存在<br>的数据结构，也就是说并不是真的有这样一颗树，只是抽象出的解空间树。<br>其实很像二叉树的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">func</span>(arr, i + <span class="number">1</span>, length);</span><br><span class="line">		<span class="built_in">func</span>(arr, i + <span class="number">1</span>, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">func</span>(arr, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子集树，其实就是递归选路径，需要一个辅助数组子集树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i,<span class="type">int</span> length, <span class="type">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x[j]==<span class="number">1</span>) cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*x[i] = 1; //选这条路</span></span><br><span class="line"><span class="comment">		func(arr, i + 1, length,x);</span></span><br><span class="line"><span class="comment">		x[i] = 0; //不选这条路</span></span><br><span class="line"><span class="comment">		func(arr, i + 1, length,x);*/</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">		&#123;</span><br><span class="line">			x[i] = k;</span><br><span class="line">			<span class="built_in">func</span>(arr,i<span class="number">+1</span>,length,x);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h2><p>有三个主要部分：<strong>虚拟化（virtualization）</strong>、<strong>并发（concurrency）</strong>、<strong>持久性（persistence）</strong></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一、（共10分）操作系统的设计目标有哪些？</p>
<ul>
<li>抽象性：对硬件资源进行抽象，提供统一接口，简化程序开发；</li>
<li>并发性：支持多个程序同时运行，提高系统吞吐；</li>
<li>虚拟化：如虚拟内存、虚拟 CPU，使用户感觉拥有独占资源；</li>
<li>资源管理与调度：高效分配 CPU、内存、磁盘等资源，提升资源利用率；</li>
<li>安全与保护：防止程序互相干扰，保护用户数据；</li>
<li>用户友好性：提供简洁易用的接口和良好的使用体验。</li>
</ul>
<p>六、（ 共 10 分）UNIX 系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：<br>fork()和 exec()，解释说明 fork()和 exec()的作用（5 分），以 UNIX 的 Shell 为例说明为什么设<br>计这两个系统调用（5分）。 </p>
<ul>
<li>fork()创建一个和父进程几乎相同的子进程，除了PID等一些信息不同其它完全一样。</li>
<li>exec()用新的程序替换掉当前程序执行的内容，不改变其PID等信息。<br>UNIX SHELL启动一个新程序的时候，先通过fork()创建一个子进程，再通过exec()加载并执行用户命令，这样父进程（shell）仍能工作，分离设计提供灵活性。</li>
</ul>
<p>七、操作系统虚拟化CPU的机制是受限直接执行，为了实现这个机制，例举的硬件提供了哪些支持？简要说明操作系统如何利用硬件来实现LDE。<br>硬件</p>
<ul>
<li>模式划分：被划分为用户态和内核态</li>
<li>中断机制：支持外设中断和系统调用陷入内核态。</li>
<li>定时器中断：防止单一进程长时间占用CPU资源，实现抢占功能。</li>
<li>内存保护机制：通过页表和地址空间隔离来保护内核</li>
<li>指令限制：一些特权指令如（I&#x2F;O）只能被内核态执行。</li>
</ul>
<p>操作系统可以将进程调度执行化为内核态以及用户态，用户态不能执行一些特权指令比如I&#x2F;O，必须通过陷阱表的陷阱指令陷入内核态，并提供了从陷入返回指令回到用户态。操作系统还提供了中断机制，防止单一进程过度占用资源，而导致其他进程出现饥饿。结合内存保护，防止非法访问内核或其他进程内存区域，从而实现虚拟化CPU且保证系统安全和稳定。还有上下文切换，通过寄存器保存当前进程的值，然后读取另一个进程的寄存器所存储的值进行运行。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250419221319250.png"><br>1.三态：运行、就绪、阻塞<br>2.错误，进程在一个时刻只能处于一种状态。<br>3.错误，单核情况下，操作系统和进程需要通过时间片轮转轮流使用CPU，不会同时运行，操作系统也是一个程序。</p>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>正在运行的程序会做一件非常简单的事情：从内存中读取指令，解码，并执行它，然后接着执行下一条指令。<br>总结为Fetch 、 Decode 、 Execute</p>
<p><strong>操作系统</strong>可以让程序<strong>共享内存</strong>、<strong>与设备交互</strong>、<strong>运行的更容易</strong>，操作系统确保系统既易于使用、又正确高效运行。为了做到这一点，采用了<strong>虚拟化</strong>的技术，在一些硬件的帮助下，操作系统负责提供虚拟化，使得<strong>单个（或一小部分）CPU可以看似认为有无限数量的CPU</strong>，从而可以同时运行多个程序，但问题就是在<strong>调度</strong>，在特定时间运行，该运行哪个？所以操作系统也承担了**资源管理器（resource manager）**的角色。</p>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><ul>
<li><p>虚拟内存，每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，打游戏的时候每个角色都有一个背包，背包的0号格子可能装有不同的东西，但并没有冲突，操作系统把编号0分到了不同的内存地址上。<br>每个程序都有自己的“背包”（内存空间），从地址 0 开始。但实际的物理内存只有一块<br>程序 A 的地址 0x1000 → 实际是 物理地址 0xA000<br>程序 B 的地址 0x1000 → 实际是 物理地址 0xC000<br>这就是虚拟内存：给程序看的假地址，每个程序都以为自己独占整片内存，其实操作系统做了“背后映射”。</p>
</li>
<li><p>操作系统通过<strong>时间片轮转（time-sharing）<strong>技术虚拟化 CPU，将 CPU 时间划分成小片段，每次只分配给一个进程运行一个时间片，然后切换到其他进程，从而营造出“多个进程同时运行”的假象。这种时分复用机制使得单核 CPU 也能实现多任务并发。其代价是</strong>频繁的上下文切换带来一定的性能开销</strong>。</p>
</li>
<li><p>进程三态：运行、阻塞、就绪</p>
</li>
<li><p>fork()系统调用的返回值：<strong>父进程获得子进程的PID，子进程的返回值是0</strong></p>
</li>
</ul>
<h3 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h3><p>有两种模式：用户模式和内核模式，用户模式下功能受限，如I&#x2F;O请求无法发送，但可以通过<strong>特殊的陷阱（trap）指令</strong>从用户模式进入内核模式，进入内核后系统就可以执行任何需要的特权操作，执行完成后，操作系统调用一个特殊的从陷阱返回(return-from-trap)指令回到用户模式。</p>
<h3 id="多级反馈队列MLFQ"><a href="#多级反馈队列MLFQ" class="headerlink" title="多级反馈队列MLFQ"></a>多级反馈队列MLFQ</h3><p>五条规则</p>
<ul>
<li>任务A的优先级高于任务B，先执行任务A，再执行任务B（保证高优先级任务的响应速度，提高系统的实时性。）</li>
<li>任务A的优先级等于任务B，以轮询的方式执行任务A、B（在同等级中实现公平性，防止个别任务长期占用CPU。）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420102050486.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420102132273.png" alt="Round-Robin"></li>
<li>新任务进入队列，放在最高优先级的队列执行（提高新任务启动速度，增强系统交互性。）</li>
<li>一旦工作用完了其在某一层中的时间配额，无论中间主动放弃了多少次CPU，就降低其优先级。（避免任务通过频繁放弃CPU来“欺骗”调度器长期占用高优先级。）</li>
<li>经过一段时间S后，就将所有任务重新加入到最高优先级（避免低优先级任务长时间得不到执行，防止饥饿现象。）</li>
</ul>
<h3 id="调度-比例份额"><a href="#调度-比例份额" class="headerlink" title="调度-比例份额"></a>调度-比例份额</h3><p>彩票数(ticket)代表了进程(或用户或其他)占有某个资源的份额，一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。拥有的彩票数越多，那被调度的概率也就越大。<br>三大特性：</p>
<ul>
<li>彩票货币</li>
<li>彩票转让：一个进程临时将自己的彩票转移给另一个进程</li>
<li>彩票通胀：一个进程的彩票数可以临时提升或降低告诉操作系统我需要CPU。</li>
</ul>
<p>步长调度：其实就是时间片轮转，执行完当前的步长然后去看看队列中现在谁的总步长最短，就去执行它，如果所有人的步长都相同了，那就随机抽一个去执行。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>如何将内存中的逻辑地址转换为物理地址？</p>
<ol>
<li>绝对装入</li>
<li>静态重定位</li>
<li>动态重定位</li>
</ol>
<ul>
<li>基址寄存器 + 逻辑地址 &#x3D; 真实地址 （基址寻址） 采用动态重定位时<strong>允许程序在内存中发生移动</strong></li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>单片机没有OS，每一次运行都需要重新烧录，<strong>单片机的CPU直接操作内存的物理地址。<strong>在单片机的情况下不可能同时运行两个程序，因为内存地址会被覆盖。<br>操作系统通过</strong>虚拟内存</strong>来解决这个问题。<br>操作系统通过为每一个进程分配一套独立的<strong>虚拟地址</strong>，进程在自己的虚拟地址里进行操作，最后OS通过映射关系映射到不同的物理地址上。进程持有的<strong>虚拟地址</strong>会通过CPU芯片上的MMU（Memory Management Unit）来转换成<strong>物理地址。</strong></p>
<blockquote>
<p>操作系统是如何管理虚拟内存和物理内存之间的关系？<br>主要有两种，<code>内存分段</code>和<code>内存分页</code>。</p>
</blockquote>
<h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>程序是由若干个逻辑分段组成的，如可用代码分段，数据分段，栈段，堆段组成，不同的段有不同的属性。<br>分段机制下的虚拟地址由两部分组成：<code>段选择子和段内偏移量</code></p>
<ul>
<li>段选择子：保存在段寄存器内，最重要的是段号，用作段的索引，段表里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>段内偏移量：应位于<strong>0和段界限之间</strong>，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602121417844.png"></li>
</ul>
<h4 id="分段产生的两个问题：内存碎片和内存交换效率低"><a href="#分段产生的两个问题：内存碎片和内存交换效率低" class="headerlink" title="分段产生的两个问题：内存碎片和内存交换效率低"></a>分段产生的两个问题：<strong>内存碎片</strong>和<strong>内存交换效率低</strong></h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602121756991.png"></p>
<ul>
<li>游戏512MB</li>
<li>浏览器128MB</li>
<li>音乐256MB<br>如果浏览器被关闭了，新的200MB的程序也无法写入，出现了<strong>内存外部碎片</strong>的问题。此时可以通过<strong>内存交换</strong>来解决：</li>
<li>可以把音乐程序占用的那256MB内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的512MB内存后面。这样就能空缺出连续的256MB空间，于是新的200MB程序就可以装载进来。<blockquote>
<p>分段为什么导致内存交换效率低？</p>
</blockquote>
</li>
<li>对于多进程系统，外部碎片的产生很常见，就不得不使用Swap内存区域，但是硬盘上的访问速度远比内存低，每一次交换都需要把一大段连续内存数据写到硬盘上。</li>
</ul>
<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>为了解决内存分段的交换效率低以及内存碎片问题，提出了内存分页。</p>
<ul>
<li>将内存空间分为一个个<strong>大小相等</strong>的分区，每个分区就是一个<strong>页框&#x3D;&#x3D;页帧&#x3D;&#x3D;物理块&#x3D;&#x3D;物理页面</strong></li>
<li>将<code>进程的逻辑地址空间</code>也分成与<strong>页框大小相等</strong>的一个个部分，每个部分称为一个<code>页</code>或<code>页面</code><br>进程的页面和内存的页框是一一对应的，大小相等。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602134849717.png"><br>每个进程都有一张页表，一个进程对应着一张页表，每个页表项由<code>页号</code>和<code>块号</code>组成，页表记录进程页面和实际存放的内存块之间的映射关系<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602140351399.png"><br>前12位就代表在几号页，后20位就是页内偏移量</li>
</ul>
<h2 id="期末复习（以题目为导向）"><a href="#期末复习（以题目为导向）" class="headerlink" title="期末复习（以题目为导向）"></a>期末复习（以题目为导向）</h2><p>一、 （20分，前3小题每题4分，第4小题8分） </p>
<ol>
<li>多核处理器调度采用单队列调度和多队列调度，分别存在什么样的问题，如何处理？ <ul>
<li>单队列调度：易于实现，负载均衡好，但线程频繁迁移会<strong>导致缓存未命中率提高</strong>，对策，采用<strong>核亲和性（CPU affinity）减少迁移</strong></li>
<li>多队列调度：缓存利用率高，<strong>但容易负载不均</strong>；对策，引入迁移实现动态负载均衡，让无任务的CPU上有任务。<strong>工作窃取（work stealing）</strong>：工作量较少的队列偷偷看其他队列是否比自己工作多，如果其他队列的工作比自己更满，就从他们那里窃取一些工作过来。</li>
</ul>
</li>
<li>简要分析虚拟内存系统的三个主要目标。  <ol>
<li>扩展内存容量：</li>
<li>内存保护：</li>
<li>内存共享 ：</li>
</ol>
</li>
<li>什么是死锁？死锁产生需要哪四个必要条件？</li>
</ol>
<ul>
<li>死锁：多线程争夺共享资源，相互等待，然后永久阻塞。<ol>
<li>互斥：资源一次只能被一个资源占有</li>
<li>占有并等待：已占有资源的进程可以申请新资源</li>
<li>不可抢占：资源不能被强制回收</li>
<li>循环等待：形成资源等待的闭环</li>
</ol>
</li>
</ul>
<p>为什么不能只靠offset或pfn？</p>
<ul>
<li>没有VPN，就不知道在哪一页；</li>
<li>没有PFN，就不知道在哪一个内存块；</li>
<li>没有OFFSET，就不知道在内存块的哪一个地方。</li>
<li>OFFSET，就是页的大小，如在32位的地址空间里一页是4KB，那offset就是pow(2,12);剩下的20位就是VPN，低位掩码<br>二、假设虚拟地址有32位，页大小为4KB，回答下列问题：</li>
</ul>
<ol>
<li>算法中第1行VPN_MASK、SHIFT的值分别是多少？VPN的取值范围是多少？第 5 行的OFFSET_MASK的值是多少？</li>
</ol>
<ul>
<li>VPN_MASK和OFFSET_MASK是掩码，用于提取VPN以及OFFSET的，32位是由20位的VPN + 12位的偏移量构成的，所以VPN_MASK前20位全1，后12位全0；OFFSET_MASK前20位为0，后12位为1。 <code>SHIFT</code> 是指页内偏移位数，即页大小的对数，用来做地址右移或左移运算。VPN的取值范围是0 - pow(2,20)-1；</li>
</ul>
<ol start="2">
<li>从算法中，你知道TLB、页表中分别包含哪些内容吗？</li>
</ol>
<ul>
<li>TLB中有VPN（页号），PFN（页帧号），<strong>ProtectBits（访问权限，比如读&#x2F;写&#x2F;执行）</strong>，<strong>Valid 位（有时也在）</strong>；页表中含PFN，ProtectBits，valid位，访问位，修改位；</li>
</ul>
<ol start="3">
<li>据你所知，软件（操作系统）管理的TLB控制流算法与上述算法有什么区别？</li>
</ol>
<ul>
<li>**硬件管理（如题中）：**TLB 查找、缺页中断、页表查找都由硬件完成，操作系统只负责处理例外情况（如页不存在）。</li>
<li>**软件管理（如 SPARC 架构）：**TLB 缺失时硬件产生异常，由操作系统查页表并手动更新TLB，增加灵活性，但效率较低。</li>
</ul>
<ol start="4">
<li>MIPS R4000 支持32位地址空间，用户地址只占地址空间的一半，可以支持最多64GB物理内存，页大小为4KB，那么其VPN、PFN分别是多少位？</li>
</ol>
<ul>
<li>32位是4GB，但题目提到了<strong>用户地址只占地址空间的一半</strong>，所以用户空间有pow(2,31)，用地址空间大小&#x2F;页大小 &#x3D; VPN，31-12 &#x3D; 19；64GB是pow(2,36)，VPN &#x3D; pow(2,36) &#x2F; pow(2,12) &#x3D; pow(2,24);PFN就是24位</li>
<li>所以VPN是19位，PFN是24位。</li>
</ul>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250608101803131.jpg"></p>
<p>六、（15分）对于如图所示的1个简单文件系统结构，包括一个 inode 位图（inode bitmap，<br>只有 8 位，每个 inode 一个），一个数据块位图（data bitmap，也是 8 位，每个数据块<br>一个），inode（总共 8 个，编号为 0 到 7，分布在 4 个块上），以及数据块（总共 8 个，<br>编号为 0～7），数据块为4KB大小，试回答如下问题： </p>
<ol>
<li>该系统最大支持多少个文件，为什么？</li>
</ol>
<ul>
<li><strong>一个文件对应一个inode</strong>，inode bitmap有8位 -&gt; 最多支持8个inode -&gt;<strong>最多支持八个文件</strong>。<br>（2）如果inode中支持一级间接指针，该系统中单文件最大可存储多大的内容？（提示：需分情况讨论） </li>
<li></li>
</ul>
<p>（3）假设要打开图中的灰色inode（第2个）所指示的文件并顺序读取所有数据，请按时间顺序列出对文件系统数据结构的所有操作。（假设在OS中该文件的inode号已知，Da数据块是文件的第1块，Db为第2块）<br>七、文件系统访问（15分）<br>（1）简要说明文件系统中inode的用途；inode一般包含哪些信息，试列举至少五个进行说明；</p>
<ul>
<li>有inodoe编号，文件的创建时间，文件的修改时间，文件访问权限，文件的大小，文件的数据块指针（用来指向数据存放的地方）<br>（2）假设要读取&#x2F;foo&#x2F;bar路径下的bar文件，首先通过open(“&#x2F;foo&#x2F;bar”,O_RDONLY)打开文件，随后再使用read操作读取文件内容；请问：执行open和read操作时，进程与文件系统之间有哪些数据交互？可以使用表格或文字形式进行描述。</li>
<li>open：系统解析路径 <code>/foo/bar</code> ，通过<strong>目录项</strong>查找<code>bar</code>的inode，加载其元数据，建立文件描述符</li>
<li>read：系统根据fd找到file结构，<strong>定位inode</strong>，通过页缓存或磁盘读取<strong>数据块</strong>，将数据拷贝到用户空间中。</li>
</ul>
<p>八、简述I&#x2F;O设备标准协议的执行步骤，请分析其利弊并简要给出解决方案。（8分）</p>
<ol>
<li><p>设备准备数据</p>
</li>
<li><p>设备向CPU发送<strong>中断信号</strong></p>
</li>
<li><p>CPU保存上下文，进入中断处理程序</p>
</li>
<li><p>驱动程序读取设备状态与数据</p>
</li>
<li><p>数据转入缓存区或用户空间</p>
</li>
<li><p>CPU恢复上下文，继续原程序。</p>
</li>
<li><p>彩票调度和步长调度采用随机思想有其优势，但没有广泛使用，分析其原因。</p>
</li>
</ol>
<ul>
<li>一个原因是这两种方式都不能很好的适应I&#x2F;O，另一个原因是票数分配问题并没有具体的解决方式，不知道一个进程应该有多少彩票数。</li>
</ul>
<ol start="2">
<li>虚拟内存的三个目标？</li>
</ol>
<ul>
<li>透明（transparency）：操作系统实现虚拟内存的方式，应该让运行的程序看不见。</li>
<li>效率 ：操作系统应该追求虚拟化尽可能高效(efficient)，包括时间上(即不会使程序运行得更慢)和空间上</li>
<li>保护：操作系统应确保进程受到保护，不会受其他进程影响，操作系统本身也不会受进程影响。</li>
</ul>
<ol start="3">
<li>什么是文件系统的崩溃一致性问题？</li>
</ol>
<ul>
<li>当你想持久化数据的时候，突然被拔电了，数据没有成功写入。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>cpp基础核心内容</title>
    <url>/2025/04/20/cpp%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="三块核心内容"><a href="#三块核心内容" class="headerlink" title="三块核心内容"></a>三块核心内容</h2><h3 id="进程虚拟地址空间区域划分"><a href="#进程虚拟地址空间区域划分" class="headerlink" title="进程虚拟地址空间区域划分"></a>进程虚拟地址空间区域划分</h3><p>有四区</p>
<ol>
<li>代码区(.text) 存放程序的机器指令，通常是<strong>只读的</strong></li>
<li>数据段(.data) 存放<strong>已初始化的全局变量和静态变量</strong></li>
<li>BSS段 存放<strong>未初始化</strong>的<strong>全局变量和静态变量</strong>，操作系统在运行前会帮助自动初始化为0</li>
<li>堆栈区(Heap and Stack) <ul>
<li>堆区：程序运行时动态分配的内存(new 和 malloc)，由程序员管理</li>
<li>栈区：函数调用时使用的内存，存放局部变量和返回地址，由系统自动分配和释放<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420233311321.png"></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>；</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三条是其实是汇编的mov指令，存放在.text区，而main函数调用的时候会在栈开辟空间。</p>
<h3 id="函数调用堆栈详细过程"><a href="#函数调用堆栈详细过程" class="headerlink" title="函数调用堆栈详细过程"></a>函数调用堆栈详细过程</h3><h3 id="程序编译链接原理"><a href="#程序编译链接原理" class="headerlink" title="程序编译链接原理"></a>程序编译链接原理</h3><p>预处理-编译-汇编-链接</p>
<ol>
<li>预处理 处理#include 之类的，除了#pragma lib和#pragma link，这两个是在链接时处理。</li>
<li>编译 gcc &#x2F; g++（gcc用来编译c语言，g++用来编译c++，其实就是dev中的F9，只不过现在换成命令行形式）  在<strong>编译的过程中符号不分配虚拟地址</strong>，在链接分配。</li>
<li>汇编 <strong>符号表的生成</strong>，生成.o文件。.o文件为目标文件（Object File），目标文件是一个二进制文件，文件的格式是ELF(executable and linkable file)</li>
<li>链接 将各个段合并（比如main.o和sum.o）生成可执行文件，Linux下是.out&#x2F;Windows下是.exe<ul>
<li>步骤一：所有的.o文件段合并，符号表合并后，进行<strong>符号解析</strong>（要找到所有符号表引用的定义）。</li>
<li>步骤二：符号的重定向（让<em>UND</em>找到初始定义的位置）<strong>这是链接的核心</strong>，符号解析成功后，给所有的符号分配虚拟地址！</li>
</ul>
</li>
</ol>
<p>g++&#x2F;gcc语法</p>
<ul>
<li>gcc -c &#x2F; g++ -c  是编译 compile<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421103629431.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421103540512.png"><br>使用objdump -t查看<strong>符号表</strong>（t - table）<br>使用cat查看文件内容</li>
<li>在main.cpp中，我们看的定义gdata是一个外部引用的变量，sum是声明，看main.o的符号表，他们并不是没有符号，符号是<em>UND</em>(undefined)，这个意思是：<strong>我现在在当前代码上用到他们了，但是我却不知道他们是怎么定义的</strong>，UND是对于<strong>符号的引用</strong>，有确定数据段的是<strong>符号的定义</strong>需要在链接这一部分才能让他们找到“家”，main函数放在.text代码段上，我们定义了data，所以data放在了.data段</li>
<li>在sum.o中，因为sum.cpp定义好了每一个位置，所以符号表都有。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421110002638.png"><br>文件头，main.o 。 .o文件就是由<strong>各种各样的段</strong>来组成的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421110042215.png"><br>可以使用objdump -s xxx.o查看段的信息<br>ld是链接器，负责链接。</li>
<li>ELF文件头记录着文件的<strong>入口点地址</strong>，程序就知道从第几行开始执行了。</li>
</ul>
<p>总结 a.out和.o文件都是由各种段组成的，但区别在a.out多了一个#program headers段，有两个load，告诉程序在运行的时候需要加载哪些数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421112526387.png"></p>
<h2 id="C-基础部分"><a href="#C-基础部分" class="headerlink" title="C++基础部分"></a>C++基础部分</h2><h3 id="形参带默认值的函数"><a href="#形参带默认值的函数" class="headerlink" title="形参带默认值的函数"></a>形参带默认值的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a = <span class="number">20</span>, <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">	cout &lt;&lt; ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码是错误的，因为在函数传参压入栈的时候，参数是由右往左压，现在b没有默认值，所以是错的，如果定义b为20，a不定义，代码是正确的。代码顺序：<strong>从上到下，从右到左给默认值</strong></p>
<h3 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><p>&#x2F;* inline内联函数和普通函数的区别？？？</p>
<ul>
<li>inline内联函数：在编译过程中，就<strong>没有函数的调用开销</strong>了，在函数的调用点直接<strong>把函数的代码进行展开处理</strong></li>
<li>inline函数不再生成相应的函数符号（objdump -t）</li>
<li>inline只是建议编译器把这个函数处理成内联函数，但是不是所有的inline都会被编译器处理成内联函数，比如递归，如果有符号说明没有内敛</li>
<li>debug版本上，inline是不起作用的；inline只有在release版本下才能出现<br>*&#x2F;<br>函数调用的过程：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="number">3.</span> <span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">	cout &lt;&lt; ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，第三行参数从右向左压栈，然后调用<strong>call</strong>指令，call 会把返回地址（main 函数中调用 sum 后的下一条指令）压入栈顶，然后跳转到 sum。要开辟函数栈帧，栈帧包含：返回地址、保存的寄存器、局部变量空间、对齐填充等。调用完后栈帧销毁，返回地址出栈，跳回 main 继续执行。虽然就是简简单单的x+y操作（三行汇编：mov add mov），但是如果循环了100000次呢？每一次都要这样开辟，很耗内存。<br>inline int sum(int x,int y)<br>{<br>    return x+y;<br>}<br>inline函数<strong>建议</strong>编译器内联展开函数（这是个建议，而不是强制），比如在第三行，很有可能编译成int ret &#x3D; a+b而不是调用函数。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>&#x2F;*</p>
<ol>
<li>c++为什么支持函数重载，c语言不支持函数重载<ul>
<li>C++代码产生函数符号的时候，是由函数名+参数列表组成的；C产生函数符号的时候，只由函数名组成。<br> 可以理解为C++：cmp_int_int &#x2F; cmp_double_double &#x2F; cmp_char *_char *，而c就会发生链接错误。</li>
</ul>
</li>
<li>函数重载需要注意什么</li>
<li>c++和c语言代码之间如何互相调用 （为何无法调用？因为函数符号不同，一个有列表一个没列表，会无法连接，<em>UND</em>）<ul>
<li>C调用C++：无法直接调用，把c++源码扩在extern “C”</li>
<li>C++调用C：把C函数的声明扩在extern “C”中<br>*&#x2F;<br>什么是重载函数？</li>
</ul>
</li>
<li>一组函数，其中函数名相同，参数列表的<strong>个数或类型不同</strong>，那么这一组函数就称为 函数重载</li>
<li>一组函数要称得上重载，一定先是处在同一个作用域中。</li>
<li>const &#x2F; volatile,是怎么影响形参类型的。</li>
<li>一组函数，函数名相同，参数列表也相同，仅仅是返回值不同，<strong>不叫重载</strong> 因为函数名参数列表都相同</li>
</ol>
<h3 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h3><ol>
<li>const与普通变量的区别<ul>
<li>const修饰的变量不能够再作为左值！！！初始化完成后，值不能被修改。</li>
<li>不能把常量的地址泄露给一个普通的指针或普通的引用变量 不能int <em>p &#x3D; const int</em></li>
</ul>
</li>
<li>c和c++中const的区别是什么?<br> const的编译方式不同，c中，const就是当作一个变量来编译生成指令的。<br> C++中，所有出现const常量名字的地方，都被常量的初始化替换了！！！所以在C++中使用const必须要初始化。比如const int a &#x3D; 20，接下来的int arr[a]，这个a不是a了，而是20。那使用指针有没有修改掉a的值呢？有，已经改掉了。</li>
<li>c++的const必须初始化，叫常量。如果用变量为const定义的量赋值，就叫常变量(和C一样了)，因为初始值不是立即数，是一个变量，这时候printf出来的都会是变量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = b;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">	*p = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(&amp;a)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const与一级指针-二级（多级）指针的结合"><a href="#const与一级指针-二级（多级）指针的结合" class="headerlink" title="const与一级指针&#x2F;二级（多级）指针的结合"></a>const与一级指针&#x2F;二级（多级）指针的结合</h3><p>c++语言规范：const修饰离它最近的类型<br><em><em>const右边如果没有指针</em>，是不参与类型的</em>*<br>const和一级指针的结合</p>
<ul>
<li>①const int <em>p &#x2F;&#x2F;修饰int，说明</em>p的值不能被改，但是p可以指向其他地方，一和二一样，const附近都是int</li>
<li>②int const *p  </li>
<li>③int *const p &#x2F;&#x2F;最靠近const的类型是：int *，修饰指针，说明指针指向不能改，但值可以改</li>
</ul>
<p><strong>总结const指针和指针类型的转换公式</strong> 理解：把一个普通指针变为const修饰的指针，告诉编译器：我不会再修改它了，是正确的</p>
<ul>
<li>int* &lt;&#x3D; const int* 是错误的</li>
<li>const int*  &lt;&#x3D; int* 是正确的</li>
</ul>
<h3 id="new-malloc-delete-free"><a href="#new-malloc-delete-free" class="headerlink" title="new&#x2F;malloc delete&#x2F;free"></a>new&#x2F;malloc delete&#x2F;free</h3><ol>
<li>delete和free的区别？malloc和free<strong>称作C的库函数</strong>，new和delete是运算符。</li>
<li>new不仅可以开辟内存，还可以初始化内存；malloc只负责开辟内存大小的空间，返回的指针是void *，所以要强制类型转换。 <code>c++int *p = (int*)malloc(sizeof(int)*20);</code></li>
<li>malloc开辟失败，是通过返回值和nullptr作比较；new开辟失败，通过<strong>抛出异常</strong>。</li>
<li>new有几种？<ul>
<li>int *p &#x3D; new int(20);</li>
<li>int *p2 &#x3D; new (nothrow) int; &#x2F;&#x2F;不抛出异常</li>
<li>const int *p3 &#x3D; new const int(40);</li>
<li>int data &#x3D; 0;int *p4 &#x3D; new (&amp;data) int(50); &#x2F;&#x2F;定位new，在指定的位置赋值</li>
</ul>
</li>
</ol>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>OOP语言的四大特征：抽象  封装&#x2F;隐藏  继承  多态<br>类：属性-&gt;成员变量  行为-&gt;成员方法<br>通过访问限定符体现：public  private  protected </p>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaLearn</title>
    <url>/2025/04/23/JavaLearn/</url>
    <content><![CDATA[<p>从今天开始，cpp转java，其实语言不是最重要的，重要的是思想，就像小学拿铅笔写字，初高中用水性笔，大学用电容笔一样，但做的都是同一件事情，写字。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>一开始就被环境变量上了一课，本博客使用hexo写的，我把D:\给删掉了，导致无法使用hexo指令，npm和node也找不到，添加完环境变量后就又能正常使用了。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>类名要和文件名相同，如果创建了Main.java文件，里面的类就要写为public class Main，否则会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印helloworld</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h3><p>可以在语句后面使用\n（字符串），但通用的语法是 +”\n” +”\t”,\t是制表符，补齐8个空格，让文本对齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">123</span>  );</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">-123</span> );</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">123.4566</span>  );</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">-123.4566</span> );</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&#x27;c&#x27;</span> + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;null\t&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="number">123</span> + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名建议"><a href="#命名建议" class="headerlink" title="命名建议"></a>命名建议</h3><p>小驼峰：方法、变量 firstName<br>大驼峰：类名 Student GoodStudent</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>和python一样，使用import，这个就是cin</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>System.out.println(1+2+”abc”+2+1);<br>会输出3abc21，因为是从左到右进行运算，一开始没有加入字符串，所以就是int运算，后面是字符串的拼接操作。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>就是c&#x2F;c++的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;14&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;15&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;16&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;17&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        playGame();</span><br><span class="line">        playGame();</span><br><span class="line">        playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>写一个5位数的验证码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] Append() &#123;</span><br><span class="line">        <span class="type">char</span>[] newchar = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">63</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            newchar[i] = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i);        <span class="comment">// 大写A-Z</span></span><br><span class="line">            newchar[i + <span class="number">26</span>] = (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);   <span class="comment">// 小写a-z</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newchar[i + <span class="number">53</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newchar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span> []wchar = Append();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            input += wchar[rand.nextInt(<span class="number">62</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(input);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，就是把大小写字母和0-9全部添加进数组里</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>和c++类似的，类里有成员变量，以及成员方法。<br><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</strong><br>this关键字：区别成员变量和局部变量，使用this就可以指向成员变量<br>标准的javabean类</p>
<ul>
<li>类名要见名知意</li>
<li>成员变量使用private修饰</li>
<li>提供至少两个构造方法<ul>
<li><strong>无参构造方法</strong></li>
<li><strong>带全部参数的有参构造方法</strong></li>
</ul>
</li>
<li>成员方法<ul>
<li><strong>提供每一个成员变量对应的set&#x2F;get</strong></li>
<li>如果还有其他行为也需要写入</li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>next();<br>nextLine();<br>这两个都是接收字符串的，next相当于cin，nextLine相当于getline<br>java中的&#x3D;&#x3D;比较，如果是比较基本数据类型就是比较值，如果比较String，就是比较地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```如果是这样，这是对的，s2复用了字符串池中的abc</span><br><span class="line">但如果是接下来的</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就不对了，new是在堆开辟了一片内存，和原来的abc不是同一个abc了。所以比较的时候不能用&#x3D;&#x3D;，而是要用equals方法<br>常用的方法</p>
<ul>
<li>equals 比较字符串是否相等</li>
<li>equalsIgnoreCase 忽略大小写的比较是否相等</li>
<li>charAt 用来遍历字符串的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较大小写，用ascii码来比较</p>
<ul>
<li>字符串切割s.subString(开始索引，结束索引)<br>StringBuilder对象不是String，要用toString将StringBuilder对象转换</li>
</ul>
<h3 id="集合ArrayList"><a href="#集合ArrayList" class="headerlink" title="集合ArrayList"></a>集合ArrayList</h3><p>相当于cpp的vector，有get，add，remove方法。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码<br>学生和老师都有吃饭，睡觉<br>但是学生可以有学习行为，老师有教书行为<br>子类在父类的基础上有更强的行为。<br>继承格式：public class 子类 extends 父类{}<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424114044935.png"><br>多层继承：子类A继承父类B，父类B继承父类C，祖孙三代。<br>java中所有的类都直接或间接继承于Object类</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同类型的对象，表现出的不同形态。<br>如果写一个学生管理系统，学生，老师，管理员都需要注册，不能写三个方法，应该是它们三个共同的父类人类接收他们三个。已经写了三个类了，它们都继承了Person<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424141834666.png"></p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象方法所在的类必须是抽象类，抽象就是你不知道它具体要干什么，但是你总结了它要干的这件事情。比如兔子吃胡萝卜，狗吃骨头，青蛙吃虫子，它们三个都能吃，但是具体吃什么就不知道了，就可以把吃这个行为给抽象出来。<br>public abstract void eat();<br><strong>super</strong>用来调用父类构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Animal(String name) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Dog: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424144053394.png"><br>应该是弥补java中不能多重继承的缺点，打补丁。接口是一种规则，是对行为的抽象<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424144345025.png"><br><strong>接口的子类要重写所有的抽象方法！</strong></p>
<h3 id="外部类和内部类"><a href="#外部类和内部类" class="headerlink" title="外部类和内部类"></a>外部类和内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">car</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String brand;</span><br><span class="line">        String color;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">engine</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age;</span><br><span class="line">            String engineName;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>内部类表示的事物是外部类的一部分,内部类单独出现没有任何意义,cpp中的结构体嵌套</p>
<p>java中的implements 表示：<strong>我承诺在这个类中会实现这个接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable是一个接口，里面只有一个方法run(),implement表明在thread类里会实现这个run</p>
]]></content>
      <categories>
        <category>javaLearn</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2025/04/25/MySQL/</url>
    <content><![CDATA[<h2 id="MySQL的数据模型"><a href="#MySQL的数据模型" class="headerlink" title="MySQL的数据模型"></a>MySQL的数据模型</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425151506824.png"><br>基于表存储的数据库叫做关系型数据库</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul>
<li>通用语法    <ol>
<li>SQL语句可以<strong>单行或多行</strong>书写，以<strong>分号</strong>结尾。</li>
<li>SQL语句可以使用空格&#x2F;缩进来增强可读性（空格缩进数量不限）</li>
<li>MySQL数据库的SQL语句<strong>不区分大小写</strong>，<strong>关键字</strong>建议使用大写</li>
<li>有多种注释</li>
</ol>
</li>
</ul>
<h3 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h3><p>语句分类<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425152338674.png"></p>
<h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><ul>
<li>查询<ol>
<li>查询所有数据库 show databases;</li>
<li>查询当前数据库 select database();</li>
</ol>
</li>
<li>创建<ol>
<li>create database 数据库名;</li>
<li>创建表:<br> create table 表名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段1 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段2 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段3 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段n 字段类型 comment &#x27;注释内容&#x27;   (注意最后一条注释没有逗号)</span><br><span class="line">)comment &#x27;表注释&#x27;;</span><br></pre></td></tr></table></figure>
 <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155452204.png"><br> <strong>varchar() 变长字符串 char() 定长字符串</strong></li>
<li>查看创建的表：</li>
</ol>
<ul>
<li>show tables;</li>
<li>desc 表名;<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155608018.png"></li>
</ul>
<ol start="4">
<li>查看表的创建信息:</li>
</ol>
<ul>
<li>show create table 表名;<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155745479.png"></li>
</ul>
</li>
<li>删除<ol>
<li>数据库删除<br> drop database 数据库名;</li>
<li>表字段删除<br> alter table 表名 字段名;</li>
<li>表删除<br> drop table 表名;</li>
</ol>
</li>
<li>使用<ol>
<li>use 数据库名</li>
</ol>
</li>
<li>表修改操作<ol>
<li>修改（增加）<br>  alter table 表名 add 字段名 字段类型 comment ‘’;</li>
<li>修改数据类型<br>  alter table 表名 modify 字段名 新数据类型(长度)</li>
<li>修改字段名和字段类型<br>  alter table 表名 change 旧字段名 新字段名 类型(长度) comment ‘’;</li>
<li>修改表名<br>  alter table 表明 rename to 新表名;</li>
</ol>
</li>
</ul>
<h4 id="DML-data-manipulation-language"><a href="#DML-data-manipulation-language" class="headerlink" title="DML (data manipulation language)"></a>DML (data manipulation language)</h4><ol>
<li>添加数据(insert)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425174721753.png"></li>
<li>修改数据(update)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425180743091.png"><br>update em set name &#x3D; ‘itheima’ where id &#x3D; 1;<br>update em set entrytime &#x3D; ‘2008-01-01’; 如果不带where代表要执行整张表的数据</li>
<li>删除数据(delete)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425181556477.png"></li>
</ol>
<h4 id="DQL-data-query-language-用来-查询数据-的，设计的关键字select"><a href="#DQL-data-query-language-用来-查询数据-的，设计的关键字select" class="headerlink" title="DQL (data query language) 用来 查询数据 的，设计的关键字select"></a>DQL (data query language) 用来 查询数据 的，设计的关键字select</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425184335313.png"></p>
<ol>
<li>基本查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425184335313.png"></li>
<li>条件查询(<strong>加where</strong>)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425190554345.png"></li>
</ol>
<ul>
<li>查询没有身份证的员工select * from em where idcard is null; （使用is null）</li>
<li>查询有 is not null</li>
<li>查询姓名为两个字的员工，用like + 两个占位符__ select * from em where name like ‘__’;</li>
<li>查询身份证最后一个位是X  select * from em where idcard like ‘%X’;</li>
</ul>
<ol start="3">
<li>聚合函数（将一列数据作为一个整体，进行纵向计算）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425192935227.png"></li>
<li>分组查询<br>注意：先where，然后在where里分组后执行聚合函数，然后再执行having，分组之后，查询的字段一般为<strong>分组字段和聚合函数，查询其他的是没有意义的</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425193446332.png"></li>
</ol>
<ul>
<li>分组性别统计数量  select gender,count(*) from em group by gender ;</li>
<li>分组性别统计年龄 select gender,avg(age) from em group by gender;</li>
<li>年龄小于45 根据工作地址分组 获取员工数量大于3的地址<br>select workaddress,count(*) from em where age &lt;45 group by workaddress having count(*)&gt;&#x3D;3;<br>先写年龄小于45，然后再写分组，然后再挑数量，想要知道数量前面是谁？加上你选择分组的东西，最后再额外条件。</li>
</ul>
<ol start="5">
<li><p>排序查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425195312558.png"></p>
</li>
<li><p>分页查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425200216365.png"></p>
</li>
</ol>
<h4 id="DCL-Data-Control-Language数据控制语言-有哪些用户可以访问服务器，控制每一个用户的访问权限"><a href="#DCL-Data-Control-Language数据控制语言-有哪些用户可以访问服务器，控制每一个用户的访问权限" class="headerlink" title="DCL (Data Control Language数据控制语言) 有哪些用户可以访问服务器，控制每一个用户的访问权限"></a>DCL (Data Control Language数据控制语言) 有哪些用户可以访问服务器，控制每一个用户的访问权限</h4><ol>
<li>管理用户<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425201101284.png"></li>
<li>授予权限<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425201200579.png"></li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425203403010.png"></p>
<h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425203317834.png"><br>select lpad(round(rand()*1000000,0),6,’0’); 实现六位数的随机验证码</p>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425204154624.png"><br>select name,datediff(curdate(),entrydate) ‘entrydays’ from em order by entrydays;</p>
<h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425205106262.png"></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>create table user(<br>    id int primary key auto_increment comment ‘主键’,<br>    name varchar(10) not null unique comment ‘姓名’,<br>    age int check ( age &gt; 0 &amp;&amp; age &lt; 120 ) comment ‘年龄’,<br>    status char(1) default (1) comment ‘状态’,<br>    gender char(1) comment ‘性别’<br>)comment ‘用户表’;<br>这些都是约束<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425205304798.png"></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425211835852.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br>比如银行转账。如果出错就要执行rollback回滚，设置为手动提交，autocommit &#x3D; 0，commit<br>事务的四大特性：</p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<h2 id="SQL刷题"><a href="#SQL刷题" class="headerlink" title="SQL刷题"></a>SQL刷题</h2><p><strong>语法顺序是 FROM → WHERE → GROUP BY →  聚合函数 -&gt; HAVING → SELECT → ORDER BY</strong></p>
<ul>
<li><code>distinct</code>  使用 DISTINCT 可以把这些重复行合并，只保留唯一的一条。</li>
<li>length &#x2F; char_length有什么区别？<ul>
<li>按“字符个数”限制、截断或统计时，用 CHAR_LENGTH。</li>
<li>需要估算存储空间或网络传输大小时，用 LENGTH。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;你好&#x27;</span>)   <span class="comment">-- 返回 2</span></span><br><span class="line">     , LENGTH(<span class="string">&#x27;你好&#x27;</span>);      <span class="comment">-- 在 utf8 下返回 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>日期用between</li>
<li>多表查询 ： 左连接、右连接、内连接。<ul>
<li>左、右连接会补null</li>
<li>内连接（inner join&#x2F;join）只会匹配表中有的数据</li>
<li>*<strong>先 ON 联结，后 WHERE 过滤</strong></li>
</ul>
</li>
<li>聚合函数<ul>
<li>排序：order by 列名 + asc&#x2F;desc</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2025/04/27/javaweb/</url>
    <content><![CDATA[<p>Server后端开发：代码开发（java）–框架简化代码（Spring）–用包（库，包管理器：Maven）<br>总结就是三步：语言，框架，以及包</p>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ul>
<li>get请求：直接在url里请求，如weather?city&#x3D;beijing</li>
<li>post请求：用请求体的方式进行请求</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dish&quot;:宫保鸡丁</span><br><span class="line">&quot;spicy&quot;:false</span><br></pre></td></tr></table></figure>

<p>拼接起来就是：Fronted—www—Server—Database<br>前端发送到后端的叫请求(Request)，后端发给前端的叫响应(Response)。</p>
<h3 id="web网站的工作流程"><a href="#web网站的工作流程" class="headerlink" title="web网站的工作流程"></a>web网站的工作流程</h3><p>一个web网站大致由三个部分组成：前端服务器(前端程序)，后端服务器(后端程序)，数据库服务器<br>用户在浏览器输入域名，浏览器会根据域名请求访问前端服务器，前端服务器在接收到请求后会向浏览器返回前端代码，(浏览器也是一个程序，内置了解析前端代码的解析引擎)，从而解析出对应的页面样式<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250427193730312.png"><br>需要学习的技术：Maven、SpringBoot Web、MySQL(got it)、SpringBoot Mybatis</p>
<h3 id="初识web前端"><a href="#初识web前端" class="headerlink" title="初识web前端"></a>初识web前端</h3><ul>
<li>网页的组成部分：文字、图片、音频、超链接、视频</li>
<li>我们看到的网页背后的本质：<strong>前端代码</strong></li>
<li>前端代码如何转换成用户眼中的网页：<strong>浏览器</strong>转化(解析和渲染(浏览器内核))成用户看到的网页</li>
</ul>
<p>Web标准：</p>
<ul>
<li>HTML(HyperText Markup Language):负责网页的结构（页面元素和内容）</li>
<li>CSS：负责网页的表现（页面元素的外观，位置等页面样式，如颜色，大小）</li>
<li>JavaScript：负责网页的行为（交互效果）<br>常用标签</li>
<li>vscode装了插件之后直接!</li>
<li>hr:水平线，一般有两个</li>
<li>h1-h6：六级标题对应不同大小</li>
<li>img：插入图片，可以绝对路径或者相对路径，一般用相对路径。还可以设置宽高，但一般只设置一个，会等比例缩放</li>
<li>title：网页名字<br>2025.4.27</li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Maven 是一个项目管理和构建工具，主要用于管理 Java 项目的依赖库，以及自动化项目的编译、打包、测试、部署等过程。<br>简单理解就是：</p>
<ul>
<li>你在开发 JavaWeb 项目的时候，需要很多第三方库（比如数据库连接池、日志框架等等）。</li>
<li>Maven 帮你自动下载、管理版本，不用你手动找 jar 包。</li>
<li>它还能一键构建项目，比如一条命令就能打成 war 包部署到服务器上。<br>成功配置maven<br>2025.4.28</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul>
<li>SpringBoot快速入门<ol>
<li>创建SpringBoot工程，勾选web开发</li>
<li>编写请求处理类（加上注解）</li>
<li>看本地占用端口，打开浏览器访问端口<br>要写注解</li>
</ol>
</li>
<li>@RequestController告诉SpringBoot直接返回内容到页面</li>
<li>@RequestMapping是访问路径<br>简单url是 <a href="http://localhost:8080/array?hobby=sing&hobby=jump&hobby=rap&hobby=basketball">http://localhost:8080/array?hobby=sing&amp;hobby=jump&amp;hobby=rap&amp;hobby=basketball</a></li>
</ul>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><strong>MySQL账号密码：root 1234</strong><br>MyBatis用来简化JDBC开发的框架，<strong>用来操作数据库</strong>。<br>包是组织<strong>类</strong>的，模块是组织<strong>包</strong>的。</p>
<h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><ul>
<li>准备数据库表(dept\emp)</li>
<li>创建SpringBoot工程，引入对应的依赖：web、mybatis、mysql驱动、lombok</li>
<li>配置文件：引入mybatis的配置信息，准备对应的实体类</li>
<li>准备对应的Mapper、Service（接口、实现类）、Controller基础结构</li>
</ul>
<h2 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h2><ul>
<li>比如要写一个url:dept&#x2F;1,dept&#x2F;2，后面的id是变动的，我们就需要RequestVariable注解来获取这个id，多参数也一样</li>
<li>以下这个代码程序就是获取url里的变量，前一步要使用RequestMapping来绑定路径参数@</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&#x27;/path/&#123;id&#125;/&#123;name&#125;&#x27;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GetVariable</span><span class="params">(<span class="meta">@RequestVariable</span> Integer id,<span class="meta">@RequestVariable</span> String name)</span></span><br><span class="line">&#123;</span><br><span class="line">    sout(id + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><ul>
<li>controller：控制层，接收前端发来的请求，对请求进行处理，并响应数据</li>
<li>service：业务逻辑层，处理具体的业务逻辑</li>
<li>dao：数据访问层（data access object，持久层），负责数据的访问操作，包括数据的增删改查</li>
</ul>
<h2 id="控制反转（IOC）与依赖注入（DI）"><a href="#控制反转（IOC）与依赖注入（DI）" class="headerlink" title="控制反转（IOC）与依赖注入（DI）"></a>控制反转（IOC）与依赖注入（DI）</h2><ul>
<li>这两个的功能是为了更好的解耦三层架构，使用控制反转IOC(在类外加上<code>@Component</code>注解)，可以把这个类交给IOC来管理，成为IOC的bean对象。等到别的层需要调用的时候，使用@Autowired进行依赖注入，这样就解耦了。</li>
<li>声明bean有四个注解：@Component，@Controller（管控制层），@Service（管业务层），@Repository（管数据访问层，这个用的少，会用@Mapper替换）</li>
<li>依赖注入的是<strong>接口，interface</strong>，我们想要让接口的某一个实现类，就写好实现类；如果有多个实现类，参考下面一条。</li>
<li>依赖注入时如果有多个同类型的bean，可以通过@Primary(提高优先级)，@Autowired+@Qulifier(“bean的名称”)，@Resource(name&#x3D;”bean的名称”)</li>
</ul>
<h3 id="面试问道是否了解IoC以及DI"><a href="#面试问道是否了解IoC以及DI" class="headerlink" title="面试问道是否了解IoC以及DI"></a>面试问道是否了解IoC以及DI</h3><ul>
<li>IOC 也就是控制反转，核心思想是把对象的创建和管理交给 Spring 容器，而不是我们自己去 new。这样可以降低代码耦合。Spring 会扫描带有 @Component、@Service、@Controller、@Repository 的类，把它们注册成 bean，统一交给 IOC 容器管理。</li>
<li>DI 是依赖注入，也就是当某个类需要依赖其他对象时，Spring 会自动把对应的 bean 注入进来，我们只需要在属性或构造方法上加 @Autowired 就可以了。</li>
<li>如果一个接口有多个实现类，Spring 无法确定要注入哪个，这时候可以用 @Qualifier(“beanName”) 或 @Resource(name&#x3D;”beanName”) 来指定，也可以在某个实现类上加 @Primary，让它成为默认注入的对象。</li>
</ul>
]]></content>
      <categories>
        <category>javaLearn</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>javaAlgorithm</title>
    <url>/2025/05/19/javaAlgorithm/</url>
    <content><![CDATA[<p>java是一种<strong>面向对象</strong>的语言，入口程序也是一个<strong>类</strong>，类的属性有public,private,protected;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>(String arg[])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2025.5.19</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>应用场景：<strong>有序</strong> <strong>数组</strong><br>二分三元素 ：<strong>left，mid，right</strong><br>目标可能存在的区间，在[left,right]之间，所以循环条件就是他。<br>循环变更的是：left和right，是基于这一次选择的mid来变更的，而不是left和right++ &#x2F; –1；<br>时间复杂度：logN<br><a href="https://leetcode.cn/problems/binary-search/">二分查找</a><br><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/description/">猜数字大小</a><br><a href="https://leetcode.cn/problems/search-insert-position/description/">搜索插入位置</a><br><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">在排序数组中查找元素的第一个和最后一个位置</a><br><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a><br><a href="https://leetcode.cn/problems/first-bad-version/description/">第一个错误的版本</a><br><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/">山脉数组的峰顶索引</a><br><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a><br><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">搜索旋转排列数组Ⅱ</a><br><a href="https://leetcode.cn/problems/find-in-mountain-array/description/">山脉数组中查找目标值</a></p>
<p>2025.5.20</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长字串</a><br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a><br><a href="https://leetcode.cn/problems/permutation-in-string/description/">最小覆盖字串</a></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈中使用push()&#x2F;pop()来 添加&#x2F;删除元素，peek()查看栈顶元素<br><a href="https://leetcode.cn/problems/simplify-path/description/">简化路径</a>StringBuilder以及字符串切割<br><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式</a><br><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></p>
<p>2025.5.21</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/3sum/">三数之和</a><br><a href="https://leetcode.cn/problems/3sum-closest/description/">最接近的三数之和</a></p>
<p>2025.5.22</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>优先队列视为堆，默认是最小堆，堆中使用add()&#x2F;poll() 进行添加&#x2F;删除元素，peek查看堆顶元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;T&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">//最小堆</span></span><br><span class="line">PriorityQueue&lt;T&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparation.reverseOrder()); <span class="comment">//最大堆 </span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第k个最大元素</a><br><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">前k个高频元素</a><br><a href="https://leetcode.cn/problems/sort-characters-by-frequency/description/">根据字符出现频率排序</a><br><a href="https://leetcode.cn/problems/k-closest-points-to-origin/description/">最接近原点的 K 个点</a></p>
<p>2025.5.23</p>
<h2 id="树-递归法"><a href="#树-递归法" class="headerlink" title="树 递归法"></a>树 递归法</h2><p>DFS用递归，BFS用队列，总结一下：充分利用好前中后序列以及层序遍历，善用队列以及递归。<br><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树的后序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">二叉树的层序遍历Ⅱ</a><br><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">二叉树的锯齿形层次遍历</a><br><a href="https://leetcode.cn/problems/same-tree/description/">相同的树</a><br><a href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树</a><br><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">二叉树的右视图</a><br><a href="https://leetcode.cn/problems/invert-binary-tree/description/">翻转二叉树</a><br><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">平衡二叉树</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a><br><a href="https://leetcode.cn/problems/path-sum/description/">路经总和</a><br><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p>
<h2 id="图的遍历，回溯"><a href="#图的遍历，回溯" class="headerlink" title="图的遍历，回溯"></a>图的遍历，回溯</h2><p>2025.5.24 &amp;&amp; 2025.5.25<br><a href="https://leetcode.cn/problems/permutations/">全排列</a><br><a href="https://leetcode.cn/problems/path-sum-ii/description/">路径总和Ⅱ</a><br><a href="https://leetcode.cn/problems/permutations-ii/description/">全排列</a><br><a href="https://leetcode.cn/problems/flood-fill/">图像渲染</a><br><a href="https://leetcode.cn/problems/word-search/description/">单词搜索</a><br><a href="https://leetcode.cn/problems/number-of-islands/description/">岛屿数量</a></p>
<p>2025.5.26<br><a href="https://leetcode.cn/problems/surrounded-regions/description/">被围绕的区域</a><br><a href="https://leetcode.cn/problems/number-of-enclaves/description/">飞地的数量</a></p>
<h2 id="简单的动态规划"><a href="#简单的动态规划" class="headerlink" title="简单的动态规划"></a>简单的动态规划</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/description/">斐波那契数</a><br><a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a><br><a href="https://leetcode.cn/problems/decode-ways/description/">解码方法</a></p>
<p>2025.5.28<br><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">最大子数组和</a></p>
]]></content>
      <categories>
        <category>javaLearn</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/2025/05/27/jvm/</url>
    <content><![CDATA[<h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><ul>
<li>定义：Java Virtual Machine <strong>java程序的运行环境（更确切：java二进制字节码的运行环境）</strong></li>
<li>好处：<ul>
<li>一次编写，到处运行的基石（跨平台）</li>
<li>自动内存管理，垃圾回收功能（垃圾回收处理<strong>堆内存</strong>的无用对象）</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
</li>
<li>比较：<strong>Jvm Jre Jdk的关系</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527085752230.png"></li>
</ul>
<h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><h3 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul>
<li>Program Counter Register 使用<strong>寄存器</strong>实现</li>
</ul>
<h4 id="2-作用："><a href="#2-作用：" class="headerlink" title="2. 作用："></a>2. 作用：</h4><ul>
<li>记住下一条jvm指令的执行地址</li>
</ul>
<h4 id="3-特点："><a href="#3-特点：" class="headerlink" title="3. 特点："></a>3. 特点：</h4><ul>
<li>线程私有：每一个线程都是独立的，都有自己的时间片，以及自己的程序计数器</li>
<li>不会存在内存溢出</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="1-定义（java-virtual-machine-stacks）"><a href="#1-定义（java-virtual-machine-stacks）" class="headerlink" title="1. 定义（java virtual machine stacks）"></a>1. 定义（java virtual machine stacks）</h4><ul>
<li>每个线程运行时所需要的内存称为虚拟机栈，<strong>线程私有</strong></li>
<li>栈由多个<strong>栈帧（Frame）组成，每个栈帧对应一次方法调用。</strong></li>
<li>每个线程只能有一个活动栈帧，<strong>对应着当前正在执行的那个方法</strong>（人话：栈顶）</li>
</ul>
<h4 id="2-问题辨析："><a href="#2-问题辨析：" class="headerlink" title="2. 问题辨析："></a>2. 问题辨析：</h4><ol>
<li>垃圾回收是否涉及栈内存？<ul>
<li>不涉及。虚拟机栈随着方法调用自动创建和销毁，不由 GC 管理。</li>
</ul>
</li>
<li>栈内存分配越大越好吗？<ul>
<li>大栈空间意味着系统能够同时创建的线程数减少，影响并发能力。 比如栈空间1m，物理内存500m，可以跑500个线程，但如果栈空间2m，只能跑250个线程。</li>
<li>上下文切换开销大，线程切换需要<strong>保存&#x2F;恢复</strong>上下文信息。</li>
<li>若程序调用栈不深，反而浪费内存。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？（判断是否是线程安全要看变量是否是<strong>共享&#x2F;私有</strong>的）<ul>
<li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</li>
<li>如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全</li>
</ul>
</li>
</ol>
<h4 id="3-栈内存溢出"><a href="#3-栈内存溢出" class="headerlink" title="3. 栈内存溢出"></a>3. 栈内存溢出</h4><ul>
<li>方法调用层级过深（递归未终止）导致<strong>栈帧过多。</strong></li>
<li>单个栈帧过大（如定义超大数组、局部变量过多）导致<strong>内存耗尽。</strong></li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>native method，不是由java代码编写的方法，由c&#x2F;c++实现。用本地方法接口</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="1-定义（Heap）"><a href="#1-定义（Heap）" class="headerlink" title="1. 定义（Heap）"></a>1. 定义（Heap）</h4><ul>
<li>通过new关键字创建的对象都会使用堆内存</li>
<li>是<strong>JVM中最大的一块内存区域</strong>，用于<strong>存储所有对象实例和数组</strong>。</li>
</ul>
<h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><strong>线程共享</strong>：多个线程可以访问堆中的同一对象，需考虑线程安全问题。</li>
<li><strong>由垃圾回收器管理</strong>：GC 自动清理无引用对象，回收内存空间。</li>
</ul>
<h4 id="3-堆内存溢出（OutOfMemoryError-Java-heap-space）"><a href="#3-堆内存溢出（OutOfMemoryError-Java-heap-space）" class="headerlink" title="3. 堆内存溢出（OutOfMemoryError: Java heap space）"></a>3. 堆内存溢出（OutOfMemoryError: Java heap space）</h4><ul>
<li>只要new出来的对象还在被使用，就不会被回收，一直在添加，最后会溢出。</li>
</ul>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul>
<li>JVM 内存结构的一部分，用于<strong>存储类的元数据信息</strong>，包括：<ul>
<li>类的结构（字段、方法、接口等）</li>
<li>常量池（如字符串字面量、符号引用）</li>
<li>静态变量</li>
<li>类的代码（字节码）、JIT 编译后的代码等</li>
</ul>
</li>
</ul>
<h4 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul>
<li><strong>所有线程共享</strong>；</li>
<li>属于 JVM 规范中规定的逻辑区域；</li>
<li>在 HotSpot 虚拟机中，早期称为 <strong>永久代（PermGen）</strong>，从 <strong>JDK 8</strong> 起被 <strong>元空间（Metaspace）</strong> 取代；</li>
<li>元空间使用 <strong>本地内存</strong>（非堆内存）进行分配；</li>
<li>方法区也会发生内存溢出，例如：动态加载大量类时抛出 <code>OutOfMemoryError: Metaspace</code>。</li>
</ul>
<h4 id="3-常见用途"><a href="#3-常见用途" class="headerlink" title="3. 常见用途"></a>3. 常见用途</h4><ul>
<li>类加载（包括反射、代理等）</li>
<li>存放静态成员和常量</li>
<li>热点代码编译缓存（如 JIT 编译结果）</li>
</ul>
<h4 id="4-简洁记忆"><a href="#4-简洁记忆" class="headerlink" title="4. 简洁记忆"></a>4. 简洁记忆</h4><blockquote>
<p>方法区用于存放类信息、常量、静态变量，是线程共享的逻辑区域，从 JDK 8 起由元空间替代。</p>
</blockquote>
<h4 id="5-运行时常量池"><a href="#5-运行时常量池" class="headerlink" title="5. 运行时常量池"></a>5. 运行时常量池</h4><ul>
<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>.class 文件里有一张“常量池表”（静态的）；加载这个类时，这张表内容就复制进 JVM 的运行时常量池；JVM 执行方法时，所有的名字、字面量、描述信息都要从这里查；它就像“JVM的大字典”，翻译代码里各种符号，让它知道具体地址和内容。</li>
</ul>
<h5 id="StringTable（串池）"><a href="#StringTable（串池）" class="headerlink" title="StringTable（串池）"></a>StringTable（串池）</h5><ol>
<li>StringTable特性<br>在预编译的时候会创建常量池，将字符串都添加进常量表中，比如s1,s2,s3就会被添加进串池里，s4的时候使用拼接字符串，其实底层调用了StringBuilder的append方法，new出了一个StringBuilder对象，一个在方法区，一个在堆区，他们所指向的对象不同，比较结果自然false；<br>如果使用equals，只需要比较值，如果使用&#x3D;&#x3D;，需要比较值和指向的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1+s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1+s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s4==s5);</span><br><span class="line">        System.out.println(s3==s6);</span><br><span class="line">    &#125;v</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结 ： &#x3D;&#x3D; 比较的是“是不是同一个人”，.equals() 比较的是“名字是不是一样”。</p>
</blockquote>
<ul>
<li>常量池中的字符串仅是符号，第一次用到时才成为对象</li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串变量拼接的原理是StringBuilder(1.8)</li>
<li>字符串常量拼接的原理是编译器优化 “a”+”b” 直接优化成 “ab”</li>
<li>可以使用intern方法，主动将串池中还没有的字符串放进串池。<ul>
<li>s.intern() 尝试将字符串s的内容放入常量池，如果常量池里有s，那就返回常量池的内容；如果常量池中没有s，就将s添加进入常量池，并返回常量池中的s</li>
</ul>
</li>
</ul>
<ol start="2">
<li>StringTable位置</li>
</ol>
<h2 id="垃圾回收-GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。"><a href="#垃圾回收-GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。" class="headerlink" title="垃圾回收 GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。"></a>垃圾回收 GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。</h2><h3 id="1-如何判断一个对象可以被回收"><a href="#1-如何判断一个对象可以被回收" class="headerlink" title="1.如何判断一个对象可以被回收"></a>1.如何判断一个对象可以被回收</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>循环引用会导致内存泄漏</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h4><h5 id="1-原理："><a href="#1-原理：" class="headerlink" title="1.原理："></a>1.原理：</h5><p>夏天吃葡萄，拎起一串葡萄，如果在根上的就不是垃圾，不能被回收；掉落下来的可以回收。</p>
<ul>
<li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活对象</li>
<li>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到表示可以回收。</li>
<li>哪些对象可以作为GC Root？</li>
</ul>
<h5 id="2-四种（-一个终结器）引用"><a href="#2-四种（-一个终结器）引用" class="headerlink" title="2. 四种（+一个终结器）引用"></a>2. 四种（+一个终结器）引用</h5><h6 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h6><ul>
<li>最常见、默认的引用方式，例如：<code>Object obj = new Object();</code></li>
<li>只要强引用还存在，<strong>对象永远不会被 GC 回收</strong></li>
<li>应用场景：日常代码中创建对象时默认的引用类型</li>
</ul>
<h6 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h6><ul>
<li>使用类：<code>SoftReference&lt;T&gt;</code></li>
<li>当内存不足时才会被 GC 回收，<strong>适合做缓存</strong></li>
<li>示例：图片缓存、内存敏感对象</li>
<li>应用场景：避免 OOM 时自动释放内存</li>
</ul>
<h6 id="3-弱引用（Weak-Reference）"><a href="#3-弱引用（Weak-Reference）" class="headerlink" title="3. 弱引用（Weak Reference）"></a>3. 弱引用（Weak Reference）</h6><ul>
<li>使用类：<code>WeakReference&lt;T&gt;</code></li>
<li>一旦 GC 运行，无论内存是否足够，都会被回收</li>
<li>示例：<code>ThreadLocal</code> 中的值、<code>WeakHashMap</code></li>
<li>应用场景：辅助结构、缓存，但对象生命周期短</li>
</ul>
<h6 id="4-虚引用（Phantom-Reference）"><a href="#4-虚引用（Phantom-Reference）" class="headerlink" title="4. 虚引用（Phantom Reference）"></a>4. 虚引用（Phantom Reference）</h6><ul>
<li>使用类：<code>PhantomReference&lt;T&gt;</code> + <code>ReferenceQueue&lt;T&gt;</code></li>
<li><strong>无法通过引用获取对象</strong>，仅用于监听对象是否即将被 GC 回收</li>
<li>应用场景：资源清理、DirectMemory 手动释放等高级用途</li>
</ul>
<h6 id="5-终结器引用（Finalizer-Cleaner）"><a href="#5-终结器引用（Finalizer-Cleaner）" class="headerlink" title="5. 终结器引用（Finalizer &#x2F; Cleaner）"></a>5. 终结器引用（Finalizer &#x2F; Cleaner）</h6><ul>
<li>一种过时的引用机制，依赖 <code>finalize()</code> 方法</li>
<li>对象在被 GC 回收前，会被加入 Finalizer 队列，并延迟处理</li>
<li>缺点：性能差、不可控、不推荐使用</li>
<li>JDK 9+ 推荐使用 <code>java.lang.ref.Cleaner</code> 替代<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527153314738.png"><blockquote>
<p>记忆口诀：<strong>强软弱虚，越来越容易被回收</strong>；终结器引用用于回收通知，但现在被 Cleaner 替代。<br><strong>GC 就是根据“引用关系”判断对象是否还能活着；没有引用的对象，才是“垃圾”。</strong></p>
</blockquote>
</li>
</ul>
<h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><h4 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1.标记清除"></a>1.标记清除</h4><ul>
<li><strong>基本思想</strong>：从 GC Roots 出发，标记所有可达对象；标记完成后，清除未被标记的对象。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527153606894.png"></li>
<li>优点：速度快</li>
<li>缺点：内存碎片太多，内存空间不连续。</li>
</ul>
<h4 id="2-标记整理"><a href="#2-标记整理" class="headerlink" title="2.标记整理"></a>2.标记整理</h4><ul>
<li><strong>基本思想</strong>：先从 GC Roots 出发标记所有可达对象，然后<strong>将存活对象向一端移动</strong>，最后清理掉边界以外的无效内存。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527154143192.png"></li>
<li>优点：碎片化消失</li>
<li>缺点：效率降低，因为涉及地址的移动</li>
</ul>
<h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3.复制"></a>3.复制</h4><ul>
<li><strong>基本思想</strong>：将内存分为两块等大小的区域（from 和 to）。每次 GC 时，从 GC Roots 标记存活对象，然后将其<strong>复制到另一块空间（to）</strong>，保持连续分布，最后清空 from 区并交换角色。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527154506611.png"></li>
<li>优点：避免碎片化</li>
<li>缺点：双倍空间</li>
</ul>
<h3 id="3-分代垃圾回收（Generational-Garbage-Collection）"><a href="#3-分代垃圾回收（Generational-Garbage-Collection）" class="headerlink" title="3. 分代垃圾回收（Generational Garbage Collection）"></a>3. 分代垃圾回收（Generational Garbage Collection）</h3><p>Java 堆内存被划分为两大区域：</p>
<ul>
<li><strong>新生代（Young Generation）</strong><ul>
<li>包括三部分：伊甸园 区、Survivor <strong>From</strong> 区、Survivor <strong>To</strong> 区</li>
<li>采用 <strong>复制算法</strong> 进行垃圾回收</li>
</ul>
</li>
<li><strong>老年代（Old Generation）</strong><ul>
<li>存放存活时间长、经过多次 GC 仍未回收的对象</li>
<li>通常采用 <strong>标记-整理算法</strong><blockquote>
<p>类比比喻：<strong>新生代 &#x3D; 日常清理，老年代 &#x3D; 每年大扫除</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527160108307.png"></p>
<h4 id="新生代回收流程（Minor-GC）："><a href="#新生代回收流程（Minor-GC）：" class="headerlink" title="新生代回收流程（Minor GC）："></a>新生代回收流程（Minor GC）：</h4><ul>
<li>所有新对象优先分配在 <strong>Eden 区</strong>；</li>
<li>当 Eden 区满了，就触发一次 <strong>Minor GC</strong>；</li>
<li>GC 时，将 Eden 和 From 区存活的对象<strong>复制到 To 区</strong>，并<strong>对象年龄+1</strong>；</li>
<li>From 和 To 区角色互换（类似复制算法）；</li>
<li>若对象年龄超过一定阈值（如 15 次），就<strong>晋升到老年代</strong>。</li>
</ul>
<h4 id="老年代回收流程（Full-GC）："><a href="#老年代回收流程（Full-GC）：" class="headerlink" title="老年代回收流程（Full GC）："></a>老年代回收流程（Full GC）：</h4><ul>
<li>如果老年代空间不足，先尝试触发 Minor GC；</li>
<li>如果仍不足，将触发一次 <strong>Full GC</strong>，同时回收新生代和老年代；</li>
<li>Full GC 开销大，伴随 <strong>Stop The World（STW）</strong>，影响性能更显著。</li>
</ul>
<h4 id="额外说明："><a href="#额外说明：" class="headerlink" title="额外说明："></a>额外说明：</h4><ul>
<li><strong>Minor GC</strong>：发生频率高，时间短，只回收新生代；会触发一次stop the world</li>
<li><strong>Full GC</strong>：发生频率低，时间长，会暂停所有线程。</li>
</ul>
<blockquote>
<p>💡 新生代回收通常使用“复制算法”，老年代回收通常使用“标记-整理算法”。</p>
</blockquote>
<h2 id="类加载（ClassLoader）"><a href="#类加载（ClassLoader）" class="headerlink" title="类加载（ClassLoader）"></a>类加载（ClassLoader）</h2><h2 id="JMM（Java-Memory-Modle）"><a href="#JMM（Java-Memory-Modle）" class="headerlink" title="JMM（Java Memory Modle）"></a>JMM（Java Memory Modle）</h2><p>java内存模型，JMM定义了一套在多线程读写共享数据时（成员变量，数组）时，对数据的可见性、有序性和原子性的规则和保障。</p>
<h3 id="为什么要加锁"><a href="#为什么要加锁" class="headerlink" title="为什么要加锁"></a>为什么要加锁</h3><ul>
<li>可见性问题：CPU的速度高，当CPU修改了缓存中的数据但还没写回主存时，线程B读取了主存中的数据，就发生了数据读写冲突。一个线程修改了共享数据，但是另外一个线程无法立刻获取到最新的共享数据</li>
<li>有序性问题：CPU或编译器对指令进行重排序，导致代码执行顺序和书写顺序不一致。</li>
</ul>
<hr>
<ul>
<li>synchronized编译后是<code>monitor enter</code>和<code>monitor exit</code>两个指令<ul>
<li>monitor enter（加锁）会使用<strong>读屏障</strong>，强行从主存重新读取数据，保证数据是最新的</li>
<li>monitor exit（解锁） 会使用<strong>写屏障</strong>，强行将缓存中的变量刷新到主存中</li>
</ul>
</li>
</ul>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><blockquote>
<p>为什么要做锁升级</p>
</blockquote>
<ul>
<li>java线程模型是一对一的，每一个线程调用都涉及到操作系统的从用户态到内核态的转换，开销很大。所以在低并发的情况下就不让你阻塞，只要不阻塞，就不用有切换状态。并发量高的时候再去阻塞。如：购物软件凌晨低并发，周末，晚上休息时间高并发。</li>
<li>为了降低 低并发情况下获得锁的代价，为了提高低并发时候的性能</li>
</ul>
<blockquote>
<p>那为什么会慢？</p>
</blockquote>
<ul>
<li>synchronized说到底层还是要调用操作系统的原语mutex，然后又涉及到线程的<code>阻塞与唤醒</code></li>
</ul>
<h3 id="状态演变"><a href="#状态演变" class="headerlink" title="状态演变"></a>状态演变</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529133440600.png"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>最开始是无锁状态，当有第一个线程来访问同步代码块时，JVM将对象头的Mark Word锁标志位设置为偏向锁，然后将线程id记录到markword中。偏向锁考虑只有一个线程抢锁的场景。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当第二个线程来抢锁就升级为轻量级锁，第二个线程拿不到锁就采用CAS + 自旋不断尝试重复获得锁<br>为什么要有轻量级锁？</p>
<ul>
<li>考虑的是竞争锁的线程不多，而且线程持有锁的时间也不长。都没有进行上下文切换以及操作系统级的线程阻塞和切换</li>
</ul>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>当第二个线程自旋到一定次数之后还没获得锁，或者有别的线程也来抢锁了，那就升级为<code>重量级锁</code>。重量级锁加锁就需要调用操作系统的<strong>底层原语mutex</strong>，所以每次切换线程都需要操作系统从用户态切换成内核态，<strong>开销很大，所以称之为重量级锁</strong>。把那些没拿到锁的线程全都<strong>阻塞</strong>，当升级到重量级锁的时候，对象头的Markword指针就会指向锁监视器monitor。<br>为什么一定要升级为重量级锁？</p>
<ul>
<li>因为自旋只适合于锁的竞争比较小，而且执行时间比较短的程序。要是大量线程都在自旋等待，CPU时间被浪费了。</li>
</ul>
<h4 id="锁监视器Monitor"><a href="#锁监视器Monitor" class="headerlink" title="锁监视器Monitor"></a>锁监视器Monitor</h4><p>锁监视器主要是用来负责记录锁的拥有者，记录锁的重入次数，负责线程的阻塞唤醒，锁监视器就是一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectMonitior</span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *_owner; <span class="comment">//锁拥有者</span></span><br><span class="line">    WaitSet _WaitSet; <span class="comment">//等待池（管理调用wait()方法的线程）</span></span><br><span class="line">    EntryList _EntryList; <span class="comment">//锁池（管理因竞争锁失败而阻塞的线程）</span></span><br><span class="line">    <span class="type">int</span> _recursions <span class="comment">//记录锁重入次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>重入次数作用？<ul>
<li>当一个线程重复去获取这个锁，这就是可重入锁，重入一次++，释放一次–，减到0就是释放锁了。</li>
</ul>
</li>
<li>锁池和等待池是干什么的？<ul>
<li>在重量级锁状态下，当有线程拿到锁，此时监视器的owner字段就记录拿到锁的线程，没有拿到锁的就进入blocking状态，然后放到锁池中；当拿到锁的线程调用了wait()方法，那该线程就释放锁，然后进入waiting状态，然后被放到等待池中，然后某个线程调用了notify，唤醒了这个waiting线程，那这个线程就从waiting状态变成blocking状态，再被放入锁池中，重新去抢锁。</li>
</ul>
</li>
<li>锁竞争失败的线程和调用了wait方法的线程有什么本质区别吗？不都是在阻塞等待吗，为什么要放在锁池和等待池？<ul>
<li>锁池放的是竞争锁失败的线程，线程状态是blocking，他的目标是尽快去获得锁去执行任务，这是<strong>锁的互斥问题</strong>；等待池是主动放弃锁的进程，现在还暂时不想要锁，这个线程等待被其他线程唤醒后，他们的状态是waiting，是想等待其他资源到位了，然后再被notify唤醒，然后进入锁池中进行抢锁，这是<strong>锁通信问题</strong>。</li>
</ul>
</li>
</ul>
<h3 id="CAS-（Compare-and-Swap）-体现乐观锁的思想"><a href="#CAS-（Compare-and-Swap）-体现乐观锁的思想" class="headerlink" title="CAS （Compare and Swap） 体现乐观锁的思想"></a>CAS （Compare and Swap） 体现乐观锁的思想</h3><p><code>悲观锁</code></p>
<ul>
<li>定义：认为并发访问肯定会出问题，凡是共享资源都必须加锁，线程没获得锁前会被<strong>阻塞</strong>。<br>缺点：</li>
<li>性能差，线程频繁上下文切换；</li>
<li>在大量<strong>读操作或低冲突场景</strong>下显得臃肿；</li>
<li>synchronized、ReentrantLock 属于典型的悲观锁。<blockquote>
<p>Compare and Swap <strong>对比，交换</strong></p>
</blockquote>
</li>
</ul>
<p><code>乐观锁</code></p>
<ul>
<li>假设线程A&#x2F;B要访问一个资源，资源门口挂的门牌号是0（表空闲），A，B都想去访问，A先看到了门牌号的值是0，A拿到了CPU的时间片，对比了一下门牌号上还是0，等于old value，就将其改为1。对比门牌号上的值是否和自己第一次看到的值相同。这时B来到了门牌号前，发现自己的值是0但门牌号已经是1了，说明已经有线程去访问了资源，这时候有两个选择。1.可以自旋等待（while true），不断用CAS修改，直到线程B耐心耗尽。</li>
<li>概念：乐观锁就是当线程访问共享资源的时候，总是乐观的认为没有线程和它竞争，所以不会加锁，只是比较状态值是否和他的预期值相同，相等说明没有被其他线程修改，然后修改状态值并访问共享资源。</li>
<li>原子性：这是两步操作，如何确保呢？ 软件层面上无法实现，必须要硬件。</li>
<li>效率：因为没有使用<code>synchronized</code>，所以不会引发阻塞，效率提升的原因。CAS+volatile实现<code>无锁并发</code></li>
<li>真的无锁吗？<ul>
<li>在 用户代码层面，CAS 不使用 synchronized 或 ReentrantLock 这类显式锁。</li>
<li>它通过 CPU 提供的原子指令（如 x86 架构中的 CMPXCHG 指令）实现对内存的原子读-改-写。</li>
<li>不会让线程进入阻塞状态（不会挂起、不会上下文切换）。</li>
<li>底层会锁总线防止其他CPU核心访问。</li>
<li>在硬件层面，CAS 其实会短暂锁住某些资源，只不过它是极快的、非阻塞的，不像软件锁那样代价高。</li>
</ul>
</li>
<li>volatile 是 Java 中的一个<code>关键字</code>，用于修饰变量，主要用于多线程编程中的<code>可见性问题</code>。它的作用可以总结为：<ul>
<li>保证内存可见性：当一个线程修改了某个 volatile 变量的值，<strong>其他线程能立刻看到这个变化</strong>。</li>
<li>禁止指令重排序（部分场景）：在 volatile 写操作前的代码不会被编译器或 CPU 移动到写操作之后。<br>所以CAS保证<strong>原子性</strong>，volatile保证<strong>可见性</strong><br>数据库也可以使用CAS的思想</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 库存 <span class="operator">=</span> 新值 <span class="keyword">where</span> 库存 <span class="operator">=</span> 旧值</span><br></pre></td></tr></table></figure>
<ul>
<li>ABA问题<ul>
<li>假设变量 x 原本是 A</li>
<li>线程 T1 读取 A，要改成 B</li>
<li>在这之间，T2 把 A 改成了 C 又改回 A</li>
<li>T1 执行 CAS：发现 x 还是 A，就以为没变，结果错误更新<blockquote>
<p>Java 解决办法：加版本号（如 AtomicStampedReference）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="请你说说：JVM-的内存结构包括哪些区域？每个区域的作用分别是什么？你在项目中遇到过哪些内存相关的问题？"><a href="#请你说说：JVM-的内存结构包括哪些区域？每个区域的作用分别是什么？你在项目中遇到过哪些内存相关的问题？" class="headerlink" title="请你说说：JVM 的内存结构包括哪些区域？每个区域的作用分别是什么？你在项目中遇到过哪些内存相关的问题？"></a>请你说说：JVM 的内存结构包括哪些区域？每个区域的作用分别是什么？你在项目中遇到过哪些内存相关的问题？</h3><ul>
<li>JVM包括以下几个区域<ul>
<li>程序计数器PC：每个线程独有一个</li>
<li>Java虚拟机栈：存储方法时调用的局部变量，方法调用信息，调用完成后就出栈</li>
<li>本地方法栈：为 JVM 执行 native 方法准备的栈空间。</li>
<li>堆：所有对象和数组的存储区，是 <code>GC</code> 的主要管理区域；</li>
<li>方法区：存储类的结构信息、常量池、静态变量等；方法区属于共享区域，不同线程共享。</li>
</ul>
</li>
</ul>
<h3 id="JVM-中有哪些类型的垃圾回收（GC）？Minor-GC-和-Full-GC-有什么区别？你有没有在项目中遇到过频繁-GC-或性能问题的情况？是怎么排查和优化的？"><a href="#JVM-中有哪些类型的垃圾回收（GC）？Minor-GC-和-Full-GC-有什么区别？你有没有在项目中遇到过频繁-GC-或性能问题的情况？是怎么排查和优化的？" class="headerlink" title="JVM 中有哪些类型的垃圾回收（GC）？Minor GC 和 Full GC 有什么区别？你有没有在项目中遇到过频繁 GC 或性能问题的情况？是怎么排查和优化的？"></a>JVM 中有哪些类型的垃圾回收（GC）？Minor GC 和 Full GC 有什么区别？你有没有在项目中遇到过频繁 GC 或性能问题的情况？是怎么排查和优化的？</h3><p>JVM中有两种GC：Minor GC和Full GC</p>
<ol>
<li>Minor GC：<ul>
<li>只针对新生代（伊甸区和survivor区）进行回收</li>
<li>频率高，速度快，通常是伊甸区满了进行</li>
<li>回收后存活的对象进入老年代</li>
</ul>
</li>
<li>Full GC：<ul>
<li>回收范围是整个堆内存：包括新生代和老年代；</li>
<li>代价大，耗时长，可能会触发STW（Stop the world）暂停所有线程</li>
<li>通常是老年代满，方法区满</li>
</ul>
</li>
</ol>
<h3 id="JVM中的双亲委派机制是什么？"><a href="#JVM中的双亲委派机制是什么？" class="headerlink" title="JVM中的双亲委派机制是什么？"></a>JVM中的双亲委派机制是什么？</h3><ul>
<li>双亲委派机制是JVM类加载器中的一种工作模式，它规定：类加载器在加载类的时候，会先把请求委托给父类加载器去尝试加载，只有当父类加载失败时，子类加载器才会自己加载。这样是为了避免类的重复加载。</li>
<li>就比如我自己假装定义一个String类，然后类加载器发现系统已经加载了“正版”的String类，就会直接使用，不会自定义加载我的盗版类。</li>
</ul>
<h3 id="讲一下java类加载的过程"><a href="#讲一下java类加载的过程" class="headerlink" title="讲一下java类加载的过程"></a>讲一下java类加载的过程</h3><ol>
<li>加载（Loading）</li>
</ol>
<ul>
<li><strong>找到对应的<code>.class</code>文件并加载进内存</strong>，生成一个Class对象</li>
</ul>
<ol start="2">
<li>连接（Linking）<ol>
<li>验证（Verify）：校验字节码是否合法（防止破坏jvm安全）</li>
<li>准备（Prepare）：为静态变量分配内存，并赋初值</li>
<li>解析（Resolve）：把常量池中的<code>符号引用</code> 解析为 <code>直接引用</code>（内存地址）</li>
</ol>
</li>
<li>初始化（Initialization）</li>
</ol>
<ul>
<li>执行类的静态变量赋值和静态代码块，只有这一步会执行Java代码，是类加载的最后一步</li>
</ul>
<h3 id="讲一下抽象类和接口的区别"><a href="#讲一下抽象类和接口的区别" class="headerlink" title="讲一下抽象类和接口的区别"></a>讲一下抽象类和接口的区别</h3><ul>
<li><p>实例化：普通类可以直接实例化对象，而抽象类不能被实例化，只能被继承</p>
</li>
<li><p>继承：一个类可以继承一个普通类，而且可以继承多个接口；而一个类只能继承一个抽象类，但可以同时实现多个接口。</p>
</li>
<li><p>抽象类一般被用作基类，被其他类继承和扩展使用。</p>
</li>
<li><p>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法、具体方法，适用于有明显继承关系的场景</p>
</li>
<li><p>接口用于定义行为规范，可以多实现，适用于定义类的能力</p>
</li>
</ul>
<h3 id="GC调优有用过吗？"><a href="#GC调优有用过吗？" class="headerlink" title="GC调优有用过吗？"></a>GC调优有用过吗？</h3><h3 id="JMM内存模型讲讲？"><a href="#JMM内存模型讲讲？" class="headerlink" title="JMM内存模型讲讲？"></a>JMM内存模型讲讲？</h3><ul>
<li>JMM定义了线程之间的可见性、原子性、有序性的规则<ul>
<li>可见性：volatile</li>
<li>原子性：automatic</li>
<li>有序性</li>
</ul>
</li>
</ul>
<h2 id="打基础"><a href="#打基础" class="headerlink" title="打基础"></a>打基础</h2><ul>
<li>this关键字的作用<ul>
<li>变量有两种，<code>成员变量</code>、<code>局部变量</code>，成员变量的值是private int name，局部变量是在方法里定义的，如果想要传参，就需要this.name &#x3D; name；这样就能让成员变量成功赋值。</li>
<li>区分局部变量和成员变量</li>
</ul>
</li>
<li>javaBean是什么<ul>
<li>javaBean翻译过来其实就是不带Main方法的类对象</li>
<li>说白了就是带get和set以及构造函数的类</li>
</ul>
</li>
<li>static关键字<ul>
<li>静态区里的变量是所有对象共享的，只有一份</li>
<li>如果是需要<code>共享的变量</code>，就需要static来修饰</li>
</ul>
</li>
<li>抽象类和接口的区别<ul>
<li>抽象类更多是把一类共性的事物抽取出来； 动物类就是抽象类；</li>
<li>接口是一种规则，是对行为的抽象。更侧重于行为，一个对象特有的功能。 狗类的游泳就是接口；</li>
<li>创建了接口或者抽象类后，都需要在具体实现的子类里重写方法。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>javaLearn</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>juc</title>
    <url>/2025/05/28/juc/</url>
    <content><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><h3 id="1-进程与线程-1"><a href="#1-进程与线程-1" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><ol>
<li>进程</li>
</ol>
<ul>
<li>程序由指令和数据组成，指令需要运行，数据需要读写，就要将指令加载到cpu上，数据加载至内存。在指令运行过程中还需要使用磁盘，网络等设备。 进程就是用来加载指令、管理内存、管理I&#x2F;O的。</li>
<li>当一个程序被运行，指令代码被加载至内存，这时就开启了一个进程。</li>
<li>进程可以视为程序的一个实例。有些可以多开（记事本），有些只能开一个（网易云）</li>
</ul>
<ol start="2">
<li>线程</li>
</ol>
<ul>
<li>一个进程之内可以有多个线程</li>
<li>一个线程就是一个指令流，是 CPU 调度的基本单位，线程按照一定顺序执行代码，多个线程可以并发地被 CPU 核心调度执行。</li>
<li>java中，线程作为最小调度单位，进程作为资源分配最小单位。</li>
</ul>
<hr>
<p>两者对比</p>
<ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂<ul>
<li>同一台计算机的进程通信称为IPC(Inter-process communication) 常见的 IPC 方式包括管道（pipe）、共享内存、消息队列、socket 等。</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h3 id="3-并行与并发"><a href="#3-并行与并发" class="headerlink" title="3.并行与并发"></a>3.并行与并发</h3><ul>
<li>并发(concurrency)：同一时间应对(dealing with)多件事情</li>
<li>并行(parallel)：同一时间动手做(doing)多件事情的能力</li>
</ul>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>同步&amp;&amp;异步调用<br>从方法调用的角度来说，如果</p>
<blockquote>
<p>类比：去奶茶店点单后站在原地等，做好了再走。 同步（调用一个方法，要等它执行完，拿到结果才能继续。）<br>类比：下单后坐下玩手机，等叫号取奶茶。 异步（调用一个方法后，不用等它完成，可以继续做别的事，结果准备好后再通知你。）</p>
</blockquote>
<h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h3><ul>
<li>单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使<br>用cpu，不至于一个线程总占用cpu，别的线程没法干活</li>
<li>多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞IO】和【异步IO】优化</li>
</ul>
<h2 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2.Java线程"></a>2.Java线程</h2><h3 id="1-创建和运行线程"><a href="#1-创建和运行线程" class="headerlink" title="1.创建和运行线程"></a>1.创建和运行线程</h3><p>创建线程有三个方法</p>
<ol>
<li>方法一，直接创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法二，使用runnable对象，使用lambda表达式简化，可以在方法二的基础上使用alt+enter让idea自己改</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">void</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;我是线程哈哈哈&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是进程哈哈哈&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用任务和线程分开的写法好一些。</p>
<h3 id="2-原理之线程运行"><a href="#2-原理之线程运行" class="headerlink" title="2.原理之线程运行"></a>2.原理之线程运行</h3><h4 id="1-运行原理"><a href="#1-运行原理" class="headerlink" title="1.运行原理"></a>1.运行原理</h4><p>每个线程启动后，虚拟机会为其分配一块栈内存</p>
<ul>
<li>每个栈由多个栈帧组成，对应着每次方法调用使用的内存。</li>
<li>每个线程只能有一个活动栈帧。</li>
</ul>
<h4 id="2-线程上下文切换（Thread-Context-Switch）"><a href="#2-线程上下文切换（Thread-Context-Switch）" class="headerlink" title="2.线程上下文切换（Thread Context Switch）"></a>2.线程上下文切换（Thread Context Switch）</h4><ul>
<li>原因：<ul>
<li>cpu时间用完</li>
<li>垃圾回收（gc）</li>
<li>有更高优先级的线程运行</li>
<li>线程自己调用了sleep,yield,wait,join,synchronized,lock等方法</li>
</ul>
</li>
<li>当ContextSwitch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是程序计数器(ProgramCounter Register)，它的作用是记住下一条jvm指令的执行地址，是线程私有的<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>ContextSwitch频繁发生会影响性能</li>
</ul>
</li>
</ul>
<h3 id="3-线程中的常见方法"><a href="#3-线程中的常见方法" class="headerlink" title="3.线程中的常见方法"></a>3.线程中的常见方法</h3><h4 id="run-VS-start"><a href="#run-VS-start" class="headerlink" title="run VS start"></a>run VS start</h4><ul>
<li>run()只是普通方法调用，不会并发</li>
<li><strong>start才是启动线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">System.out.println(t1.getState());</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(t1.getState());</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(t1.getState());</span><br></pre></td></tr></table></figure>
<p>记住，start只能调用一次，会让state变为runnable。</p>
<h4 id="sleep-VS-yield"><a href="#sleep-VS-yield" class="headerlink" title="sleep VS yield"></a>sleep VS yield</h4><ul>
<li>sleep<ol>
<li>调用sleep会让当前线程从Running进入Timed Waiting状态（阻塞）</li>
<li>其它线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行（不能够马上获得cpu，看线程的状态）</li>
<li>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</li>
</ol>
</li>
<li>yield（让出，谦让）<ol>
<li>调用yield会让当前线程从Running变为runnable就绪态，然后调度执行其他线程</li>
<li>具体的实现依赖于OS<br>应用：防止CPU占用100%<br>在没有利用cpu进行计算的时候，不要让while(true)空转浪费cpu，可以使用yield或sleep让出cpu的使用权</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用wait &#x2F; 条件变量达到类似效果</li>
<li>不同的是，后两种都需要加锁，并且需要相应的唤醒(notify &#x2F; notifyall)操作，一般适用于要同步的场景<ul>
<li>wait() 必须放在 <strong>synchronized</strong> 中；</li>
<li>被 wait() 的线程会<strong>释放锁并阻塞</strong>；</li>
<li>notify() 在同一个锁对象上唤醒一个线程，notifyAll() 唤醒所有等待线程。</li>
</ul>
</li>
<li>sleep适用于无需锁同步的场景</li>
</ul>
<h4 id="interrupt-isInterrupted-interrupted"><a href="#interrupt-isInterrupted-interrupted" class="headerlink" title="interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()"></a>interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()</h4><ul>
<li>thread.interrupt();<ul>
<li>并不会立刻杀死线程！</li>
<li>它只是设置线程的“中断标志位”为 true</li>
<li>如果线程正在 sleep、wait、join 等阻塞操作，会抛出 InterruptedException 异常</li>
</ul>
</li>
<li>Thread.currentThread().isInterrupted();<ul>
<li>返回当前线程的中断状态（true&#x2F;false）</li>
<li>不会清除这个标志位</li>
</ul>
</li>
<li>Thread.interrupted(); &#x2F;&#x2F; 检查当前线程是否中断，并清除标志位<blockquote>
<p>Thread.interrupted()：“我看一下我被打断没？顺便把这事忘了”<br>isInterrupted()：“我看你有没有被打断，我不动你状态”</p>
</blockquote>
</li>
</ul>
<h5 id="拓展：设计模式（两阶段终止）"><a href="#拓展：设计模式（两阶段终止）" class="headerlink" title="拓展：设计模式（两阶段终止）"></a>拓展：设计模式（两阶段终止）</h5><blockquote>
<p>有两个线程t1和t2，t2已经完成了，t1该如何帮t2料理后事？</p>
</blockquote>
<ul>
<li>不能使用暴力stop()，因为t2可能有一些上了锁的资源，当t2被杀死后就再也没有机会释放锁，导致其它线程无法获得锁。</li>
</ul>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程是为用户线程提供服务的线程。当所有用户线程都结束时，守护线程会被 JVM 自动终止，不会阻止程序退出。</p>
<h5 id="GC-是守护线程的例子"><a href="#GC-是守护线程的例子" class="headerlink" title="GC 是守护线程的例子"></a>GC 是守护线程的例子</h5><ul>
<li>JVM 启动时会创建 GC 守护线程</li>
<li>它在后台自动运行，清理不再使用的对象</li>
<li>主线程（用户线程）结束后，GC 守护线程也会随 JVM 退出而结束</li>
<li>守护线程适合执行日志、监控、GC 等后台任务</li>
</ul>
<h2 id="3-共享模型之管程-Monitor"><a href="#3-共享模型之管程-Monitor" class="headerlink" title="3.共享模型之管程(Monitor)"></a>3.共享模型之管程(Monitor)</h2><h3 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1.共享带来的问题"></a>1.共享带来的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">sout(cnt);</span><br></pre></td></tr></table></figure>
<p>不一定是0。<br>多个线程<strong>对共享资源进行读写操作</strong>，上下文交换引起的指令交错<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250528160715423.png"></p>
<ul>
<li>问题出现在多个线程访问<strong>共享资源</strong></li>
<li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为临界区</li>
<li>竞态条件（Race Condition）<ul>
<li>多个线程在临界区内执行，由于代码的执行顺序不同而导致结果无法预测，称之发生了<strong>静态条件</strong></li>
</ul>
</li>
</ul>
<h3 id="2-静态条件解决方案"><a href="#2-静态条件解决方案" class="headerlink" title="2.静态条件解决方案"></a>2.静态条件解决方案</h3><ul>
<li>阻塞式<ul>
<li>Synchronized、lock</li>
</ul>
</li>
<li>非阻塞式<ul>
<li>原子变量</li>
</ul>
</li>
</ul>
<h4 id="synchronized（对象锁）"><a href="#synchronized（对象锁）" class="headerlink" title="synchronized（对象锁）"></a>synchronized（对象锁）</h4><ol>
<li>语法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">    <span class="comment">//临界区代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类比说明"><a href="#类比说明" class="headerlink" title="类比说明"></a>类比说明</h5><ul>
<li>把 <code>obj</code> 想象成一个 <strong>房间</strong>，房间只有一个 <strong>门</strong>。</li>
<li>每个线程（如 <code>t1</code>、<code>t2</code>）就像是 <strong>想进房间干活的人</strong>。</li>
<li>一次只能一个线程进房间，其他线程必须在门外 <strong>排队等待</strong>。</li>
</ul>
<hr>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><ol>
<li><code>t1</code> 运行到 <code>synchronized(obj)</code><br>→ 拿到钥匙，进入房间（获得锁）<br>→ 门被锁上，其他线程进不来。</li>
<li><code>t2</code> 也运行到 <code>synchronized(obj)</code><br>→ 发现门被锁，<strong>阻塞在门外</strong>，等待钥匙。</li>
<li><code>t1</code> 时间片用完，被系统挂起<br>→ 虽然暂停了，但<strong>钥匙还在它手上</strong>（锁未释放）<br>→ <code>t2</code> 仍无法进入房间。</li>
<li><code>t1</code> 被重新调度回来<br>→ 执行完同步代码块，<strong>出门还钥匙</strong>（释放锁）<br>→ 唤醒 <code>t2</code>，<code>t2</code> 拿到钥匙进入房间继续执行。</li>
</ol>
<hr>
<h6 id="关键类比总结"><a href="#关键类比总结" class="headerlink" title="关键类比总结"></a>关键类比总结</h6><table>
<thead>
<tr>
<th>Java 概念</th>
<th>房间类比</th>
</tr>
</thead>
<tbody><tr>
<td>锁对象（如 obj）</td>
<td>房间</td>
</tr>
<tr>
<td>synchronized(obj)</td>
<td>进入房间前先锁门</td>
</tr>
<tr>
<td>获得锁</td>
<td>拿到钥匙，进入房间</td>
</tr>
<tr>
<td>阻塞线程</td>
<td>在门外排队等待钥匙</td>
</tr>
<tr>
<td>释放锁</td>
<td>出门还钥匙，唤醒别人</td>
</tr>
</tbody></table>
<h6 id="面向对象加锁"><a href="#面向对象加锁" class="headerlink" title="面向对象加锁"></a>面向对象加锁</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                r.Increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                r.Decrease();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        r.getCnt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increase</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Decrease</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCnt</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="在方法上加锁"><a href="#在方法上加锁" class="headerlink" title="在方法上加锁"></a>在方法上加锁</h6><ol>
<li>在实例上加锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在类上加锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>this 就像你家门 → 每家自己锁</li>
<li>Test.class 就像整栋楼大门 → 所有人公用<br>区别是静态方法（类对象） 非静态方法（当前实例）<br>synchronized锁的是当前实例，Test锁的是整个类<br>搜 <code>线程八锁</code>进行练习，主要分析锁住的是不是同一个对象，如果不是同一个对象，那就是并行，不存在多线程；是同一个对象，就是并发。<br>实例方法加锁锁 this，每个对象一把锁；<br>静态方法加锁锁 class，全类共用一把锁；<br>不同对象加锁不冲突，相同对象才竞争；<br>类锁和实例锁互不影响。</li>
</ul>
<h4 id="线程安全：局部变量-vs-静态变量"><a href="#线程安全：局部变量-vs-静态变量" class="headerlink" title="线程安全：局部变量 vs 静态变量"></a>线程安全：局部变量 vs 静态变量</h4><h5 id="局部变量是线程安全的"><a href="#局部变量是线程安全的" class="headerlink" title="局部变量是线程安全的"></a>局部变量是线程安全的</h5><ul>
<li>每次方法调用会创建新的栈帧</li>
<li>局部变量存放在线程独立的栈中，不共享，不冲突</li>
</ul>
<h5 id="静态变量是线程不安全的"><a href="#静态变量是线程不安全的" class="headerlink" title="静态变量是线程不安全的"></a>静态变量是线程不安全的</h5><ul>
<li>静态变量属于类，全局共享</li>
<li>多线程访问会产生数据竞争，必须加锁保护</li>
</ul>
<hr>
<h5 id="习题：银行账户转账"><a href="#习题：银行账户转账" class="headerlink" title="习题：银行账户转账"></a>习题：银行账户转账</h5><p>两个账户 <code>a</code> 和 <code>b</code>，线程 T1 从 a 转账到 b，T2 从 b 转账到 a<br>如果两个账户是不同对象，用 <code>synchronized(this)</code> 是不安全的，因为<strong>锁的是两个不同的对象</strong>！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">        target.balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Monitor底层原理-（这里去看jvm的jmm）"><a href="#Monitor底层原理-（这里去看jvm的jmm）" class="headerlink" title="Monitor底层原理 （这里去看jvm的jmm）"></a>Monitor底层原理 （这里去看jvm的jmm）</h3><p>Monitor被翻译为<strong>监视器或管程</strong>，可以理解为提到的<strong>锁</strong></p>
<ul>
<li>第一个线程获得对象的锁后，成为owner</li>
<li>后续来的线程发现owner被占用，只能进入等待队列并切换状态为阻塞</li>
<li>当临界区代码被执行完后，owner空出，通知Monitor唤醒阻塞队列的线程，（此时的阻塞队列竞争是非公平的，不一定是先进来的就先得到锁）</li>
<li>对象总是与一个monitor相关联的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529100222307.png"></li>
</ul>
<h3 id="notify-和wait"><a href="#notify-和wait" class="headerlink" title="notify()和wait()"></a>notify()和wait()</h3><p>在重量级锁的环境下，一个线程如果缺乏资源，就会调用wait方法<strong>主动放弃锁</strong>，进入等待池，自己的状态设置为waiting；等到别的线程将资源送来了，就会调用notify，告诉这个线程资源来了，这时候第一个线程就会离开等待池，状态变为blocking，进入锁池(EntryList)重新去竞争锁。</p>
<h3 id="park-和unpark"><a href="#park-和unpark" class="headerlink" title="park()和unpark()"></a>park()和unpark()</h3><p><code>park()</code> 和 <code>unpark()</code> 是 Java 中底层线程阻塞&#x2F;唤醒的原语，属于 <code>LockSupport</code> 类提供的工具，用于实现更灵活的并发控制（比 <code>wait/notify</code>、<code>sleep/yield</code> 更底层、更强大）。</p>
<h3 id="锁的活跃性"><a href="#锁的活跃性" class="headerlink" title="锁的活跃性"></a>锁的活跃性</h3><ul>
<li>死锁：各自持一把锁，又都想获得对方的锁，哲学家问题<br>  <strong>产生死锁的条件</strong><ul>
<li>互斥</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待 ✅ （最常通过避免循环等待解决）<br>  <strong>解决策略</strong></li>
<li>固定加锁顺序：如先锁 A 再锁 B，所有线程统一顺序，避免循环等待。</li>
<li>使用 tryLock()：尝试加锁，失败就放弃，避免永久等待。</li>
<li>死锁检测与恢复：定期检测资源等待图，发现死锁强制中断线程（一般用于数据库&#x2F;操作系统）。</li>
</ul>
</li>
<li>饥饿：线程<strong>优先级不公平</strong>、<strong>锁分配不均</strong><br>  解决策略<ul>
<li>使用 公平锁：如 <code>ReentrantLock(true)</code>，按请求顺序分配锁；</li>
<li>避免线程优先级过高差距；</li>
<li>控制资源分配策略，避免让某些线程长期得不到调度。</li>
</ul>
</li>
<li>活锁：</li>
</ul>
<h4 id="ReentrantLock-可重入锁，公平锁"><a href="#ReentrantLock-可重入锁，公平锁" class="headerlink" title="ReentrantLock(可重入锁，公平锁)"></a>ReentrantLock(可重入锁，公平锁)</h4><ol>
<li>优点</li>
</ol>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁</li>
<li>支持多个条件变量（所有条件满足了才从waitSet出来去锁池）<blockquote>
<p>与synchronized一样支持<strong>可重入</strong></p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>可重入</li>
</ol>
<ul>
<li>“ReentrantLock 可重入指的是一个线程可以多次加锁而不阻塞自己，内部通过记录持有线程和重入计数来实现，类似 synchronized 的行为。”</li>
</ul>
<ol start="3">
<li>语法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 非公平锁（默认）</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">unfairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>条件变量</li>
</ol>
<ul>
<li>用于线程间通信，代替 wait() 和 notify()；</li>
<li>支持多个等待队列（更细粒度的控制）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ReentrantLock + Condition：可以为不同条件建多个等待队列（每个condition内部有一个独立的等待队列）</p>
<ol start="5">
<li>锁超时</li>
<li>总结</li>
</ol>
</blockquote>
<ul>
<li>ReentrantLock 是显式锁，功能强于 synchronized；</li>
<li>支持更细粒度的锁策略；</li>
<li>搭配 Condition 可实现更复杂的线程通信模型；</li>
<li><strong>需手动释放锁，推荐 try-finally 结构</strong>。</li>
</ul>
<h2 id="4-共享模型之不可变"><a href="#4-共享模型之不可变" class="headerlink" title="4.共享模型之不可变"></a>4.共享模型之不可变</h2><ol>
<li>什么是Java中的不可变类</li>
</ol>
<ul>
<li>不可变类是指无法修改对象的值（<strong>无法继承、线程安全</strong>），String不可变<ul>
<li>追问：怎么实现不可变类？<ul>
<li>通过看String的源码，String添加了final(类似于cpp的const)关键字，并且是private对象</li>
<li>替换方法replace()的实现是返回一个新的字符串。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-并发工具"><a href="#5-并发工具" class="headerlink" title="5.并发工具"></a>5.并发工具</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-ThreadPoolExcutor"><a href="#1-ThreadPoolExcutor" class="headerlink" title="1.ThreadPoolExcutor"></a>1.ThreadPoolExcutor</h4><ol>
<li>线程池状态<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529164801644.png" alt="线程池状态"></li>
</ol>
<ul>
<li>五状态：Running、Shutdown、Stop、Tidying、Terminated<br>Shutdown就像终结对方的连胜，但不代表这局游戏结束咯。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529165203047.png"><br>数字比较，是有符号数，最高位为-4，也可以去看ThreadPoolExecutor的源码</li>
</ul>
<ol start="2">
<li>线程池构造方法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529165901446.png" alt="线程池构造方法"></li>
</ol>
<ul>
<li>corePoolSize核心线程数目：<strong>线程池中常驻的线程数。</strong></li>
<li>maximumPoolSize最大线程数目：线程池中允许创建的最大线程数。</li>
<li>keepAliveTime线程存活时间：非核心线程空闲多久被回收。</li>
<li>unit时间单位-针对救急线程</li>
<li>workQueue阻塞队列：<strong>用于缓存待执行任务的阻塞队列</strong>，如 LinkedBlockingQueue。</li>
<li>threadFactory线程工厂-可以为线程创建时起个好名字</li>
<li>handler拒绝策略：线程池满时的拒绝策略<blockquote>
<p>最大线程数 &#x3D; 核心线程数 + 救急线程数</p>
</blockquote>
</li>
<li>核心线程和救急线程的区别？<ul>
<li>核心线程在任务执行完成后仍留在线程池中，救急线程执行完后会离开线程池。（外包）</li>
</ul>
</li>
<li>如果系统面临高并发，你会怎样去配置线程池？<ul>
<li>如果任务是<strong>CPU密集型</strong>（如计算型服务），线程数设为<code>CPU核心数+1</code>，使用无界队列，避免上下文切换；因为计算型服务几乎不进行IO操作，CPU使用频率很高，增加过多线程反而会导致频繁进行上下文切换，反而拖延性能，多加一个线程是为了应对线程调度或偶尔阻塞的情况。</li>
<li>如果任务是<strong>IO密集型</strong>（如网络请求，数据库读写），可设置更多线程，如 <code>2 * CPU核心数</code>，配合适当长度的阻塞队列；因为IO密集型任务经常阻塞，线程会空闲，多设置一些线程来保证CPU有任务执行，线程看起来很多，但由于很多都处于阻塞，所以不会频繁进行上下文切换。<blockquote>
<p>所以本质上，线程池线程数的设置要根据任务的“阻塞程度”和“CPU占用率”做平衡。</p>
</blockquote>
</li>
<li>拒绝策略方面，如果系统不能丢任务，可使用 CallerRunsPolicy 让主线程帮忙执行，降低系统负载；</li>
<li>队列类型上，对于高并发请求建议使用 LinkedBlockingQueue 或 ArrayBlockingQueue 来控制流量和内存使用。</li>
</ul>
</li>
<li>线程池的执行策略<ol>
<li>如果任务数小于核心线程数，分配一个线程去处理任务</li>
<li>如果任务数大于核心线程数，进入阻塞队列等待</li>
<li>如果任务数大于核心线程数并且阻塞队列已满，创建救急线程去处理任务</li>
<li>如果救急线程数+核心线程数大于最大线程数，执行拒绝策略</li>
</ol>
</li>
</ul>
<h4 id="2-Fork-Join"><a href="#2-Fork-Join" class="headerlink" title="2.Fork&#x2F;Join"></a>2.Fork&#x2F;Join</h4><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1.AQS"></a>1.AQS</h4><p>全称是：AbstractQueuedSynchronized，是<strong>阻塞式锁</strong>和相关的同步器工具的框架<br><strong>AQS 就是一套模板机制，你通过实现它的几个抽象方法，就可以“自定义一把锁”或“同步器”</strong></p>
<ul>
<li>特点：<ul>
<li>用<code>state</code>属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获得锁和释放锁<ul>
<li>getState：获取state状态</li>
<li>setState：设置state状态</li>
<li>compareAndSetState：乐观锁机制设置state状态</li>
<li>独占模式只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>基于FIFO的等待队列，类似于monitor的Entrylist</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor 的 WaitSet</li>
</ul>
</li>
<li>子类要实现下列方法<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
</li>
<li>并发工具类：是一个能让多个线程安全的去访问共享资源的一个工具，每个线程访问的时候要去<strong>判断</strong>当前共享资源是否被占用，是否正在被访问；如果没有线程访问，那当前线程就可以访问；如果当前资源被访问了，要么<strong>重试</strong>，要么<strong>阻塞</strong>，要么<strong>放弃</strong>。</li>
<li>如何表示共享资源当前正在被访问呢？<ul>
<li>状态变量。为0时表示空闲，为1时表示被占有，同样是Reentrantlock的思想</li>
<li>公平策略：AQS是基于FIFO的队列设计的，只需要重写tryAcquire方法就可以自定义公平&#x2F;非公平策略了</li>
</ul>
</li>
<li>Reentrantlock和Synchronized有什么区别？<ul>
<li>Reentrantlock基于FIFO实现了公平锁和非公平锁；而Synchronized都是非公平</li>
</ul>
</li>
</ul>
<h4 id="2-Reentrantlock"><a href="#2-Reentrantlock" class="headerlink" title="2.Reentrantlock"></a>2.Reentrantlock</h4><ul>
<li>类型：独占、可重入、支持公平&#x2F;非公平</li>
<li>关键 AQS 方法：tryAcquire() &#x2F; tryRelease()</li>
<li>state 表示：当前线程持有锁的次数（支持递归加锁）</li>
<li>典型用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3.Semaphore"></a>3.Semaphore</h4><ul>
<li>类型：共享锁</li>
<li>关键 AQS 方法：tryAcquireShared() &#x2F; tryReleaseShared()</li>
<li>state 表示：剩余可用许可数量</li>
<li>典型用法：限流、连接池并发控制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">semaphore.acquire();   <span class="comment">// 获取许可</span></span><br><span class="line">semaphore.release();   <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure>

<h4 id="4-CountDownLatch-（倒计时锁）"><a href="#4-CountDownLatch-（倒计时锁）" class="headerlink" title="4.CountDownLatch （倒计时锁）"></a>4.CountDownLatch （倒计时锁）</h4><ul>
<li>类型：共享同步器（不可重置）</li>
<li>关键 AQS 方法：tryAcquireShared()（为 0 才通过） &#x2F; tryReleaseShared()</li>
<li>state 表示：倒计时数量</li>
<li>典型用法：等待多个线程完成后再执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">latch.countDown(); <span class="comment">// 调用 3 次后 latch.await() 才能继续，countDown计数--</span></span><br><span class="line">latch.await(); <span class="comment">//等待计数归零</span></span><br></pre></td></tr></table></figure>

<h4 id="5-ReentrantReadWriteLock"><a href="#5-ReentrantReadWriteLock" class="headerlink" title="5.ReentrantReadWriteLock"></a>5.ReentrantReadWriteLock</h4><ul>
<li>类型：读锁共享，写锁独占</li>
<li>关键点：<ul>
<li>写锁使用 tryAcquire()，互斥；</li>
<li>读锁使用 tryAcquireShared()，可多个同时获取；</li>
</ul>
</li>
<li>state 表示：高 16 位写锁计数，低 16 位读锁计数（位运算拆解）</li>
<li>典型用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readLock.lock();   <span class="comment">// 多线程可以同时读</span></span><br><span class="line">writeLock.lock();  <span class="comment">// 写操作互斥，读写互斥</span></span><br></pre></td></tr></table></figure>

<h4 id="6-FutureTask"><a href="#6-FutureTask" class="headerlink" title="6.FutureTask"></a>6.FutureTask</h4><ul>
<li>类型：任务状态控制器（封装线程执行结果）</li>
<li>关键 AQS 方法：用独占锁管理任务执行与等待线程；</li>
<li>state 表示：任务状态（NEW、RUNNING、COMPLETED）</li>
<li>典型用法：配合线程池异步获取结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">task.get(); <span class="comment">// 等待并获取结果</span></span><br></pre></td></tr></table></figure>

<h1 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h1><h2 id="那请你说说：synchronized-和-ReentrantLock-有什么区别？你在什么场景下会选择用-ReentrantLock-而不是-synchronized？"><a href="#那请你说说：synchronized-和-ReentrantLock-有什么区别？你在什么场景下会选择用-ReentrantLock-而不是-synchronized？" class="headerlink" title="那请你说说：synchronized 和 ReentrantLock 有什么区别？你在什么场景下会选择用 ReentrantLock 而不是 synchronized？"></a>那请你说说：synchronized 和 ReentrantLock 有什么区别？你在什么场景下会选择用 ReentrantLock 而不是 synchronized？</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250610132655010.png"><br>从语法层面上说，synchronized是关键字，而Reentrantlock是concurrent包里提供的，reentrantlock可以中断，不会傻等，也支持trylock()尝试加锁，也可以设置公平&#x2F;非公平锁，可以配合<strong>条件变量</strong>进行使用，需要手动lock和unlock。</p>
<ul>
<li>如果只是简单的同步代码块或方法，用 synchronized 更方便；</li>
<li>如果需要 <code>中断等待、限时尝试加锁、公平策略或多个条件等待队列</code>，就必须用 ReentrantLock，它更灵活、可控。</li>
<li>比如我做订单超卖防止时，需要加锁保护共享资源。我如果只是简单保证线程安全，会直接用 synchronized；但如果我要限制等待时间，或者希望后来的线程也有公平机会执行，就会选择 ReentrantLock 并配合 tryLock() 或 lockInterruptibly() 实现更复杂的并发控制逻辑。</li>
<li>ReentrantLock.lockInterruptibly() 允许在等待锁的过程中被中断，是<strong>处理超时等待、线程池任务超时取消、避免死锁</strong>等高级并发场景非常实用的手段。而 synchronized 不支持中断，一旦等待只能卡住。</li>
</ul>
<h2 id="什么是ABA问题？如何解决？"><a href="#什么是ABA问题？如何解决？" class="headerlink" title="什么是ABA问题？如何解决？"></a>什么是ABA问题？如何解决？</h2><ul>
<li>ABA 问题指的是：一个变量原本是 A，线程1 读取后准备操作；但此时线程2 把它改成了 B，然后又改回 A。当线程1 继续用 CAS 比较时，会误以为这个变量从未被修改，其实已经发生过变化，导致潜在的并发安全问题。</li>
<li>解决方法：加版本号；它在变量的基础上加一个版本号，每次修改时版本号递增，CAS 时比较的不只是值，还有版本；</li>
</ul>
<h2 id="Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？"><a href="#Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？" class="headerlink" title="Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？"></a>Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？</h2><ul>
<li>Java中的线程池是通过ThreadPoolExcutor实现的，当调用.execute(task)的时候，线程池会按以下步骤执行<ol>
<li>线程核心未满？-&gt;分配一个核心线程执行任务</li>
<li>核心线程满了，队列没满？-&gt;放进任务队列<code>workQueue</code>等待执行</li>
<li>队列也满了，但是最大线程数还没满？-&gt;创建一个<strong>救急线程</strong>来执行</li>
<li>连最大线程数也满了？-&gt;执行拒绝策略，抛出异常</li>
</ol>
</li>
</ul>
<h2 id="I-O多路复用是什么？"><a href="#I-O多路复用是什么？" class="headerlink" title="I&#x2F;O多路复用是什么？"></a>I&#x2F;O多路复用是什么？</h2><ul>
<li>I&#x2F;O 多路复用是指：通过一个线程同时监听多个 <strong>I&#x2F;O 事件（比如 socket 连接、读写等）</strong>，一旦有事件发生就去处理，<strong>避免为每个连接开一个线程，大大提高了并发性能和资源利用率。</strong></li>
</ul>
<h1 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h1><ul>
<li>不使用Executor创建<ol>
<li>FixedThreadPool和SingleThreadPool允许的阻塞队列长度为<code>Integer.MAX_VALUE</code>，会导致OOM</li>
<li>CachedThreadPool允许创建的线程数量为<code>Integer.MAX_VALUE</code>，也会导致OOM</li>
</ol>
</li>
<li>四种拒绝策略<ul>
<li>AbortPolicy：如果任务数超过了阻塞队列，直接拒绝执行</li>
<li>CallerRunsPolicy：由提交线程池任务的线程来运行</li>
<li>DiscardPolicy：直接丢弃新来的任务</li>
<li>DiscardOldestPolicy：丢弃队列里最老的任务，尝试执行当前任务</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>OS八股</title>
    <url>/2025/06/01/OS%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><ol>
<li>系统调用&#x2F;用户态和内核态</li>
</ol>
<ul>
<li>用户态：用户态可以直接读取用户程序的数据。</li>
<li>内核态：内核态运行的程序几乎可以访问计算机的任何资源，不受限制。<blockquote>
<p>用户态<strong>无法直接访问硬件资源</strong>，而内核态可以；系统通过硬件保护机制防止用户态程序直接访问关键资源，确保系统稳定和安全。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>什么是系统调用？</li>
</ol>
<ul>
<li>日常情况下我们的程序基本运行在用户态，当遇到与<strong>内核态</strong>级别有关的资源调用时，就需要进行<strong>系统调用</strong>，大致分为五类<ul>
<li>设备管理：完成设备的请求或释放，以及设备的启动等。</li>
<li>文件管理：完成文件的<code>增删改查</code>。</li>
<li>进程管理：完成进程的<code>创建、撤销、阻塞及唤醒</code>等功能。</li>
<li>进程通信：完成进程间的消息传递或信号传递。</li>
<li>内存管理：完成内存的分配、回收以及获取作业占用内存的大小及地址等功能。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>什么情况下发生系统调用？<ol>
<li>主动系统调用<ul>
<li>用户态<strong>主动请求</strong>切换到内核态，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如read操作，比如fork()操作。系统调用的核心是OS为用户开了一个特别的中断来实现。</li>
</ul>
</li>
<li>异常<ul>
<li>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li>
</ul>
</li>
<li>外围设备的中断<ul>
<li>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。如网卡接收到数据包、定时器中断等也会导致从用户态切入内核态，执行中断服务程序。<blockquote>
<p>用户态程序无法直接访问硬件资源，为了在受限的权限下完成磁盘读写、网络通信、进程创建等操作，用户程序需要通过系统调用请求内核代为执行。以 Linux 为例，系统调用通过特殊的 syscall 指令触发软中断（软中断是调用方法，硬中断不可控，比如    IO完成通知、定时器、外设输入），由操作系统内核中的中断处理程序接管执行，完成如 <code>read(), fork()</code> 等功能后再返回用户态。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>其他必会知识<ol>
<li>并行与并发<ul>
<li>并行(Parallelism)：多个任务在同一时刻被<code>多个处理器</code>或<code>多个核心</code>同时执行，是物理上的同时发生，常用于计算密集型任务。</li>
<li>并发(concurrency)：在一个时间段内多个任务被启动，并由<code>单个处理器交替执行</code>，依<code>靠任务调度</code>机制实现“看似同时”进行，适用于IO密集型任务或资源共享的场景。<blockquote>
<p>并发更侧重于任务间的切换与调度控制，可在单核或多核系统中实现；而并行依赖于多核资源，更强调同时执行多个任务的能力。<br> &#x2F;&#x2F;todo()<br>在Java中，<code>synchronized</code> 和 <code>ReentrantLock</code> 是并发控制工具；他们用来控制<strong>多个线程并发访问共享资源的行为，防止出现竞态</strong>，知识扩展到锁。<br><code>ForkJoinPool</code> 和 <code>parallelStream()</code> 是实现并行计算的常用工具</p>
</blockquote>
</li>
</ul>
</li>
<li>同步和异步</li>
</ol>
<ul>
<li>同步（Synchronous）是指调用方发出请求后必须等待任务执行完成并返回结果才能继续执行下一步，期间调用线程会被阻塞。</li>
<li>异步（Asynchronous）是指调用方发出请求后不等待结果立即返回，任务通常由其他线程或事件回调处理，调用线程可继续执行后续逻辑，不被阻塞。<blockquote>
<p>异步编程：<code>线程池</code></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><ol>
<li>线程，进程，协程的区别<ul>
<li>进程是操作系统分配资源的基本单位，每个进程有独立的地址空间、文件描述符等资源。</li>
<li>线程是CPU调度的基本单位，是进程内的执行流，多个线程共享进程资源但独立调度。</li>
<li>协程是用户态轻量级线程，由程序自身控制切换，不需要内核参与，调度成本低，适合高并发IO场景。</li>
</ul>
</li>
<li>进程vs线程<ul>
<li>资源管理：进程拥有独立的资源，线程共享所属进程的资源</li>
<li>调度机制：线程是调度单位，切换成本低；线程切换仅需保存少量寄存器，不涉及页表&#x2F;地址空间切换；而进程切换需要保存和恢复全部上下文，包括内存映射，开销更大。</li>
<li>系统开销：进程创建&#x2F;销毁需要分配内存、句柄等系统资源，线程的系统开销更小。</li>
<li>通信机制：线程可以直接共享内存通信；进程需要使用IPC机制，如管道，socket，或共享内存。</li>
</ul>
</li>
<li>PCB是什么？（Process Control Block）<ul>
<li>PCB主要包含以下几部分内容：<ul>
<li>进程的描述信息，比如进程的名称，标识符。</li>
<li>处理机的状态信息。当程序中断时保留此时的信息，以便CPU返回时能从断点处执行。</li>
<li>进程调度信息，比如阻塞原因，状态，优先级等。</li>
<li>进程控制和资源占有，同步通信机制，链接指针。</li>
</ul>
</li>
<li>PCB的作用？<ul>
<li>PCB是进程实体中的一部分，是操作系统中最重要的数据结构</li>
<li>由于它的存在，可以使程序并发运行。</li>
<li>系统通过PCB来感知进程的存在。</li>
<li>进程的组成可以用这张图来表示，换句话说，PCB是程序的唯一标识符。<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250601122001745.png"></li>
</ul>
</li>
</ul>
</li>
<li>进程的五种状态<ul>
<li>创建、就绪、运行、阻塞、结束</li>
<li>就绪和运行可以互相转化，当进程为就绪态时，若CPU为其分配时间篇，即可运行，状态变为运行。</li>
<li>运行状态结束后又变回就绪态。</li>
<li>阻塞状态是进程在运行状态中，需要等待某个资源，比如打印机资源，从而挂起的状态，等资源拿到后会回到就绪态，等待CPU时间片。<br> <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250419221319250.png"></li>
</ul>
</li>
<li>进程调度算法<ul>
<li>先来先服务(FCFS)、短作业优先(SJF)、最短剩余时间有限(SRTN)、时间片轮转、优先级调度、多级反馈队列</li>
</ul>
</li>
<li>进程同步的方式<ol>
<li>临界区<ul>
<li>多个进程对<code>共享资源</code>的访问代码区域称为临界区，系统通过<code>加锁</code>等机制确保任意时刻<code>仅有一个进程</code>执行临界区代码。</li>
</ul>
</li>
<li>同步和互斥<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后顺序。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
</li>
<li>信号量(Semaphore)<ul>
<li>信号量是一个<strong>整型计数器</strong>，用于控制进程间访问临界资源的个数。通过原子操作 P()（等待）和 V()（释放）实现：</li>
<li>P：如果信号量大于零，就对其进行减 1 操作；如果信号量等于 0，进程进入 waiting 状态，等待信号量大于零。</li>
<li>V：对信号量执行加 1 操作，并唤醒正在 waiting 的进程<blockquote>
<p>如果信号量只能取 0 或者 1，那么就变成了互斥量，其实也可以理解成加锁解锁操作，0 表示已经加锁，1 表示解锁。</p>
</blockquote>
</li>
<li>信号量是什么？是一种用于控制多进程或多线程并发访问共享资源的<strong>同步机制</strong>，汉堡店例子，有两种信号量：整型信号量和记录型信号量。记录型信号量执行P操作先–，然后判断当前值是否小于0，如果小于0，将其添加进阻塞队列；如果此时执行V操作让值大于等于0，说明在阻塞队列中存在进程已经预定了库存，分配给他。</li>
</ul>
</li>
<li>管程(Monitor)<ul>
<li>管程是高级语言层面的同步机制，封装了共享资源、临界区操作和条件变量。管程内部自动实现互斥，外部无法直接访问内部资源。Java 中 synchronized、wait&#x2F;notify 就是典型的管程模型实现。<blockquote>
<p>Java中的ReentrantLock、Condition、Semaphore等都是对底层同步机制的封装。合理选用这些同步原语是高并发编程的核心。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>进程间通信的方式(<strong>重要！</strong>)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250601141818349.png"></li>
</ol>
<ul>
<li>两个进程都只能访问自己的那一片地址空间，如果一个进程可以随意访问另一个进程的地址空间，会修改另一个进程的数据，导致数据不安全。<ol>
<li>共享存储</li>
</ol>
<ul>
<li>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。但需要借助**同步机制（如信号量、互斥锁）**来防止竞态。</li>
</ul>
<ol start="2">
<li>管道</li>
</ol>
<ul>
<li>管道只能采用<strong>半双工通信</strong>，某一时间段只能实现单向的传输，如果要实现<strong>双向同时通信</strong>，则需要设置两个管道。</li>
<li>各进程<strong>互斥</strong>地访问管道</li>
<li>当管道被写满的时候，写进程应该被阻塞。</li>
<li>当管道空的时候，读进程应该被阻塞。</li>
</ul>
<ol start="3">
<li>Socket和 MQ</li>
</ol>
</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ol>
<li>讲讲死锁发生的条件是什么？<ol>
<li>资源分配是互斥的：资源要么处于被分配给一个进程的状态，要么就是可用状态。</li>
<li>等待和占有条件：进程在请求资源得不到满足的时候，进入阻塞等待状态，且不释放已占有的资源。</li>
<li>不剥夺条件：已经分配给一个进程的资源不能强制性地被抢占，只能等待占有他的进程释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程释放所占有的资源。</li>
</ol>
</li>
<li>如何避免死锁的发生？<ol>
<li>预防策略：从形成死锁的四个条件入手，打破这四个条件的一个或多个<ul>
<li>破坏互斥条件：比如只读文件、磁盘等软硬件资源可采用这种办法处理。</li>
<li>破坏占有和等待条件：在进程开始执行之前，就把其要申请的所有资源全部分配给他，直到所有资源都满足，才开始执行。</li>
<li>破坏不剥夺条件：允许进程强行从资源占有者那里夺取某些资源</li>
<li>破坏环路等待条件：给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次执行。</li>
</ul>
</li>
<li>避免死锁<ul>
<li>银行家算法</li>
</ul>
</li>
<li>如果发生了死锁怎么办？<ul>
<li>先检测到死锁</li>
<li>撤销进程法<ul>
<li>撤销陷于死锁的全部进程</li>
<li>逐个撤销陷于死锁的进程，直到思索不存在</li>
</ul>
</li>
<li>资源剥夺法<ul>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失；</li>
<li>从另外的进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li>你能举出一个死锁的例子吗？</li>
</ol>
<ul>
<li>假设生产者进程先加锁再检查缓冲区是否已满，而消费者进程先检查锁再访问缓冲区。当缓冲区满，生产者阻塞；消费者因锁被占用也阻塞，形成相互等待 —— 死锁。<blockquote>
<p>死锁问题的本质是对有限资源的不当管理，在设计并发程序时应优先关注资源分配顺序和锁粒度控制。</p>
</blockquote>
</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ol>
<li>内存管理的几种机制<br> 操作系统常见的内存管理机制包括分区管理、分页管理、分段管理和段页式管理。<ol>
<li><strong>分区管理</strong>（固定&#x2F;可变）<ul>
<li>最早的机制是将内存划分为若干固定大小或可变大小的区域（分区），每个进程占用一个区域。**缺点是会产生内部或外部碎片，且灵活性差，**因此被现代机制所取代。</li>
</ul>
</li>
<li><strong>分页管理</strong><ul>
<li>将逻辑地址空间划分为固定大小的页（Page），将物理内存划分为相同大小的页框（Frame），通过页表实现逻辑地址与物理地址的映射。<strong>分页提高了内存利用率，解决了外部碎片问题，但可能会增加访问开销。</strong></li>
</ul>
</li>
<li>分段管理<ul>
<li>将程序按照逻辑结构划分为多个段（如代码段、数据段、堆栈段等），每段具有独立的基址和长度，通过段表映射到物理内存。<strong>分段体现了程序的逻辑结构，便于共享和保护，但可能产生外部碎片。</strong></li>
</ul>
</li>
<li>段页式管理<ul>
<li>是分页与分段的结合。先将逻辑地址空间划分为段，再将每个段分页，结合段表和页表进行地址转换。<strong>该机制既保留了分段的逻辑性，又解决了分段带来的碎片问题，是现代操作系统广泛采用的方式。</strong></li>
</ul>
</li>
</ol>
</li>
<li>分页和分段有什么区别呢？</li>
</ol>
<ul>
<li>共同点的话：<ul>
<li>首先都是离散分配的，单每个页和每个段的内存是连续的。</li>
<li>都是为了提高内存利用率，减少内存碎片。</li>
</ul>
</li>
<li>不同点：<ul>
<li>分页式管理的页面大小是固定的，由操作系统决定；分段式管理的页面是由用户程序所决定的。</li>
<li>分页是为了满足操作系统内存管理的需求，每一页是没有实际的意义的；而段是有逻辑意义的，在程序中可认为是代码段、数据段。</li>
<li>分页的内存利用率高，不会产生外部碎片；而分段如果单段长度过大，为其分配很大的连续空间不方便，会产生外部碎片。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>讲讲分页管理的快表和多级页表（按照why how的方式来回答，即为什么出现快表，是如何解决痛点的）<br>why?</li>
</ol>
<h2 id="快表（TLB，Translation-Lookaside-Buffer）"><a href="#快表（TLB，Translation-Lookaside-Buffer）" class="headerlink" title="快表（TLB，Translation Lookaside Buffer）"></a>快表（TLB，Translation Lookaside Buffer）</h2><ol>
<li>为什么要有快表？（Why）<br>在分页管理中，<strong>每次内存访问前都要先查页表</strong>，再根据页表找到物理地址。这样一来，<strong>访问一个内存地址要两次内存访问</strong>（查页表 + 真正访问数据），开销非常大。为了优化访问速度，操作系统引入了快表（TLB），它是一个小型的、快速的硬件缓存，专门用来缓存<strong>页表项</strong>。</li>
<li>快表是如何工作的（How）<br>每次访问内存地址时，先用页号去查快表：</li>
</ol>
<ul>
<li>如果<strong>命中</strong>（也叫TLB Hit），就直接拿到对应的物理页框号，速度非常快；</li>
<li>如果<strong>不命中</strong>，就去查主存中的页表，查到后再把这个页表项加入快表；</li>
<li>如果快表满了，会使用替换策略（如LRU）淘汰掉旧的页表项。<blockquote>
<p>快表的设计基于<strong>局部性原理</strong>：最近访问的页很可能会被再次访问，所以把它缓存在硬件里可以大幅提高访问速度。</p>
</blockquote>
</li>
</ul>
<h2 id="多级页表（Multi-level-Page-Table）"><a href="#多级页表（Multi-level-Page-Table）" class="headerlink" title="多级页表（Multi-level Page Table）"></a>多级页表（Multi-level Page Table）</h2><ol>
<li><p>为什么要有多级页表？（Why）<br>在32位系统中，假如虚拟地址空间是4GB，页大小是4KB，那就需要<br>4𝐺𝐵&#x2F;4𝐾𝐵&#x3D;1𝑀 个页表项。每个页表项4字节，总共页表大小就是4MB，<strong>光是页表就占了很多内存</strong>，对资源是一种浪费。于是提出多级页表，用<strong>树形结构按需加载页表项，节省内存空间。</strong></p>
</li>
<li><p>多级页表是怎么工作的？（How）<br>以两级页表为例，虚拟地址被分成三部分：</p>
</li>
</ol>
<ul>
<li>一级页表索引</li>
<li>二级页表索引</li>
<li>页内偏移<br>访问地址时，先根据一级索引找到对应的二级页表地址，再用二级索引找到具体页表项，最后加上页内偏移得到物理地址。<br>多级页表的好处是：只有用到的页表项才会被加载到内存中，节省了大量内存空间，但代价是地址转换过程变长（可以通过快表优化）。</li>
</ul>
<ol start="4">
<li>讲讲虚拟内存</li>
</ol>
<h2 id="一、为什么需要虚拟内存？（Why）"><a href="#一、为什么需要虚拟内存？（Why）" class="headerlink" title="一、为什么需要虚拟内存？（Why）"></a>一、为什么需要虚拟内存？（Why）</h2><p>早期的程序运行时，必须整个程序全部装入内存才能执行。这个方式有几个问题：</p>
<ul>
<li>程序太大时根本装不下；</li>
<li>多个程序同时运行，内存不够用；</li>
<li>程序之间容易互相干扰，缺乏隔离性。<br>而事实上，程序在某个时刻真正会用到的数据往往只是很小一部分，所以我们没必要一次性全部加载。这就引出了虚拟内存的概念。</li>
</ul>
<h2 id="二、虚拟内存是怎么实现的？（How）"><a href="#二、虚拟内存是怎么实现的？（How）" class="headerlink" title="二、虚拟内存是怎么实现的？（How）"></a>二、虚拟内存是怎么实现的？（How）</h2><p>虚拟内存的核心思想是：让程序以为它有一整块连续的内存空间，而操作系统背后悄悄地在做“地址映射”和“按需加载”。<br>具体来说：</p>
<ul>
<li>每个进程<strong>有一个虚拟地址空间</strong>，和物理内存空间隔离；</li>
<li>程序执行时，只<strong>加载当前需要的页面</strong>，其余放在磁盘（也叫“后备存储”）；</li>
<li>如果程序访问了一个不在内存的页，会触发<strong>缺页中断</strong>；</li>
<li>操作系统此时从磁盘中把该页加载进内存；</li>
<li>如果内存满了，还会触发<strong>页面置换</strong>，将旧的页换出去，把新的页换进来。<blockquote>
<p>这一整套机制依赖于硬件支持的<strong>地址映射（MMU）</strong>，以及操作系统的<strong>分页管理、页面置换算法和缺页中断机制。</strong></p>
</blockquote>
</li>
</ul>
<ol start="5">
<li><p>虚拟内存的三种实现技术？</p>
<ol>
<li>请求分页式存储管理<ul>
<li>程序运行时只加载当前需要的部分；</li>
<li>没有加载的部分先留在磁盘中；</li>
<li>一旦访问未加载的部分，就<strong>触发缺页（或缺段）中断</strong>，把需要的数据调入内存；</li>
<li>若内存不足，还要进行<strong>页面或段的置换。</strong><blockquote>
<p>核心目标都是：<strong>基于局部性原理，按需加载，提高内存利用率。</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>请求分段式存储管理</li>
<li>请求段页式存储管理（主流，先分段再分页）</li>
</ol>
</li>
<li><p>讲讲页面置换算法？</p>
</li>
</ol>
<h2 id="一、为什么需要页面置换？（Why）"><a href="#一、为什么需要页面置换？（Why）" class="headerlink" title="一、为什么需要页面置换？（Why）"></a>一、为什么需要页面置换？（Why）</h2><p>在请求分页的机制下，程序访问的页面不一定都在内存中，一旦访问了不在内存的页面，就会产生缺页中断。如果这时内存已经满了，就需要将某个当前在内存中的页面换出去，把新的页面换进来，这就需要用到页面置换算法。换句话说，页面置换就是一种淘汰策略，目的是在内存空间有限的前提下，尽量保留“有用的页面”，提高命中率。</p>
<h2 id="二、常见的页面置换算法（How）"><a href="#二、常见的页面置换算法（How）" class="headerlink" title="二、常见的页面置换算法（How）"></a>二、常见的页面置换算法（How）</h2><ol>
<li>OPT（最优置换算法）</li>
</ol>
<ul>
<li>思想：总是淘汰未来最长时间不会用到的页面。</li>
<li>优点：命中率最高，是理想状态的上限。</li>
<li>缺点：无法实现，因为操作系统无法预知未来。<blockquote>
<p>一般用于评估其他算法性能的理论上限。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>FIFO（先进先出）</li>
</ol>
<ul>
<li>思想：按页面进入内存的先后顺序，最早进入的最先淘汰。</li>
<li>优点：实现简单，基于队列结构。</li>
<li>缺点：可能淘汰掉频繁使用的页面，存在Belady异常（页框变多反而缺页率升高）。</li>
</ul>
<ol start="3">
<li>LRU（最近最久未使用）</li>
</ol>
<ul>
<li>思想：淘汰最长时间没被访问的页面，基于时间局部性原理。</li>
<li>实现方式有：<ul>
<li>使用链表或栈，记录访问顺序；</li>
<li>用时间戳、计数器等辅助信息。</li>
</ul>
</li>
<li>优点：性能较好，效果接近OPT。</li>
<li>缺点：实现复杂，开销大，需要硬件支持或软件模拟。</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ol>
<li>文件系统主要做了什么？</li>
</ol>
<ul>
<li>文件系统主要负责管理和组织计算机存储设备上的文件和目录<ol>
<li>存储管理：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够多的空间存储。</li>
<li>文件管理：文件的创建、删除、移动、重命名、压缩、加密、共享等。</li>
<li>目录管理：目录的创建、删除、移动、重命名。</li>
<li>文件访问控制：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权的文件，保证文件的安全性和保密性。</li>
</ol>
</li>
</ul>
<ol start="2">
<li>硬链接和软链接有什么区别？<ol>
<li>硬链接<ul>
<li>在 Linux&#x2F;类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li>
<li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li>
<li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li>
<li><code>ln</code>命令用于创建硬链接。</li>
</ul>
</li>
<li>软链接（Symbolic Link 或 Symlink）<ul>
<li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li>
<li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li>
<li>软连接类似于 Windows 系统中的快捷方式。</li>
<li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li>
<li>ln -s 命令用于创建软链接。</li>
</ul>
</li>
</ol>
</li>
<li>硬链接为什么不能跨文件系统？</li>
</ol>
<ul>
<li>硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</li>
</ul>
<ol start="4">
<li>提高文件系统性能的方式有哪些？</li>
</ol>
<ul>
<li>优化硬件：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。</li>
<li>选择合适的文件系统选型：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。</li>
<li>运用缓存：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。</li>
<li>避免磁盘过度使用：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。</li>
<li>对磁盘进行合理的分区：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。</li>
</ul>
<ol start="5">
<li><p>常见的磁盘调度算法</p>
<ol>
<li>先来先服务算法（First-Come First-Served，FCFS）：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</li>
<li>最短寻道时间优先算法（Shortest Seek Time First，SSTF）：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</li>
<li>扫描算法（SCAN）：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，<strong>直到到达磁盘的边界（要到0）</strong>，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</li>
<li>循环扫描算法（Circular Scan，C-SCAN）：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界（要到头），然后回到磁盘起点(0)，重新开始循环。<br> <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250608195117657.png"></li>
<li>边扫描边观察算法（LOOK）：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。<br> <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250608195241862.png"></li>
<li>均衡循环扫描算法（C-LOOK）：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且<strong>磁头只需要返回到有磁道访问请求的位置即可</strong>。不下到0楼了，下到第一个有人的地方。<br> <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250608195354353.png"><blockquote>
<p>LOOK和C-LOOK ：LOOK返回接人，CLOOK直接上到最两边有人的地方</p>
</blockquote>
</li>
</ol>
</li>
<li><p>谈谈inode?</p>
</li>
</ol>
<ul>
<li>Linux会为每个文件分配两个数据结构：<strong>索引节点（index node）<strong>以及</strong>目录项（directory entry）</strong>，它们主要用来记录文件的元信息和目录层次结构。<ul>
<li>索引节点：inode，用来记录文件的元信息，比如inode编号、文件大小、访问权限、创建时间、修改时间、数据<strong>在磁盘的位置</strong>；索引节点是文件的<strong>唯一标识符</strong>。</li>
<li>目录项：用来记录文件的名字，<strong>索引节点指针</strong>，以及与其他目录项的层级关联关系。多个目录项关联起来就会形成目录结构，<strong>目录项不存放在磁盘，而是缓存在内存</strong><blockquote>
<p>目录项和索引节点的关系是一对多</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
  <entry>
    <title>RocketMQ</title>
    <url>/2025/05/30/RocketMQ/</url>
    <content><![CDATA[<p>实际开发：短信分发，第一次进行预处理 用三个消息队列分别存储 ： 移动&#x2F;联通&#x2F;电信的号码</p>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>MQ ： Message Queue 消息队列，是在<strong>消息传输过程中保存消息的容器</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530124156919.png"></p>
<h3 id="1-优势"><a href="#1-优势" class="headerlink" title="1.优势"></a>1.优势</h3><ol>
<li>应用解耦</li>
</ol>
<ul>
<li>耦合度：指的是模块或组件之间的依赖程度。耦合度越高，容错越低。</li>
<li>防止消费者&#x2F;生产者某一方崩了导致整个流程崩溃。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530125404194.png"> <blockquote>
<p>提高系统容错性以及可维护性</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>异步提速</li>
</ol>
<ul>
<li>生产方发完消息，可以继续下一步业务逻辑。<blockquote>
<p>提升用户体验和系统吞吐量</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>削峰填谷<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530130717717.png"><br>相当于数据先打到缓存中，然后消费者从缓存中拿数据，而不是直接打到消费者，如果1w&#x2F;s打到物流系统会崩溃<blockquote>
<p>提高系统稳定性</p>
</blockquote>
</li>
</ol>
<h3 id="2-劣势"><a href="#2-劣势" class="headerlink" title="2.劣势"></a>2.劣势</h3><ol>
<li>系统可用性降低</li>
</ol>
<ul>
<li>如果MQ崩了，就会对业务造成影响。<blockquote>
<p>如何保障MQ的高可用？</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>系统复杂度提高<br>如何保障消息没有被重复消费，如何处理信息丢失，如何保障信息传递的顺序性</li>
<li>一致性问题<br>A处理完业务通过MQ发给BCD，BC都成功处理，那D处理失败，如何保障消息处理数据的一致性？</li>
</ol>
<h2 id="RocketMQ-工作原理总结"><a href="#RocketMQ-工作原理总结" class="headerlink" title="RocketMQ 工作原理总结"></a>RocketMQ 工作原理总结</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530134621660.png"><br>RocketMQ 主要由以下四个核心组件组成：</p>
<h3 id="1-Producer（消息生产者）"><a href="#1-Producer（消息生产者）" class="headerlink" title="1. Producer（消息生产者）"></a>1. Producer（消息生产者）</h3><ul>
<li>负责发送消息到 Broker。</li>
<li>启动时向 NameServer 获取 Topic 的路由信息。</li>
<li>根据路由选择合适的 Broker 和队列进行发送。</li>
<li>支持普通消息、顺序消息、事务消息、延迟消息等。</li>
</ul>
<h3 id="2-NameServer（注册中心）"><a href="#2-NameServer（注册中心）" class="headerlink" title="2. NameServer（注册中心）"></a>2. NameServer（注册中心）</h3><ul>
<li>提供轻量级服务注册与发现。</li>
<li>Broker 启动时将自身信息（Topic、IP、端口等）注册到多个 NameServer。</li>
<li>Producer 和 Consumer 从 NameServer 拉取最新路由信息。</li>
<li>是无状态、可水平扩展的集群。</li>
</ul>
<h3 id="3-Broker（消息中转与存储）"><a href="#3-Broker（消息中转与存储）" class="headerlink" title="3. Broker（消息中转与存储）"></a>3. Broker（消息中转与存储）</h3><ul>
<li>接收来自 Producer 的消息，进行持久化存储。</li>
<li>按 Topic 和 Queue 分类组织消息。</li>
<li>支持主从架构，提升高可用性。</li>
<li>提供消费进度管理、消息拉取服务等。</li>
</ul>
<h3 id="4-Consumer（消息消费者）"><a href="#4-Consumer（消息消费者）" class="headerlink" title="4. Consumer（消息消费者）"></a>4. Consumer（消息消费者）</h3><ul>
<li>从 NameServer 获取路由并从指定 Broker 拉取消息。</li>
<li>支持集群模式（负载均衡）和广播模式（每个消费者都收到）。</li>
<li>支持 Push 或 Pull 两种消费方式。</li>
<li>消费成功后提交消费进度（Offset）。</li>
</ul>
<hr>
<h3 id="消息流动过程（简述）"><a href="#消息流动过程（简述）" class="headerlink" title="消息流动过程（简述）"></a>消息流动过程（简述）</h3><ol>
<li>Broker 启动并向 NameServer 注册。</li>
<li>Producer 启动并向 NameServer 获取路由信息。</li>
<li>Producer 向 Broker 发送消息。</li>
<li>Consumer 向 NameServer 获取路由，并从 Broker 拉取消息。</li>
<li>Consumer 消费消息并提交 Offset。</li>
</ol>
<hr>
<h3 id="特性支持"><a href="#特性支持" class="headerlink" title="特性支持"></a>特性支持</h3><ul>
<li>✅ 高吞吐、低延迟</li>
<li>✅ 顺序消息、事务消息、延迟消息</li>
<li>✅ 主从架构支持高可用</li>
<li>✅ 消费进度可控（精确到队列和偏移量）</li>
</ul>
<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="RabbitMQ-常见的使用场景有哪些？"><a href="#RabbitMQ-常见的使用场景有哪些？" class="headerlink" title="RabbitMQ 常见的使用场景有哪些？"></a>RabbitMQ 常见的使用场景有哪些？</h3><p>场景</p>
<ul>
<li>解耦系统	比如下单成功 → 发短信、发优惠券 → 通过 MQ 异步解耦处理</li>
<li>流量削峰	秒杀高并发请求先进入 MQ 排队，后台异步慢慢处理，防止系统崩溃</li>
<li>异步处理	比如上传图片后异步生成缩略图，发邮件、日志存储等</li>
<li>可靠通知	比如订单状态变更、库存同步等，需要消息必达</li>
<li>延迟&#x2F;定时任务	利用死信队列实现定时取消订单、超时提醒等业务逻辑</li>
</ul>
<h3 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h3><blockquote>
<p>死信队列是用于存放“无法被正常消费的消息”的队列。消息变成“死信”后会被路由到指定的死信交换机，再进入死信队列中，供后续处理或监控。<br>下单后 15 分钟未支付 → 将消息发送到一个设置了 TTL 的普通队列，TTL 到期后消息变成死信 → 转发到死信队列 → 消费者监听死信队列做“自动取消订单”处理。<br>死信队列用于接收处理失败或过期的消息，避免消息丢失。在实际项目中我用它实现延迟任务，比如用户下单后15分钟未支付，通过设置 TTL+死信队列来触发订单关闭逻辑，既解耦了业务流程，也保证了消息可靠性。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>SQL八股</title>
    <url>/2025/06/02/SQL%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p>MySQL是关系型数据库RDB</p>
<ol>
<li>什么是SQL？<br>SQL(Structured Query Language)，专门用于和数据库打交道，从数据库中高效提取数据。</li>
<li>什么是MySQL？<br>MySQL是一种关系型数据库，用于<strong>持久化</strong>我们系统中的一些数据，比如用户信息。</li>
<li>整数类型的UNSIGNED属性有什么用？<br>UNSIGNED可以将表示的正整数范围提升一倍，比如TINYINT只能表示-128-127，如果使用UNSIGNED TINYINT就可以变为0-255，可以用在年龄，员工id等一些值不为<strong>负的场景</strong>。</li>
<li>CHAR和VARCHAR有什么区别？</li>
</ol>
<ul>
<li>CHAR：<ul>
<li>长度：<strong>定长字符串</strong>，比如CHAR(10)，无论输入abc还是abcdefghij，都只会占用10个字符（如果输入超过十个就截断）</li>
<li>适用场景：长度固定的字符串，比如身份证号，性别，<strong>MD5算法</strong>加密后的密码等。</li>
<li>类比：CHAR 就像定长的信封，无论你放几张纸，都塞满；</li>
</ul>
</li>
<li>VARCHAR：<ul>
<li>长度：<strong>变长字符串</strong>，VARCHAR 在存储时需要使用 1（长度小于255） 或 2（长度大于255） 个额外字节记录字符串的长度，检索时不需要处理。比如我存放’abc’，还需要一个字节来记录长度，所以一共是四字节。VARCHAR(10)代表最多能存放10个字节</li>
<li>适用场景：字段长度不确定，如用户名、地址等。</li>
<li>类比：VARCHAR 是塑料袋，放多少张纸占多少空间，节省但形状不规则。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>DECIMAL和&#x2F;FLOAT&#x2F;DOUBLE有什么区别</li>
</ol>
<ul>
<li>DECIMAL(定点数)<ul>
<li><strong>精度高，用于存储精确的小数，不会有误差；</strong></li>
<li>适用于<strong>金融、电商、计量</strong>等要求精确的小数场景；</li>
</ul>
</li>
<li>FLOAT&#x2F;DOUBLE<ul>
<li>近似值，以二进制表示，会有微小误差；</li>
<li>适用于<strong>科学计算、图像处理等对速度要求高但可容忍误差</strong>的场景；</li>
</ul>
</li>
</ul>
<ol start="6">
<li>DATETIME和TIMESTAMP的区别是什么？<br><strong>DATETIME 类型没有时区信息</strong>，TIMESTAMP 和时区有关。</li>
</ol>
<ul>
<li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>
</ul>
<ol start="6">
<li>NULL和’’(空字符串)的区别是什么？</li>
</ol>
<ul>
<li>含义不同：<ul>
<li>NULL 表示值缺失、未知或未定义；</li>
<li>‘’ 是一个已知的空字符串，值是明确存在的，只是没有内容。</li>
</ul>
</li>
<li>比较运算：<ul>
<li>NULL 无法直接参与 &#x3D;、!&#x3D; 等运算，任何和 NULL 比较的结果都是 NULL（未知），只能用 IS NULL &#x2F; IS NOT NULL；</li>
<li>‘’ 可以正常比较，比如 ‘’ &#x3D; ‘’ 是 TRUE。</li>
</ul>
</li>
<li>聚合函数行为：<ul>
<li>NULL 会被 SUM、AVG 等聚合函数自动忽略；</li>
<li>COUNT(*) 统计所有行，包括 NULL；</li>
<li>COUNT(col) 只统计非 NULL 值；</li>
<li>‘’ 会被当成普通值参与运算，比如 SUM(‘’) 视为 0，MIN(‘’) 是空字符串。<blockquote>
<p>为什么不建议使用 NULL 作为默认值？<br>NULL 表达不明确，查询时需要特殊处理，无法高效使用索引，也容易被聚合函数忽略，导致语义和性能问题。除非明确表示“未知&#x2F;缺失”，否则推荐使用更有意义的默认值如 0、’’、1970-01-01 等。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol start="7">
<li><p>BOOLEAN该如何表示？<br>MySQL中没有专门的BOOLEAN，使用TINYINT来存储0&#x2F;1来表示false&#x2F;true</p>
</li>
<li><p>InnoDB有什么强大之处？</p>
</li>
</ol>
<ul>
<li>支持<strong>行级锁</strong>，实现高并发</li>
<li>支持<strong>事务（ACID）</strong><ul>
<li>A：原子性 一组操作要么全部完成，要么全部回滚</li>
<li>C：一致性    执行前后数据保持一致，符合约束和逻辑</li>
<li>I：隔离性    并发事务彼此隔离，不互相干扰</li>
<li>D：持久性    提交后的数据永久保存，即使系统崩溃也不丢失<blockquote>
<p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><ol>
<li>为什么 MySQL 采用 B+ 树作为索引？<br>MySQL是将数据持久化在硬盘上，磁盘 I&#x2F;O 成本高，<strong>索引的核心目标就是减少磁盘访问次数</strong>。B+树只在叶子节点存放索引和数据，且最底层是双向链表，叶子节点通过链表串联，可以高效支持范围查询和排序；非叶子节点只存键值，不存数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603142536027.png" alt="B+树结构"></li>
<li>索引的分类有哪些？<br>有主键索引和二级索引</li>
</ol>
<ul>
<li>主键索引的B+树的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+树的叶子节点里<ul>
<li>主键索引通过PRIMARY KEY创建，主键索引是<strong>聚簇索引</strong>（<strong>索引结构和数据一起存放的索引</strong>）</li>
</ul>
</li>
<li>二级索引的B+树的叶子节点存放的是主键值，而不是实际数据。查完了数据要回表，也就是查两次B+树<ul>
<li>二级索引是非聚簇索引（<strong>索引结构和数据分开存放的索引</strong>）</li>
</ul>
</li>
</ul>
<ol start="3">
<li>什么时候使用索引&#x2F;不使用索引？<br>索引需要占用物理空间，创建索引和维护索引要耗费时间，所以要看场景决定是否使用。</li>
</ol>
<ul>
<li>使用索引<ul>
<li>字段有<strong>唯一限制的</strong>，比如商品编码</li>
<li>经常用where</li>
<li>经常用<code>group by</code> 和<code>order by</code>的字段，因为b+树已经自动排序了。</li>
</ul>
</li>
<li>不使用索引<ul>
<li>不能快速定位</li>
<li>大量重复数据，比如性别</li>
<li>表数据太少</li>
<li>经常更新的字段</li>
</ul>
</li>
</ul>
<ol start="4">
<li>有什么优化索引的办法？</li>
</ol>
<ul>
<li>前缀索引优化<ul>
<li>使用某个字段的前几个字符串建立索引</li>
</ul>
</li>
<li>覆盖索引优化<ul>
<li><strong>覆盖索引就是“只从索引就能拿到结果”的优化技巧，避免回表，提高效率。</strong> 多用于只查几个字段的业务场景。</li>
</ul>
</li>
<li>主键索引最好自增<ul>
<li>避免新开空间割裂。</li>
</ul>
</li>
<li>防止索引失效</li>
</ul>
<ol start="5">
<li>请问在什么情况下索引会失效？你遇到过哪些索引失效的场景？怎么优化？</li>
</ol>
<ul>
<li>模糊查询左边加通配符：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%abc&#x27;</span>  <span class="comment">-- 索引失效</span></span><br></pre></td></tr></table></figure>
<p>使用 LIKE ‘abc%’ 才能走索引。</p>
<ul>
<li>字段运算或函数包裹：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(create_time) <span class="operator">=</span> <span class="number">2024</span>  <span class="comment">-- 索引失效</span></span><br></pre></td></tr></table></figure>
<p>改成 create_time BETWEEN ‘2024-01-01’ AND ‘2024-12-31’</p>
<ul>
<li>隐式类型转换（尤其字符串 vs 数字）：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>  <span class="comment">-- id为int类型，索引失效</span></span><br></pre></td></tr></table></figure>
<p>优化：确保类型一致，参数写成 123 而非 ‘123’</p>
<ul>
<li>OR连接多个条件，但其中一个没有索引：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>确保每个字段都有索引，或用 UNION 拆分查询。</p>
<blockquote>
<p>在MySQL中，索引会因为模糊匹配、函数包裹、类型不一致、OR条件混用或未遵循最左前缀原则等原因失效。我在项目中习惯使用EXPLAIN来查看执行计划，确认SQL是否真正使用索引，并通过改写条件或建组合索引提升查询效率。</p>
<ol start="6">
<li>我们刚讲了单列索引。现在请你谈谈组合索引是什么？什么是“最左前缀原则”？如果你建了一个 (a, b, c) 的联合索引，分别在哪些条件下能使用这个索引？哪些情况会导致索引失效？</li>
</ol>
</blockquote>
<ul>
<li>组合索引是给多个字段一起建的索引，比如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_abc <span class="keyword">ON</span> <span class="keyword">user</span>(a, b, c);</span><br></pre></td></tr></table></figure>
<ul>
<li>这个索引是按 (a, b, c) 顺序组织的，就像一本书里按姓（a）、名（b）、出生年（c）排序的目录。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250610131739264.png"><blockquote>
<p>组合索引是多个字段组合建索引，遵循最左前缀原则。只有从最左字段开始连续使用时才能命中索引。比如索引是 (a, b, c)，必须从 a 开始匹配，否则无法使用索引，可能退化为全表扫描。</p>
</blockquote>
</li>
</ul>
<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><p>有三种日志</p>
<h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p>是Innodb存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，用于<strong>事务的回滚和MVCC</strong></p>
<ol>
<li>MVCC</li>
</ol>
<ul>
<li>MVCC（Multi-Version Concurrency Control），是Innodb实现高并发读写的核心机制，它允许多个<strong>事务并发读写而不加锁</strong>，实现读写不冲突。</li>
<li>MVCC让读操作不必等写操作完成，写操作也不会阻塞读，<strong>大大提升并发性能</strong></li>
<li>如何做到的？<ul>
<li>InnoDB为每行记录维护了两个隐藏字段：<ul>
<li>trx_id：创建&#x2F;最后修改这行的事务id</li>
<li>roll_pointer：指向undo log的指针，可回溯历史版本</li>
</ul>
</li>
<li>读操作会根据当前事务的版本号判断哪些数据是“自己能看到的旧版本”。<blockquote>
<p>MVCC 让读操作看到的是符合事务隔离的“历史快照”，避免加锁冲突，是 InnoDB 实现高并发的核心机制。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>日志增加<blockquote>
<p>每当InnoDB引擎对一条记录进行增删改时，要把回滚时所需的信息记录到undo log里。</p>
</blockquote>
<ul>
<li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li>
<li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li>
<li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li>
</ul>
</li>
</ol>
<h2 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h2><ul>
<li><strong>写入磁盘很慢</strong>，但事务必须保证“提交就不能丢”，所以InnoDB先把sql语句记录在redo log上，再异步刷新到磁盘上，一旦宕机，只要redo log在，就能重做，保证事务数据不丢。</li>
<li>redo log是循环写，会边写边擦除日志，binlog是全局日志。如果数据库被删了，要通过binlog还原。</li>
</ul>
<h2 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h2><p>binlog<strong>Binary Log是 MySQL 层的日志，记录所有涉及数据修改的 SQL 语句如 INSERT、UPDATE、DELETE</strong>，作用是：</p>
<ol>
<li>主从复制的基础<ul>
<li>MySQL 主库会将 binlog 传给从库；从库通过 binlog 重放主库的操作，实现数据同步。</li>
</ul>
</li>
<li>数据恢复（逻辑级）<ul>
<li>搭配全量备份 + binlog，可以恢复任意时间点的数据（类似“时光机”）；比如误删了数据，可以通过 binlog 找出执行的 SQL 语句。<blockquote>
<p>binlog 是 MySQL 层的“操作录像机”，记录了所有数据变更语句，是主从复制和数据恢复的核心。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>问题：那有了binlog，为什么还要有redo log？</p>
<ol>
<li><p>binlog 是“逻辑日志”，写入在事务提交之后：</p>
<ul>
<li>如果系统崩溃在提交前，binlog 根本没写，还原不了；</li>
<li>会导致事务丢失，违背了“已提交不能丢”的承诺。</li>
</ul>
</li>
<li><p>binlog 只能“重演 SQL”，不能“恢复内存页”：</p>
<ul>
<li>redo log 是物理日志，可以快速恢复脏页（Buffer Pool）；</li>
<li>binlog 没法修复页级一致性。<br>✅二者配合流程（WAL机制）：</li>
</ul>
</li>
<li><p>执行 SQL，修改内存页（Buffer Pool）；</p>
</li>
<li><p>写 redo log（物理变更） → 写入 redo log buffer；</p>
</li>
<li><p>写 binlog（逻辑变更）；</p>
</li>
<li><p>同时持久化 redo log + binlog；</p>
</li>
<li><p>执行 COMMIT，事务才算真正提交成功。</p>
</li>
<li><p>为什么需要两阶段提交？</p>
</li>
</ol>
<ul>
<li>有两种情况：<ul>
<li>如果在将redolog刷入到磁盘之后，MySQL突然宕机了，而binlog还没有来得及写入。MySQL重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D;1这行数据的 name字段恢复到新值 xiaolin,但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog会被复制到从库，由于binlog丢失了这条更新语句，从库的这一行name字段是旧值jay，与主库的值不一致性;</li>
<li>如果在将binlog刷入到磁盘之后，MySQL突然宕机了，而redolog还没有来得及写入。由于redolog还没写，崩溃恢复以后这个事务无效，所以id&#x3D;1这行数据的name字段还是旧值jay，而binlog里面记录了这条更新语句，在主从架构中，binlog会被复制到从库，从库执行了这条更新语句，那么这一行name字段是新值xiaolin，与主库的值不一致性;</li>
</ul>
</li>
<li>所以MySQL为了避免半成功，使用了<strong>两阶段提交</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603160127646.png"></li>
<li>把单个事务拆分成了两部分：准备 和 提交<ul>
<li>准备：将XID(内部XA事务的ID)写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log持久化到磁盘(innodb_flush_log_at_trx_commit &#x3D; 1的作用);</li>
<li>提交：把XID写入到binlog，然后将binlog持久化到磁盘(sync_binlog&#x3D;1的作用)，接着调用引擎的提交事务接口，将redolog状态设置为commit，此时该状态并不需要持久化到磁盘，只需要write到文件系统的page cache中就够了，因为只要binlog写磁盘成功，就算redo log的状态还是prepare也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
</li>
</ul>
<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>多个事务并发执行的时候可能会遇到脏读、不可重复读、幻读</p>
<h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603161259993.png"></p>
<ul>
<li>如果一个事务读到了另一个未提交事务所修改的数据，就发生了脏读。</li>
</ul>
<h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603161758686.png"></p>
<ul>
<li>在一个事务内多次读取同一个数据，如果前后两次的数据不一致，就发生了不可重复读</li>
</ul>
<h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603161940832.png"></p>
<ul>
<li>在一个事务内多次查询<strong>记录数量</strong>，如果出现前后两次查询记录数量不一致，就发生了幻读。<blockquote>
<p>幻读和不可重复读的区别在于：一个是行数变了，一个是内容变了</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>脏读靠“读已提交”(每次查询都只能看到其他事务“已提交”的数据”；)解决，不可重复读靠“可重复读”(一个事务开始后，无论查询多少次，看到的都是事务开始时的一致快照；)，幻读还需“间隙锁”防插入(主要用来防止其他事务在已查询范围内插入新记录，从而防止幻读。)。InnoDB 全都能搞定。</p>
</blockquote>
<p>MVCC其实是一种事务隔离级别<code>无锁</code>的实现方式，用于提高事务的并发性能</p>
<ul>
<li>InnoDB存储引擎的数据库表会维护两个隐藏列：<code>trx_id</code>和<code>roll_pointer</code><ul>
<li>trx_id是当前处理这行数据的事务id</li>
<li>如果执行了update语句，会产生一个新数据，新数据的roll_pointer指向旧数据，如果需要回滚，就回退，这些都存放在undolog中方便回滚<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250626112545679.jpg"></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringAiMySelf</title>
    <url>/2025/06/03/SpringAiMySelf/</url>
    <content><![CDATA[<p>AI 问答系统（Chat 接口）<br>用户在前端输入问题，后端 Spring Boot 调用 AI 接口（如 OpenAI &#x2F; 通义千问 &#x2F; 自定义模型），返回回答并展示。</p>
<h1 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h1><ul>
<li>JDK17</li>
<li>在IDEA中勾选依赖项<ul>
<li>SpringWeb &#x2F;&#x2F;搭建REST接口，用于对外提供API</li>
<li>Spring Data Redis &#x2F;&#x2F;使用Redis进行缓存&#x2F;AI结果存储</li>
<li>MySQL Driver &#x2F;&#x2F;用于连接数据库，存储用户、记录等结构化数据</li>
<li>Lombok &#x2F;&#x2F;简化实体类开发，自动生成Getter&#x2F;Setter&#x2F;构造器等</li>
</ul>
</li>
<li>配置application.yml(src&#x2F;main&#x2F;resources)</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span>  <span class="comment">#默认端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据库</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo_db?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#配置redis</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#JSON输出格式优化</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure>

<h2 id="配置测试之Redis"><a href="#配置测试之Redis" class="headerlink" title="配置测试之Redis"></a>配置测试之Redis</h2><ul>
<li>先在本机启动Redis</li>
<li>在src&#x2F;main&#x2F;java&#x2F;com.explainsf&#x2F;springai下新建一个包<code>controller</code>，编写TestController类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.explainsf.springai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/redis&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;test - key&quot;</span>, <span class="string">&quot;hello redis!&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis里读</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;test - key&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redis 中的值是：&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开发问答环节"><a href="#开发问答环节" class="headerlink" title="开发问答环节"></a>开发问答环节</h3><ol>
<li>@RestController注解有什么用？</li>
</ol>
<ul>
<li>它是一个<strong>控制器类</strong>，用于处理前端发过来的请求</li>
</ul>
<hr>
<ol start="2">
<li>@RequestMapping(“&#x2F;test”)有什么用？</li>
</ol>
<ul>
<li>为这个控制器类编写一个统一的URL前缀，所有这个类里的接口，都会带上这个前缀；比如我们写了@GetMapping(“&#x2F;redis”)，最终完整的路径就是&#x2F;test&#x2F;redis</li>
</ul>
<hr>
<ol start="3">
<li>@Autowired有什么用？</li>
</ol>
<ul>
<li>让Spring<strong>自动注入（创建和管理）这个对象</strong>，不然我们就需要手动的new。每一个新创建的对象都要进行一次注解添加</li>
</ul>
<hr>
<ol start="4">
<li>@GetMapping有什么用？</li>
</ol>
<ul>
<li>我们写了<code>GetMapping(&#39;/redis&#39;)</code>，就<strong>去执行下面的这个方法</strong></li>
</ul>
<hr>
<ol start="5">
<li>StringRedisTemplate是什么？opsForValue()方法又有什么用？</li>
</ol>
<ul>
<li>是Spring提供的类，用来专门操控redis;opsForValue()用来操作字符串，有不同的方法可以操作不同的数据类型<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603204613935.png"></li>
</ul>
<blockquote>
<p>Spring Boot 会把你写的每个接口，组合成一个 URL 路径：&#x2F;test是前缀，&#x2F;redis是后缀（调用的方法），拼在一起就可以<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603203821427.png" alt="Redis测试"></p>
</blockquote>
<h2 id="配置测试之MySQL"><a href="#配置测试之MySQL" class="headerlink" title="配置测试之MySQL"></a>配置测试之MySQL</h2><ul>
<li>先创建一个表(也叫做架构)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE demo_db;</span><br></pre></td></tr></table></figure>
<ul>
<li>再使用架构并建表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">                      id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">                      name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">                      email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603205500499.png" alt="建表"></p>
<ul>
<li><p>创建一个entity包，里面有User类</p>
</li>
<li><p>创建一个repository包，目录在包名下，包里含有一个UserRepository接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.explainsf.springai.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.explainsf.springai.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>继承了Jpa这个类，我们自己的接口会有以下方法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603211809647.png" alt="继承Jpa"></p>
</blockquote>
<h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><ol>
<li><code>@Entity</code></li>
</ol>
<ul>
<li><strong>作用</strong>：标识这个类是一个实体类，会映射为数据库中的一张表。</li>
<li><strong>来自</strong>：<code>jakarta.persistence</code></li>
<li><strong>说明</strong>：如果没有这个注解，Spring Boot 不会将该类作为数据库表处理。</li>
</ul>
<hr>
<ol start="2">
<li><code>@Table(name = &quot;user&quot;)</code></li>
</ol>
<ul>
<li><strong>作用</strong>：指定实体类对应的数据库表名为 <code>user</code>。</li>
<li><strong>默认行为</strong>：如果不写该注解，JPA 会默认使用类名作为表名（大小写敏感，容易报错）。</li>
</ul>
<hr>
<ol start="3">
<li><code>@Id</code></li>
</ol>
<ul>
<li><strong>作用</strong>：标识该字段为<strong>主键</strong>（Primary Key）。</li>
<li><strong>必须使用</strong>：否则 JPA 无法知道如何唯一标识一条记录。</li>
</ul>
<hr>
<ol start="4">
<li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code></li>
</ol>
<ul>
<li><strong>作用</strong>：设置主键的生成策略为数据库自增（MySQL 中的 AUTO_INCREMENT）。</li>
<li><strong>常见策略</strong>：<ul>
<li><code>AUTO</code>：由 JPA 自动选择策略</li>
<li><code>IDENTITY</code>：数据库自增（适用于 MySQL）</li>
<li><code>SEQUENCE</code>：使用序列（适用于 Oracle）</li>
<li><code>TABLE</code>：使用数据库表记录主键（性能较差）</li>
</ul>
</li>
</ul>
<hr>
<ol start="5">
<li><code>@Data</code>（Lombok 提供）</li>
</ol>
<ul>
<li><strong>作用</strong>：自动生成以下方法：<ul>
<li><code>get</code> &#x2F; <code>set</code></li>
<li><code>toString()</code></li>
<li><code>equals()</code> &#x2F; <code>hashCode()</code></li>
</ul>
</li>
<li><strong>简化代码</strong>： 相当于加了：@Getter @Setter @ToString @EqualsAndHashCode ，@RequiredArgsConstructor<blockquote>
<p>在下文中，虽然我们没写getMessage()方法，但是由于我们在ChatRequest这个类上加了Data注解，于是自动生成了Get方法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603213050247.png" alt="数据库连接"></p>
</blockquote>
</li>
</ul>
<h2 id="配件测试之Qwen"><a href="#配件测试之Qwen" class="headerlink" title="配件测试之Qwen"></a>配件测试之Qwen</h2><ul>
<li>在application.yml中使用Qwen创建的api-key以及api-url(不同的模型有不同的http响应)</li>
<li>在pom.xml配置dependecy</li>
<li>在软件包下创建config包并在里面配置<code>QwenConfig</code>类</li>
<li>然后在Service里开发QwenService负责</li>
<li>最后在ChatController中提供对外的接口</li>
</ul>
<h3 id="配置API之Qwen"><a href="#配置API之Qwen" class="headerlink" title="配置API之Qwen"></a>配置API之Qwen</h3><ol>
<li>@Component有什么用？</li>
</ol>
<ul>
<li>将这个类注册为Spring容器中的一个Bean，@Component是注册Bean，<strong>告诉 Spring 这个类&#x2F;对象你要负责创建和管理。</strong><blockquote>
<p>@Component：你告诉 Spring “这个类要托管给你管理”（注册到容器）<br>@Autowired：你告诉 Spring “我要用那个托管的类”（注入使用）</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>@ConfigurationProperties(prefix &#x3D; “qwen”)有什么用？</li>
</ol>
<ul>
<li>SpringBoot会自动将application.yml中的api-key和api-url注入到QwenConfig中的配置环境。</li>
</ul>
<hr>
<p>到目前，后端的基础就已经写好了。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604103258227.png"></p>
<p>阶段性总结</p>
<ul>
<li>我们写的这个结构是SpringBoot的三层架构：<ul>
<li>配置类Config</li>
<li>服务类Service</li>
<li>控制器类Controller</li>
</ul>
</li>
</ul>
<h1 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h1><h2 id="聊天接口完善"><a href="#聊天接口完善" class="headerlink" title="聊天接口完善"></a>聊天接口完善</h2><ul>
<li>支持POST请求</li>
<li>返回统一的JSON格式</li>
</ul>
<ol>
<li>在包下新建model包，并在里面新建ChatRequest类和统一响应类</li>
<li>重写ChatRequest类(使用了@Data)</li>
<li>使用了统一返回类</li>
<li>最后使用PostMan进行POST请求的调试<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604110257747.png"></li>
</ol>
<h3 id="聊天接口之完善问答"><a href="#聊天接口之完善问答" class="headerlink" title="聊天接口之完善问答"></a>聊天接口之完善问答</h3><ol>
<li>为什么要新建一个model并在里面创建ChatRequest和统一响应类？</li>
</ol>
<ul>
<li>之前我们调用API的回答方式是&#x2F;chat方法，是一种get请求，简单来说就是我们只需要传一个参数<code>问题</code>，浏览器就会给我们模型的回答，现在我们使用ChatRequest和统一响应类来接收JSON请求体，可以把接口返回格式统一，也是主流的开发。</li>
</ul>
<p>&#x2F;&#x2F;json格式混乱，我们使用json格式解析器回复更好<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604111310245.png"><br>现在我们就成功调用了ai</p>
<h2 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h2><ul>
<li>创建一个chat.html(src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;chat.html)</li>
<li>修改ChatController作为页面路由</li>
<li>前端代码生成<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604114943104.png"></li>
<li>但现在问题是：无法记录上下文，这时候我们就要用到redis存储历史记录<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604115410587.png"></li>
</ul>
<h2 id="Redis实现上下文记录"><a href="#Redis实现上下文记录" class="headerlink" title="Redis实现上下文记录"></a>Redis实现上下文记录</h2><ul>
<li>创建util包，里面存放着ChatMemoryManager实现类<ul>
<li>ChatMemoryManager的实现类思路<br>我们先使用了<code>StringRedisTemplate</code>和<code>ObjectMapper</code>这两个类，并且定义了最大历史记录为5.</li>
</ul>
</li>
<li>修改QwenService以及Controller，让它们带上了userId和Message<ul>
<li>我们使用了一个<strong>集合</strong>来存放历史消息</li>
</ul>
</li>
</ul>
<h3 id="Redis问答"><a href="#Redis问答" class="headerlink" title="Redis问答"></a>Redis问答</h3><ol>
<li>StringRedisTemplate类是哪里来的？</li>
</ol>
<ul>
<li>它是Spring提供的操作redis的类，专门用于字符串类型的读写操作。</li>
</ul>
<ol start="2">
<li>ObjectMapper是哪里来的？</li>
</ol>
<ul>
<li>这是Jackson提供的核心类，用来进行java对象&lt;–&gt;JSON字符串的切换，在发送请求和存redis的时候会经常用到</li>
</ul>
<ol start="3">
<li>那我们现在的redis会不会自动删除聊天记录呢？</li>
</ol>
<ul>
<li>其实不会，使用的是 redisTemplate.opsForValue().set(key, value)，也没有设置过期时间TTL，所以历史记录会<strong>永久存放在redis</strong>中；那我们是否需要删除呢？要取决于我们的上下文聊天是否持久<ul>
<li>保证每次进入页面都有记忆：不删除，可以永久存放在redis中</li>
<li>只在本次对话中记忆：需要删除，聊完就清空redis</li>
<li>长期登录用户的对话记录：建议写入数据库，redis仅做缓存，<strong>MySQL做历史保存，Redis做上下文</strong></li>
</ul>
</li>
</ul>
<ol start="4">
<li>所以chatGPT的策略是什么？</li>
</ol>
<ul>
<li>所有的<code>记忆</code>都是靠<strong>拼接历史对话内容</strong>到当前请求中完成的，并不是”主动记得”，当每次用户提问的时候，系统把之前的消息打包发送给模型。所谓的上下文能力全部来源于<code>调用者的message消息列表</code>，<ul>
<li>调用chatGPT时，OpenAI会构造出这样一个message数组：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你好&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你好，有什么我可以帮你的吗？&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你知道我刚才问了什么吗？&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只有这样模型才知道刚刚发生了什么。</li>
</ul>
</li>
<li>所以我们有两种方式实现长期记忆<ol>
<li>前端或服务端主动保存历史聊天</li>
</ol>
<ul>
<li>每次用户发言就持久化（如存到 MySQL）</li>
<li>用户进入新聊天时自动加载历史上下文到 Redis，再发送给模型</li>
</ul>
<ol start="2">
<li>方式二：Embedding + 概念记忆（更高阶）</li>
</ol>
<ul>
<li>把用户历史对话转为向量（embedding），存入向量库</li>
<li>在新问题触发时从向量库中“召回相似的历史”，附加给 prompt<blockquote>
<p>现在构建的 Redis-based 对话记忆系统，是行业内标准方案。<br>现在消息记录已经被成功存入到redis中了<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604124304164.png"><br>成功了！<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604131807919.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="MySQL实现持久化聊天记录到本地"><a href="#MySQL实现持久化聊天记录到本地" class="headerlink" title="MySQL实现持久化聊天记录到本地"></a>MySQL实现持久化聊天记录到本地</h2><ul>
<li>基于Redis我们可以实现上下文记忆，但我们需要保存聊天记录，有以下好处<ul>
<li>MySQL可以持久化数据，<strong>适合做用户聊天记录展示、检索以及分析</strong></li>
<li>Redis重启可能数据会丢失，MySQL可以长期备份保存</li>
<li>用这些保存的数据继续去分析</li>
<li>多端跨平台跨设备查看历史聊天记录<blockquote>
<p>🔒 Redis 用于短时上下文记忆（对话中），MySQL 用于长期存储与用户功能（查看历史、数据分析），两者配合才完整。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol>
<li>我们需要建表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> chat_log (</span><br><span class="line">    id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    user_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    role <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,          <span class="comment">-- user / assistant</span></span><br><span class="line">    content TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (user_id) <span class="keyword">REFERENCES</span> <span class="keyword">user</span>(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>在entity添加实体类<code>ChatLog</code>(对应MySQL表)</p>
</li>
<li><p>添加Repository(操作数据库)</p>
</li>
</ol>
<h3 id="数据库问答"><a href="#数据库问答" class="headerlink" title="数据库问答"></a>数据库问答</h3><ol>
<li>JPA是什么？<br>(Java Persistence API) Java官方定义的一套ORM规范，可以把<strong>数据库当Java中的类来操作，把数据行当成对象来操作</strong>，我们使用的是SpringBoot + JPA</li>
</ol>
<ul>
<li>实体类：@Entity + @Table描述数据库表结构</li>
<li>接口：extends JpaRepository&lt;实体，主键类型&gt;直接获得数据库</li>
<li>不用写SQL，自动生成</li>
</ul>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604141206470.png"><br>我们成功创建了MySQL和后端的连接，但是有个问题！我们没有注册登录用户，当我们拿一个从来没有插入进数据库的id进行回答时，虽然模型成功给出了答案，但是并没有成功在前端页面返回，是因为我们没有在user表里插入这个人，所以我们现在可以使用一个办法，先让用户注册并登录，让这个用户和chat_log表中的对应数据关联。</p>
<ul>
<li>所以我们接下来先实现用户注册登录功能</li>
<li>我们有两张表，一张是chat_log，另一张是user，user里可以设置字段id以及password，在chat_log里面的表也有一个id字段，作为外键指向user表让两张表相连。</li>
</ul>
<h2 id="登陆注册"><a href="#登陆注册" class="headerlink" title="登陆注册"></a>登陆注册</h2><ol>
<li>复写User类，新增password字段，@Data直接帮我们省去了Setter和Getter的写</li>
<li>写UserRepository，主要是添加</li>
<li>创建UserService实现登录注册逻辑</li>
<li>添加Spring Security依赖<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604153637030.png"></li>
</ol>
<h3 id="登陆注册问题"><a href="#登陆注册问题" class="headerlink" title="登陆注册问题"></a>登陆注册问题</h3><ol>
<li>@Server注解有什么用？</li>
</ol>
<ul>
<li>它是 Spring 的组件注解之一，用于标识一个类是“服务层组件”（Service）。被标注的类会被 Spring 容器自动识别并托管为 Bean，可以在其他地方通过 @Autowired 自动注入使用。</li>
</ul>
<ol start="2">
<li>@Override有什么用？</li>
</ol>
<ul>
<li>表示当前方法是 重写了父类或接口中定义的方法。</li>
</ul>
<ol start="3">
<li>我们采用了什么加密算法？</li>
</ol>
<ul>
<li>加密方式：BCrypt 哈希加密，是一种<strong>不可逆</strong>的密码加密方式；<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604154714565.png"></li>
</ul>
<h2 id="JWT登陆注册"><a href="#JWT登陆注册" class="headerlink" title="JWT登陆注册"></a>JWT登陆注册</h2><blockquote>
<p>既然我们已经有了数据库登录，那为什么还要做JWT登录？</p>
</blockquote>
<ul>
<li>数据库<ul>
<li>当前数据库的登陆方式是用户登陆时提交ID和密码</li>
<li>服务端查数据库验证密码</li>
<li>前端之后每次请求仍需要传用户ID，服务端继续查数据库验证</li>
<li>问题在于<strong>每一次都要去请求数据库，太麻烦了！</strong></li>
</ul>
</li>
<li>JWT<ul>
<li>我们在登陆成功后给用户发一个令牌token，代表用户身份，每次请求只去查询<code>token</code>，实现无状态认证。</li>
<li>易扩展，可以加入用户角色、权限、过期时间等<blockquote>
<p>数据库登录是“身份验证的方式”，而 JWT 是“身份验证后的认证令牌机制”，两者是互补不是重复。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol>
<li>添加依赖</li>
<li>修改UserService.login和UserController</li>
</ol>
<ul>
<li>登陆成功后生成JWT Token</li>
<li>将Token和用户信息一起返回给前端</li>
<li>创建一个DTO(LoginResponse)</li>
<li>修改登录逻辑，使用LoginResponse类型来接收<blockquote>
<p>成功返回了jwt令牌<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604160458678.png"></p>
</blockquote>
</li>
</ul>
<h2 id="编写JwtAuthFilter实现Token校验与用户认证"><a href="#编写JwtAuthFilter实现Token校验与用户认证" class="headerlink" title="编写JwtAuthFilter实现Token校验与用户认证"></a>编写JwtAuthFilter实现Token校验与用户认证</h2><ul>
<li>使用 OncePerRequestFilter 保证每次请求只调用一次；</li>
<li>我们把 userId 放入了认证上下文，可以在控制器里用 @AuthenticationPrincipal 获取；</li>
<li>不做角色权限处理，使用空权限列表 Collections.emptyList() 即可。</li>
</ul>
<ol>
<li>增加我们自定义的jwt过滤器</li>
</ol>
<ul>
<li>addFilterBefore(…) 是关键，把我们自定义的 JWT 过滤器插入到 Spring Security 过滤器链中；</li>
<li>现在所有接口如果没有 Token，都会被拒绝访问（除了 permitAll() 的那些）；</li>
</ul>
<h2 id="但现在又出现了新的问题"><a href="#但现在又出现了新的问题" class="headerlink" title="但现在又出现了新的问题"></a>但现在又出现了新的问题</h2><ul>
<li>我们在单一账号下能够实现记忆，但是用了两个不同的账号来回切换，就发现它们无法读取之前的记忆了，问题在于我们之前使用的是getMessages(userId)从 Redis 拉取历史，上下文丢失了<blockquote>
<p>用户登录或重新进入聊天时，如果 Redis 中无上下文，则从 MySQL 中加载最近 N 条对话记录“恢复记忆”。</p>
</blockquote>
</li>
</ul>
<ol>
<li>在chat方法添加如果redis是空，从mysql里找回之前的消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1: 如果 Redis 无上下文，自动从数据库恢复</span></span><br><span class="line">    <span class="keyword">if</span> (chatMemory.getMessages(userId).isEmpty()) &#123;</span><br><span class="line">        List&lt;ChatLog&gt; recent = chatLogRepository.findTop10ByUserIdOrderByCreateTimeDesc(Long.valueOf(userId));</span><br><span class="line">        Collections.reverse(recent); <span class="comment">// 确保顺序正确（旧 → 新）</span></span><br><span class="line">        <span class="keyword">for</span> (ChatLog log : recent) &#123;</span><br><span class="line">            chatMemory.saveMessage(userId, log.getRole(), log.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>成功加入历史记录！<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604163808292.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604163859488.png"></p>
<h1 id="部署上线"><a href="#部署上线" class="headerlink" title="部署上线"></a>部署上线</h1><p>使用阿里云ECS</p>
<ul>
<li>下载XShell</li>
<li>连接阿里云服务器</li>
<li>Maven打包Jar包<ul>
<li>clean&amp;&amp;package</li>
</ul>
</li>
<li>下载XFTP上传Jar包<ul>
<li>上传成功后在Xshell输入nohup java -jar &#x2F;root&#x2F;my-project.jar &gt; app.log 2&gt;&amp;1 &amp;</li>
</ul>
</li>
<li>安装nginx作反向代理，去掉端口号<br>成功上线！<br>IP访问和域名访问</li>
<li>IP访问：直接访问</li>
<li>域名访问：国内要备案</li>
</ul>
<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><h3 id="Q：重点介绍一下你在CC-Chat项目中最具挑战性的部分，以及你是如何解决的。"><a href="#Q：重点介绍一下你在CC-Chat项目中最具挑战性的部分，以及你是如何解决的。" class="headerlink" title="Q：重点介绍一下你在CC-Chat项目中最具挑战性的部分，以及你是如何解决的。"></a>Q：重点介绍一下你在CC-Chat项目中最具挑战性的部分，以及你是如何解决的。</h3><p>A：在我独立开发的CC-Chat项目中，最具挑战的部分是实现上下文记忆功能。起初我通过Redis缓存用户的历史对话，实现大模型的上下文“模拟”。但在测试中发现模型无法记住历史对话，排查后发现由于用户切换账号，缓存数据被清除，导致上下文缺失。<br>为此，我引入MySQL存储完整历史记录，当缓存缺失时自动回源数据库构造上下文，从而保证了对话的连续性和智能性。这个过程让我更深入理解了缓存与持久化的协同机制，也锻炼了我定位问题和系统设计的能力。</p>
<h3 id="Q：你刚才提到了-Redis-和-MySQL-配合实现上下文记忆。那请你详细讲讲你是如何设计-Redis-缓存结构的？具体用到了哪些数据结构或命令？是否考虑过数据过期和清理机制？"><a href="#Q：你刚才提到了-Redis-和-MySQL-配合实现上下文记忆。那请你详细讲讲你是如何设计-Redis-缓存结构的？具体用到了哪些数据结构或命令？是否考虑过数据过期和清理机制？" class="headerlink" title="Q：你刚才提到了 Redis 和 MySQL 配合实现上下文记忆。那请你详细讲讲你是如何设计 Redis 缓存结构的？具体用到了哪些数据结构或命令？是否考虑过数据过期和清理机制？"></a>Q：你刚才提到了 Redis 和 MySQL 配合实现上下文记忆。那请你详细讲讲你是如何设计 Redis 缓存结构的？具体用到了哪些数据结构或命令？是否考虑过数据过期和清理机制？</h3><p>A：在Redis中，我为每个用户维护一个聊天上下文列表，采用Redis的List结构（如 lpush 和 lrange）按时间顺序缓存每轮对话。当用户发起新的请求时，我会根据用户ID取出最新的几条消息构造上下文。如果Redis缓存为空（如首次登录或缓存过期），我会从MySQL中查出该用户的历史记录，恢复构造Redis缓存，保证连续性。<br>同时我设置了缓存的过期时间（<code>expire</code>），<code>避免内存占用过高</code>。<code>为了防止缓存击穿，我也使用了双写策略</code>：每次新对话既写入Redis也写入MySQL。此外，为了提升并发性能，设计了异步写入MySQL的方案。</p>
<p>第二期方案： “缓存写 + 异步落库”的方案。用户每次对话时，我会先将聊天数据写入Redis缓存，同时将该记录封装成消息推送到消息队列（如RabbitMQ），由异步消费线程统一批量写入MySQL。</p>
<ol>
<li>写入快速响应：主线程只操作内存级别的Redis，不阻塞。</li>
<li>削峰填谷：队列起到缓冲作用，避免高并发时数据库写入雪崩。</li>
<li>数据一致性：我设置了失败重试机制和幂等处理，确保数据不会重复或丢失。</li>
</ol>
<ul>
<li>幂等：幂等（Idempotent）处理是指无论执行多少次操作，结果都是一样的，不会因为重复执行而产生副作用。假设用户发送一条聊天消息，系统把这条消息保存到数据库。如果因为网络问题，这条请求被重试了3次，幂等处理能确保这条消息只保存一次，不会出现三条一样的记录。<br>在 CC-Chat 项目的异步写入方案中，为避免消息重复消费导致聊天记录重复插入数据库，我设计了基于 Redis 的幂等处理机制。<br>具体做法如下：</li>
</ul>
<ol>
<li>唯一标识：每条聊天消息生成一个唯一ID（如使用UUID或雪花算法）。</li>
<li>消息发送：当用户发送消息时，该ID连同消息体一起被封装发送到 RabbitMQ。</li>
<li>幂等校验：消费者在处理前，先去 Redis 查询该消息ID是否已处理。</li>
<li>若 Redis 中存在该ID，则跳过（说明是重复消息）。</li>
<li>若不存在，则处理并在 Redis 中用 setnx 命令记录该ID，并设置短期过期时间（如5分钟）。</li>
<li>落库写入：消息入库成功后，异步确认或更新 Redis 状态。</li>
</ol>
<p>通过这种方式，即使 RabbitMQ 消息被重复投递或消费，依赖 Redis 的幂等校验可确保每条聊天消息只被写入一次，保证数据一致性与准确性。</p>
<h3 id="Q：你使用了建表语句，这个数据库会无限的扩容下去吗？当我聊天的时候信息越来越多，数据库一直增长？"><a href="#Q：你使用了建表语句，这个数据库会无限的扩容下去吗？当我聊天的时候信息越来越多，数据库一直增长？" class="headerlink" title="Q：你使用了建表语句，这个数据库会无限的扩容下去吗？当我聊天的时候信息越来越多，数据库一直增长？"></a>Q：你使用了建表语句，这个数据库会无限的扩容下去吗？当我聊天的时候信息越来越多，数据库一直增长？</h3><p>A：如果没有限制机制，<strong>数据库会默认一直增长</strong>，会带来查询变慢，磁盘空间不足，数据备份和迁移变得困难。<br>我想到了这个问题后打算在后续完善项目时采用以下几个策略进行问题解决</p>
<ul>
<li>分库分表：将大表用户按用户ID或时间进行分表，比如按月建表，提升效率</li>
<li>历史数据归档：将半年以前的数据定期转移到归档表或冷存储中，仅保留最近活跃记录</li>
<li>分页+索引优化： 配合时间字段建索引，并使用分页查询，避免全表扫描；</li>
<li>使用外部存储：对非结构化数据（如图片、长文本）使用对象存储（如OSS）+URL引用，减轻数据库压力</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Redis八股</title>
    <url>/2025/06/10/Redis%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h2 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="什么是缓存击穿、穿透、雪崩？区别是什么？如何解决？"><a href="#什么是缓存击穿、穿透、雪崩？区别是什么？如何解决？" class="headerlink" title="什么是缓存击穿、穿透、雪崩？区别是什么？如何解决？"></a>什么是缓存击穿、穿透、雪崩？区别是什么？如何解决？</h3><ul>
<li>穿透：请求<strong>永远不会命中缓存</strong><ul>
<li>请求的数据缓存中没有，数据库也没有，每次请求都会打到数据库</li>
<li>查不存在的用户ID，如 ID&#x3D;-1</li>
<li>① 参数校验 ② 布隆过滤器 ③ 缓存空值<ul>
<li>启动时将数据库中所有合法的 ID 加入布隆过滤器；</li>
<li>每次查询前先判断：ID 是否在布隆过滤器中？</li>
<li>如果不在 → 直接返回，不查缓存也不查库；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果在 → 走正常的缓存查询流程。</p>
<ul>
<li>击穿：缓存<strong>偶尔失效后瞬间打爆后端</strong><ul>
<li>某个热点数据突然过期，大量请求同时查询，穿透缓存打爆数据库</li>
<li>秒杀商品库存刚好过期</li>
<li>① 加互斥锁 ② 提前续期 ③ 永不过期+异步更新</li>
</ul>
</li>
<li>雪崩：<strong>大量缓存同时失效导致系统崩溃</strong><ul>
<li>大量缓存同一时间过期，所有请求打到数据库，系统瞬间崩溃</li>
<li>定时批量缓存设置相同过期时间</li>
<li>① 加随机过期时间 ② 热点预热 ③ 多级缓存<blockquote>
<p>布隆过滤器是一种<strong>概率型数据结构</strong>，可以用来判断一个元素<strong>一定不存在&#x2F;可能存在</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Redis的过期删除策略？"><a href="#Redis的过期删除策略？" class="headerlink" title="Redis的过期删除策略？"></a>Redis的过期删除策略？</h3><ul>
<li>惰性删除：访问key时，才检查他是否过期，如果过期就删除 | 但可能留下大量垃圾</li>
<li>定期删除：每隔一段时间随机抽取部分 key 检查过期并删除（如每秒检查 20 个）</li>
<li>主动淘汰：当内存不足时触发内存淘汰机制</li>
</ul>
<h3 id="什么是基于-Redis-构造分布式锁？"><a href="#什么是基于-Redis-构造分布式锁？" class="headerlink" title="什么是基于 Redis 构造分布式锁？"></a>什么是基于 Redis 构造分布式锁？</h3><ul>
<li>本质：利用 Redis 的 SET key value NX EX 原子命令，保证同一时刻只有一个线程&#x2F;服务获取到锁，从而控制并发访问共享资源（如库存扣减、优惠券发放）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">SET lock_key my_value NX EX <span class="number">10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>NX：只在 key 不存在时设置（互斥）</li>
<li>EX 10：自动过期（防死锁）</li>
<li>my_value：用 UUID 表示“我是谁”，用于后续解锁校验</li>
</ul>
<h3 id="为什么用-Lua-脚本做分布式锁？"><a href="#为什么用-Lua-脚本做分布式锁？" class="headerlink" title="为什么用 Lua 脚本做分布式锁？"></a>为什么用 Lua 脚本做分布式锁？</h3><p>加锁与解锁需要“判断 + 删除”是一个原子操作。用<strong>普通 Redis 命令不能保证原子性</strong>（可能判断完刚要删，锁就被别人改了）。<br>Redis 支持执行一整段 Lua 脚本，这段脚本在 Redis 内部一次性、原子性执行，所以我们用它封装加锁或解锁逻辑，确保线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="缓存一致性如何实现？"><a href="#缓存一致性如何实现？" class="headerlink" title="缓存一致性如何实现？"></a>缓存一致性如何实现？</h3><ul>
<li>先更新库，再删除缓存，设置延迟双删。</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li>虽然redis是内存数据库，但是提供了两种方式进行持久化，默认的是RDB，AOF需要自行设置配置开启；</li>
</ul>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><ul>
<li>AOF的步骤是，当一条<code>写命令</code>成功执行后，把这条命令追加到一个文件里，然后重启redis的时候，redis先去这个文件里读取命令并执行，就相当于恢复了数据。<ul>
<li>避免额外检查开销</li>
<li>不会阻塞当前写操作命令的执行：因为只有命令执行成功后才会被写入</li>
</ul>
</li>
</ul>
<h4 id="AOF写回策略"><a href="#AOF写回策略" class="headerlink" title="AOF写回策略"></a>AOF写回策略</h4><ul>
<li>Always：执行完命令同步将AOF日志数据写回硬盘</li>
<li>Everysec：执行完命令后就将写操作写入到缓冲区，然后<code>每隔一秒</code>将缓冲区的数据写入到硬盘</li>
<li>No：转由操作系统写</li>
</ul>
<h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><ul>
<li>随着数据库使用的越来越多，AOF文件的体积变大，就需要重写机制，只会保存最新的一条更新数据</li>
<li>比如使用:set name lcc 然后再使用 set name lccc</li>
<li>更新的时候只会记住后面的lccc，因为之前的命令已经没有意义了。</li>
</ul>
<h4 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h4><ul>
<li>RDB是快照，每次执行快照，把<code>内存里的所有数据</code>都记录到硬盘里，所以如果频繁执行快照，就会导致Redis的性能下降，如果设置时间过长，然后恰好宕机，就会丢失这一段时间里的所有数据</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2025/07/23/Nginx/</url>
    <content><![CDATA[<h1 id="学习Nginx"><a href="#学习Nginx" class="headerlink" title="学习Nginx"></a>学习Nginx</h1><h2 id="基本用法：正向代理-反向代理-动静分离-负载均衡"><a href="#基本用法：正向代理-反向代理-动静分离-负载均衡" class="headerlink" title="基本用法：正向代理 &amp;&amp; 反向代理 &amp;&amp; 动静分离 &amp;&amp; 负载均衡"></a>基本用法：正向代理 &amp;&amp; 反向代理 &amp;&amp; 动静分离 &amp;&amp; 负载均衡</h2><blockquote>
<p>一句话总结：正向代理屏蔽了真实的ip地址，反向代理屏蔽了服务器的位置</p>
</blockquote>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><ol>
<li>功能<ul>
<li>常用于VPN，翻墙：举一个比较简单的例子：<ul>
<li>你想去问老师问题，但是你没办法直接找到老师</li>
<li>你委托一个同学去找老师</li>
<li>同学找到了老师并且老师告诉了你同学你想问的内容</li>
<li>你同学回来告诉你老师说了什么</li>
<li>相当于你成功问了老师问题</li>
</ul>
</li>
<li>同学在这一个过程中起的是<code>代理服务器</code>的作用</li>
</ul>
</li>
<li>定义<ul>
<li>在客户端（浏览器）配置<code>代理服务器</code>，通过代理服务器进行互联网访问。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250723162338683.jpg"></li>
</ul>
</li>
</ol>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ol>
<li>功能<ol>
<li>隐藏<code>服务器</code>真实ip地址，增强安全性</li>
<li>负载均衡，将请求转发到多台后端服务器，提高性能和可用性</li>
<li>静态资源缓存，减少后端服务器压力，提升响应速度</li>
</ol>
</li>
<li>定义<ul>
<li>我们将请求发送到<code>代理服务器</code>中，由反向代理服务器去选择目标服务器获取数据，再返回给客户端，此时可以将<strong>反向代理服务器和目标服务器视为同一个服务器</strong>，暴露了代理服务器的地址，隐藏了真实服务器地址的ip</li>
</ul>
</li>
</ol>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ol>
<li>功能：很多请求打入服务器，很可能会造成崩溃，这时候需要Nginx转发请求，让每个服务器都能分摊请求。其实就是一个项目的jar包部署在多台服务器上。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250723165250720.jpg"></li>
</ol>
<h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><ol>
<li>功能：将静态资源和动态资源分别部署在不同的服务器上，节省资源空间，加快访问速度。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250723165813652.jpg"></li>
</ol>
<h2 id="在Linux上配置及使用Nginx"><a href="#在Linux上配置及使用Nginx" class="headerlink" title="在Linux上配置及使用Nginx"></a>在Linux上配置及使用Nginx</h2><ul>
<li>使用ssh远程链接本地的ubuntu<ul>
<li>ssh：SSH（Secure Shell） 是一种网络协议，用于在 不安全的网络中安全地远程登录另一台机器，比如你在 Windows 上登录一台 Linux 服务器。</li>
</ul>
</li>
<li>Xshell：让我们能在windows上操作Linux系统，配合Xftp实现上传下载文件</li>
<li>最终可以实现使用ip访问nginx</li>
</ul>
<h2 id="Nginx的配置文件"><a href="#Nginx的配置文件" class="headerlink" title="Nginx的配置文件"></a>Nginx的配置文件</h2><p>有<code>三部分</code>组成</p>
<h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><ul>
<li>作用：从配置文件到events块的所有内容，主要会设置一些影响 nginx 服务器整体运行的配置命令</li>
<li>全局块配置如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes <span class="keyword">auto</span>;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">include /etc/nginx/modules-enabled<span class="comment">/*.conf;</span></span><br></pre></td></tr></table></figure>
<p>比如<code>worker_processes</code>这个参数，越大的话，可以支持的并发处理量也就越多</p>
<h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><ul>
<li>作用：影响Nginx服务器与用户的网络连接</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">	worker_connections <span class="number">768</span>;</span><br><span class="line">	# multi_accept on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>比如worker_connections是支持的最大连接数</li>
</ul>
<h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><ul>
<li>http块里又分为两块：<code>http全局块</code>和<code>server块</code></li>
</ul>
<h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><h4 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h4><ul>
<li>实现功能：在浏览器中输入<code>www.123.com</code>跳转到linux系统中tomcat主页面中</li>
<li>首先安装tomcat<ul>
<li>进入tomcat的官网，可以使用wget下载，也可以在windows下载然后使用xftp移动安装包进入<code>opt</code></li>
<li>解压 tar -zxvf 压缩包</li>
<li>启动startup.sh脚本</li>
</ul>
</li>
<li>启用对外访问的端口8080<ul>
<li>firewall-cmd –add-port&#x3D;8080&#x2F;tcp –permanent</li>
<li>firewall-cmd –reload</li>
<li>firewall-cmd –list-all</li>
</ul>
</li>
<li>修改本地的host文件夹：192.168.6.128 <a href="http://www.123.com(这一步是在模拟dns解析过程,让浏览器知道我们应该跳哪)/">www.123.com（这一步是在模拟DNS解析过程，让浏览器知道我们应该跳哪）</a></li>
<li>反向代理配置（proxy_123.conf）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name www<span class="number">.123</span>.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http:<span class="comment">//192.168.6.128:8080;</span></span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们本地测试时用 <code>hosts</code> 模拟 <code>DNS</code>，让浏览器能把域名解析到虚拟机的 <code>IP</code>。上线后就不需要这个步骤，因为 DNS 已经负责把域名解析到服务器公网 IP。浏览器发请求到服务器后，由 Nginx 判断请求路径或域名，转发到对应后端服务（不同端口），然后把返回的结果发回浏览器。这就是路径转发功能</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>java基础八股</title>
    <url>/2025/06/20/java%E5%9F%BA%E7%A1%80%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>抽象类只有方法，没有实现，下面的子类继承父类，并且子类可以有自己的方法，比如Integer、Double包装类继承了Number类，Number类是一个抽象类，只有定义没有实现。如何体现多态？我们可以写父类的方法，但是调用的是不同的子类重写的方法。这就是运行时多态（即“动态绑定”）的典型体现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printValue</span><span class="params">(Number value)</span> &#123;</span><br><span class="line">        System.out.println(value.doubleValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Number</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">3.14</span>);</span><br><span class="line">        printValue(n1);</span><br><span class="line">        printValue(n2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>自动装箱&#x2F;拆箱就是基本数据类型和包装类的转换。</p>
<blockquote>
<p>弊端：如果创建类型不同，会造成GC的负担</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;<span class="number">5000</span> ; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会一直浪费时间装箱拆箱，生成5000个无用的对象，增加了GC的负担。</p>
<h2 id="Java中为什么要有Integer"><a href="#Java中为什么要有Integer" class="headerlink" title="Java中为什么要有Integer"></a>Java中为什么要有Integer</h2><ul>
<li>Integer是int被包装成Object对象，对象封装有很多好处，可以把属性和方法结合在一起；</li>
<li>为了支持泛型和集合框架。在创建集合的时候，集合类只能放对象，比如ArrayList<Integer><blockquote>
<p>java是面向对象语言，很多API只能接受对象</p>
</blockquote>
</Integer></li>
</ul>
<h2 id="什么是集合和泛型？"><a href="#什么是集合和泛型？" class="headerlink" title="什么是集合和泛型？"></a>什么是集合和泛型？</h2><ul>
<li>集合是Java中用来统一存储一组对象的数据结构，比如列表、集合、映射等，属于java.util包<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>List</td>
<td>有序、可重复</td>
<td><code>ArrayList</code>、<code>LinkedList</code></td>
</tr>
<tr>
<td>Set</td>
<td>无序、不可重复</td>
<td><code>HashSet</code>、<code>TreeSet</code></td>
</tr>
<tr>
<td>Map</td>
<td>键值对结构，键不可重复</td>
<td><code>HashMap</code>、<code>TreeMap</code></td>
</tr>
</tbody></table>
</li>
<li>泛型是 Java 提供的一种类型参数化机制，让你在写集合或类的时候不必固定元素类型，而是用占位符 <T> 等代替。</T></li>
</ul>
<h2 id="封装继承多态"><a href="#封装继承多态" class="headerlink" title="封装继承多态"></a>封装继承多态</h2><p>父类引用指向子类对象，调用的方法在运行时根据对象的实际类型动态决定，实现“同一操作不同实现”。</p>
<blockquote>
<p>示例：Person p &#x3D; new Student(); p.getInfo() 实际调用的是 Student 的重写方法。</p>
</blockquote>
<h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><ul>
<li>抽象类是对一类事物的抽象，接口是对能力的抽象。</li>
<li>抽象类可以包含字段、构造方法、普通方法和抽象方法；接口只能包含常量和抽象方法（Java 8+ 允许 default&#x2F;static 方法）。</li>
<li>类只能继承一个抽象类，但可以实现多个接口。</li>
<li>抽象类不能实例化，只能被继承；接口不能实例化，只能被实现。</li>
<li>父类类型变量不能直接调用子类实现的接口方法，除非强制类型转换。<blockquote>
<p>抽象类不能被final修饰，final修饰符用于禁止类被继承或方法被重写，抽象类和final是互斥的。<code>String</code>就有final修饰，保证了String类的不可变性和安全性。final主要用于修饰类，方法，以及对象，保证不可变性。</p>
</blockquote>
</li>
</ul>
<h2 id="引用不可变是什么？"><a href="#引用不可变是什么？" class="headerlink" title="引用不可变是什么？"></a>引用不可变是什么？</h2><ul>
<li>引用指的是创建出来的变量其实<strong>指向了堆内存中的一个对象</strong>，这个变量就是一个引用变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个sb就是一个引用变量，指向了<code>堆内存里一个StringBuilder对象</code>。<ul>
<li>理解sb为一个遥控器</li>
<li>sb指向的对象是电视<br>引用不可变指的是，我这个遥控器只能控制这一台电视，不可以控制别的电视（如下，这是非法的），但是可以更改电视播放的内容，（如sb &#x3D; 123）这是可以的</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sb = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2025/06/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250623144824191.jpg"><br>国际协议没有商业使用，商业上有一套标准，进而再抽象为教学的标准。</p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>有三个目标</p>
<ul>
<li>封装成帧<ul>
<li>信息在链路层的传输中都是靠帧来传输的，最重要的是要确定<code>帧边界</code>，明确哪里是一个完整的帧<ul>
<li>帧定界方法：主要采取“<code>特殊标志法</code>，要处理转义字符，方法是在非帧开始&#x2F;结束的后面添加一个转义字符防止错误定位帧区间。</li>
</ul>
</li>
</ul>
</li>
<li>差错检测<ul>
<li>在信息传输的过程中，很容易数据传输出错，这时需要FCS（Frame Check Sequence）来检测数据是否出错。<ul>
<li>把整个帧的内容（目的地址到数据）使用<code>CRC（循环冗余校验）</code>的算法算出一个32位的校验值</li>
<li>把这个校验值<strong>附加在帧尾</strong>，就是FCS</li>
</ul>
</li>
</ul>
</li>
<li>可靠传输<ul>
<li>停止-等待协议SW</li>
<li>回退N帧协议GBN</li>
<li>选择重传协议SR</li>
</ul>
</li>
</ul>
<h2 id="MAC地址-IP地址-ARP协议"><a href="#MAC地址-IP地址-ARP协议" class="headerlink" title="MAC地址&#x2F;IP地址&#x2F;ARP协议"></a>MAC地址&#x2F;IP地址&#x2F;ARP协议</h2><ul>
<li>MAC地址是以太网的MAC子层所使用的地址</li>
<li>IP地址是TCP&#x2F;IP体系结构网际层所使用的地址</li>
<li>ARP协议属于TCP&#x2F;IP体系结构的网际层<ul>
<li>已知设备的IP地址，使用ARP协议可以通过IP地址获得该设备的MAC地址</li>
</ul>
</li>
</ul>
<ol>
<li>MAC地址<ul>
<li>当多个主机连接在同一个广播信道上，想要实现两个主机之间的通信，则每个主机就要有一个唯一标识（MAC），每个主机发送的<code>帧中必须携带标识发送主机和接收主机的地址</code>，MAC地址有六位，前两位 ： 第一位是目的地址，第二位是源地址，MAC地址属于<code>数据链路层</code></li>
</ul>
</li>
<li>IP地址<br> -IP地址在数据传播的过程中永远不变，从源–&gt;目的地，但MAC地址实现的是转发，所以从一个中转站到另一个中转站要变动。路由器有入网口和出网口，所以有不同的MAC地址。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250624103148403.jpg"></li>
<li>ARP协议<ul>
<li>主机 A 发送 ARP 请求广播：“谁是 192.168.1.5？请告诉我你的 MAC”</li>
<li>主机 B 收到后，回复：“我是 192.168.1.5，我的 MAC 是 xx:xx:xx”</li>
<li>A 将 IP-MAC 对保存到 ARP 缓存中，今后直接使用<blockquote>
<p>APR协议不能跨网络使用，路由器会<code>隔离</code>广播<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250624105553904.jpg"></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><ul>
<li>UDP是<strong>面向无连接</strong>通信协议，速度快，有大小限制，数据不安全，易丢失数据</li>
<li>TCP是<strong>面向连接</strong>通信协议，速度慢，没有大小限制，数据安全</li>
</ul>
<h2 id="BS架构CS架构"><a href="#BS架构CS架构" class="headerlink" title="BS架构CS架构"></a>BS架构CS架构</h2><ul>
<li>Browser&#x2F;Server：浏览器&#x2F;服务器</li>
<li>Client&#x2F;Server：客户端&#x2F;服务器</li>
<li>网络编程三要素：IP、端口、协议<br>使用InetAddress可以获得一个主机的ip</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2025/06/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>UML类图+：public、-：privated、#：default</p>
<h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><ol>
<li>开闭原则<ul>
<li>以前写好的代码不要动了，要想新的方法，就重新写一个</li>
</ul>
</li>
<li>单一职责原则<ul>
<li>一个类最好只干一件事</li>
</ul>
</li>
<li>接口隔离原则<ul>
<li>一个接口不要包含太多能力</li>
</ul>
</li>
</ol>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul>
<li>想象全公司只买得起一台打印机：机器加锁不让私自开（构造器私有），前台登记并保管它（静态实例），谁要打印都向前台借同一台（getInstance）。这样全程只有一台设备，省资源，也避免冲突。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2025/08/05/SpringCloud/</url>
    <content><![CDATA[<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250805193912226.png"></p>
<ul>
<li>下面介绍一个传统服务请求的全过程：<ul>
<li>用户需要通过ip（但因为ip太难记了，所以要买一个域名绑定ip）访问网站；</li>
<li>请求进入Nginx网关，负责<code>负载均衡</code>（如轮询、权重）和流量转发；</li>
<li>发送给部署了相同jar包的服务器，这样实现了高可用高并发；</li>
<li>数据库也可以部署在多台服务器上。<blockquote>
<p>集群就是同一个功能的副本</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250805195231542.png"></p>
<ul>
<li>定义：分布式架构是将一个大型应用的功能拆分为多个小型服务（微服务），分别部署在不同的服务器上，彼此协作完成整个业务流程。</li>
<li>下面介绍大致流程<ul>
<li>原来的大型应用的功能都被拆分成了小模块，可以去部署到同一ip下的不同位置；</li>
<li>不同功能之间想要请求数据时要发一个http请求，获得json数据，就需要<code>远程调用(RPC)</code>;</li>
<li>每个服务都将自己的地址信息注册到注册中心（如Nacos、Eureka），其他服务可通过注册中心获取其地址，实现服务发现与调用；</li>
<li>注册中心也可以<strong>进行客户端或服务端负载均衡；</strong></li>
<li>为了提高系统的稳定性，还会加入服务熔断、限流、降级等机制（如使用 Sentinel、Hystrix）。</li>
</ul>
</li>
<li>如果采用分布式，访问的流程<ul>
<li>先访问域名，请求还是会来到<code>网关</code>，网关会通过注册中心找到请求路由分发到不同的服务器上</li>
<li>如果要微服务：SpringBoot</li>
<li>如果是注册中心、配置中心：Spring Cloud Alibaba Nacos</li>
<li>网关：SpringCloud GateWay</li>
<li>远程调用：Spring Cloud OpenFeign</li>
<li>服务熔断：Spring Cloud Alibaba Sentinel</li>
</ul>
</li>
</ul>
<h2 id="创建SpringCloud-parent项目"><a href="#创建SpringCloud-parent项目" class="headerlink" title="创建SpringCloud parent项目"></a>创建SpringCloud parent项目</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;3.3.4&lt;/version&gt;</span><br><span class="line">		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;/parent&gt;</span><br><span class="line">	&lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">	&lt;groupId&gt;com.explainsf&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;cloud-demo&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">	&lt;name&gt;cloud-demo&lt;/name&gt;</span><br><span class="line">	&lt;description&gt;cloud-demo&lt;/description&gt;</span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;</span><br><span class="line">		&lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;spring-cloud.version&gt;2023.0.3&lt;/spring-cloud.version&gt;</span><br><span class="line">		&lt;spring-cloud-alibaba.version&gt;2023.0.3.2&lt;/spring-cloud-alibaba.version&gt;</span><br><span class="line">	&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">			&lt;/dependency&gt;</span><br><span class="line">		&lt;/dependencies&gt;</span><br><span class="line">	&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">			&lt;/plugin&gt;</span><br><span class="line">		&lt;/plugins&gt;</span><br><span class="line">	&lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>看父子结构，src相当于是写代码的地方，父结构只需要导入依赖，不需要写代码，所以src的都删掉；</li>
<li>架构是cloud-demo -&gt; service -&gt; service-product&amp;&amp;servicie-order<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250805205002579.png"></li>
</ul>
<h2 id="安装nacos-naming-and-configuration-service"><a href="#安装nacos-naming-and-configuration-service" class="headerlink" title="安装nacos(naming and configuration service)"></a>安装nacos(naming and configuration service)</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250805211758920.png"></p>
<ul>
<li>注意配置好JAVA_HOME的路径，说明我变强了哈哈，能看出gpt给出来的东西是错的，明明我知道java 17安装在d盘的，之前一直被gpt忽悠在c盘，难怪配置总是失败。</li>
<li>端口号是8848，还要加上一个&#x2F;nacos</li>
<li>配置管理就是配置中心；服务管理就是注册中心<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250806095633231.png"></li>
<li>体验注册中心，也就是功能来的时候，要去哪个地方访问另一个功能。</li>
</ul>
<h2 id="启动微服务项目"><a href="#启动微服务项目" class="headerlink" title="启动微服务项目"></a>启动微服务项目</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250806102130131.png"></p>
<ul>
<li>为order项目添加springboot web依赖，然后<code>更新maven</code>；</li>
<li>编写好注册类（添加SpringBootApplication注解）以及application.properties来确定端口号及注册中心地址。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-product</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9000</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure>
<h3 id="服务发现（注解：-EnableDiscoveryClient）"><a href="#服务发现（注解：-EnableDiscoveryClient）" class="headerlink" title="服务发现（注解：@EnableDiscoveryClient）"></a>服务发现（注解：@EnableDiscoveryClient）</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250806105400206.png"></p>
<ul>
<li>最重要的就是启动注解@EnableDiscoveryClient，之后应该都能上层封装，可以获取ip，端口号</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>微信小程序开发</title>
    <url>/2025/07/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="微信小程序开发"><a href="#微信小程序开发" class="headerlink" title="微信小程序开发"></a>微信小程序开发</h2><ul>
<li>在传统的网页开发中，网页编程采用的是三件套<code>HTML + CSS +JS</code>，其中<code>HTML</code>描述结构，<code>CSS</code>描述样式，<code>JS</code>用来处理这个页面和用户的交互；</li>
<li>在小程序中，<code>wxml</code>充当类似于<code>html</code>的角色，</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>pages：存放微信小程序的所有页面</li>
<li>.eslintrc.js：格式化代码</li>
<li>app.js：微信小程序的<code>入口文件</code>，用于描述微信小程序的整体逻辑</li>
<li>app.json：微信小程序的全局配置文件，用于设置页面路径、窗口外观、页面表现、标签栏</li>
<li>app.wxss：微信小程序的全局样式文件</li>
<li>project.config.json：微信开发者工具上做的任何配置都会写入这个文件中</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>不需要写后缀名，第一个是默认页面，想要设置分包作为首页可以在app.json添加entryPagePath</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;pages&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pages/log/log&quot;</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<ul>
<li>页面跳转：将函数写在js文件里，在wxml里使用函数绑定</li>
<li>view&lt;hover-class&#x3D;”bold”&gt;可以翻译成触摸时使用bold样式</li>
<li>想要居中，在view后面写一个样式(样式存放于wxss中)，比如</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.<span class="property">center</span>-box&#123;</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>公共样式：其实就是一个公共的css，多个地方</li>
<li>flex布局，可以配合文本居中(justify-content)，还有字体大小font-size（在微信小程序中推荐rpx，可以自适应缩放，px是绝对，不好布局）</li>
<li>flex-direction可以用column，实现列的样式</li>
<li>分包问题，微信首次加载只加载主包，大小不能超过2mb，主包+分包合起来一共不能超过20mb<blockquote>
<p>分包 &#x3D; 延迟加载的页面模块，能有效减小主包体积，让小程序打开更快，更容易上线。</p>
</blockquote>
</li>
</ul>
<h2 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h2><ul>
<li>微信开发者工具其实更像是一个写前端界面的东西，可以通过js进行前端界面的一些内容绑定，比如button可以和bindtap绑定，自定义一个函数，点击跳转到xx页面。</li>
<li>这就是前后端联调的开发模式，使用wx.request调取本地端口，然后就可以去查询本地的数据库信息，最后打包上线。</li>
<li>可以通过生命周期函数（onload、onready）等进行<code>埋点</code>的设计（埋点的意思是在关键地方插入代码，来统计用户的行为，比如用户是否点击分享，是否点击转发等）。</li>
<li>通过<code>数据绑定</code>查询后台数据库，就像是淘宝，京东，只是商品变，大布局不变。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Netty</title>
    <url>/2025/08/11/netty/</url>
    <content><![CDATA[<h2 id="NIO-Non-Blocking-Input-Output"><a href="#NIO-Non-Blocking-Input-Output" class="headerlink" title="NIO(Non-Blocking Input&#x2F;Output)"></a>NIO(Non-Blocking Input&#x2F;Output)</h2><ul>
<li>三大组件</li>
</ul>
<ol>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ol>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250811145104843.png"></p>
<ul>
<li>Selector可以和一个线程合作，可以理解为Selector是摄像头，可以同时监听多个Channel的I&#x2F;O状态，然后交由一个线程去处理这些就绪事件</li>
<li>你可以把 Selector 想成一个 监控中心（摄像头）。</li>
<li>它一直盯着多个 门口（Channel）。</li>
<li>一旦某个门口有人按门铃（I&#x2F;O 就绪），监控中心就通知唯一的值班员（线程）过去处理。</li>
<li>相较于传统的IO而言：<ul>
<li>传统阻塞 I&#x2F;O：一个连接对应一个线程，线程多了就很浪费（上下文切换，CPU核数不够等）。</li>
<li>NIO + Selector：一个线程就能处理成千上万个连接的 I&#x2F;O 事件，大幅减少线程切换和资源占用。</li>
</ul>
</li>
</ul>
<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><ul>
<li>大致有两个部分：Channel（数据来源&#x2F;目标）和 Buffer（数据中转区）。</li>
</ul>
<ol>
<li>初始为写模式，调用 channel.read(buffer) 将数据写入缓冲区。</li>
<li>调用 flip() 切换为读模式（limit &#x3D; position; position &#x3D; 0）。</li>
<li>使用 get() 从缓冲区读取数据。</li>
<li>数据读完后，调用 clear() 切回写模式（position &#x3D; 0; limit &#x3D; capacity），准备下一轮写入。</li>
<li>重复执行，直到通道数据全部读取完毕。</li>
<li>如果缓冲区还有未读数据且需要续读，则用 compact() 代替 clear() 保留剩余数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250811160506801.png"></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>FastAPI</title>
    <url>/2025/09/11/FastAPI/</url>
    <content><![CDATA[<h1 id="Learn-the-FastAPI"><a href="#Learn-the-FastAPI" class="headerlink" title="Learn the FastAPI"></a>Learn the FastAPI</h1><ul>
<li>fastapi是一个web开发框架，目前我个人感觉是比springboot更方便，因为我只下载了python&amp;&amp;pip两个库，就可以很快的启动后端</li>
</ul>
<h1 id="环境创建"><a href="#环境创建" class="headerlink" title="环境创建"></a>环境创建</h1><ol>
<li>先下载python（我下载了3.12），创建一个新文件夹，然后使用<code>VS Code</code>打开这个文件夹，接着调出cmd，在里面先安装好虚拟环境：使用命令python -m venv venv创建，并使用命令venv\Scripts\activate激活虚拟环境。</li>
<li>我们需要的是<code>fastapi</code>以及<code>uvicorn</code>，使用pip install，可以换源，之前我已经换过清华源了，会快一些。</li>
<li>写测试样例：新建py文件test.py</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/add&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;result&quot;</span> : <span class="number">10</span>+<span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/sub&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;result&quot;</span> : <span class="number">10</span>-<span class="number">20</span>&#125;</span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/mul&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;result&quot;</span> : <span class="number">10</span>*<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只需要在终端输入<code>uvicorn test:app --reload</code>或<code>uvicorn test:app --reload</code>就可以启动后端项目，具体看你的路径，这样一次可以启动三个方法。</li>
</ul>
<ol start="4">
<li>接口文档：fastapi有一个非常好的优势，可以自动生成接口文档使用<code>/docs</code>或者<code>/redoc</code>就可以打开</li>
</ol>
<h1 id="项目基础构建"><a href="#项目基础构建" class="headerlink" title="项目基础构建"></a>项目基础构建</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastapi[all]==0.75.2</span><br><span class="line">aioredis==2.0.1</span><br><span class="line">cos-python-sdk-v5==1.9.15</span><br><span class="line">PyJWT==2.3.0</span><br><span class="line">python-dotenv==0.19.1</span><br><span class="line">tortoise-orm[aiomysql]==0.19.0</span><br><span class="line">tencentcloud-sdk-python==3.0.618</span><br><span class="line">wechatpy==2.0.0a11</span><br><span class="line">qrcode[pil]==7.3.1</span><br><span class="line">python-alipay-sdk==3.0.4</span><br><span class="line">passlib==1.7.4</span><br><span class="line">sqlmodel==0.0.6</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Redis复盘</title>
    <url>/2025/09/11/Redis%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<p>为了更深了解Redis，重新学习一次黑马点评，从原理到实现。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>一种非关系型数据库(NoSQL)、里面都是键值对(key-value)的存储形式，不过value可以使用一个json</li>
<li>是一种<code>非结构化</code>、<code>存储在内存（因此速度快）</code>的数据库</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存，IO多路复用，良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群</li>
<li>基本的数据结构类型有五种：String、Hash、List、Set、ZSet(SortedSet)</li>
</ul>
<h1 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h1><ul>
<li>keys：查找关键词（不要在生产环境用这个，redis是单线程的，会阻塞其他任务） keys *(*是通配符，查所有)</li>
<li>del：删除一个key</li>
<li>exists：判断是否存在 （语法：exists key）</li>
<li>expire：给key设置有效期，有效期到期后这个key自动删除（因为redis是使用内存的，不能无限制往里面加）</li>
<li>ttl：查看一个key的生存时间</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li>底层是使用字节存储的，不同的数据类型采用不同的编码，如果存数字，就用字节，如果存字符串，就存编码，甚至可以存图，最大不能存超过512M</li>
</ul>
<h2 id="Key层级"><a href="#Key层级" class="headerlink" title="Key层级"></a>Key层级</h2><ul>
<li>可以使用set heima:user:id</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul>
<li>Hash是一个类似于Map&lt;String,Map&lt;String,String&gt;&gt;的结构，其中有开始的关键词key作为键，然后有一个filed和value一起作为值，这样就可以让一个key有多个value</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>底层是一个链表，可以LPUSH和RPUSH，想象逐个插入，比如LPUSH 1，2，3，4，5，出来的结果应该是5 4 3 2 1，类似于头插法，RPUSH同理<ul>
<li>如何用List模拟一个栈？LPUSH&amp;&amp;LPOP</li>
<li>如何用List模拟一个队列？LPUSH&amp;&amp;RPOP || RPUSH&amp;&amp;LPOP</li>
<li>如何用List模拟一个阻塞队列？使用BLPOP&#x2F;BRPOP替换上面的队列 BLPOP和BRPOP在没有元素的时候等待指定时间，而不是直接返回null</li>
</ul>
</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li>set是集合，去重，唯一；可以用来求交集、并集、差集，来判断是不是好友，还能查看一个好友是不是自己的好友(sismember)</li>
</ul>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><ul>
<li>zset中每一个元素都带有一个score属性，可以基于score属性对元素排序，底层是一个跳表(SkipList)加哈希表，具备以下特征，经常用来做排行榜。<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快<br>可以使用incrby，range，rank查询排名</li>
</ul>
</li>
</ul>
<h1 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul>
<li>使用session登录，session可以使用<code>session.setAttribute(parama)</code>很方便</li>
<li>短信验证功能：使用session存储code</li>
<li>实现收发功能：调用sendCode，去IUserService这个接口里实现类</li>
<li>使用Mybatis-plus的save去生成未注册的用户</li>
<li>使用类为Object的cacheCode与DTO里的Code进行比较，相同的话</li>
<li><strong>登陆验证功能</strong>使用ThreadLocal作为拦截器对象，这样我们客户端发送请求，先在拦截器里完成鉴权，然后再将请求发送给不同的接口，去实现一个Interceptor类，然后实现HandlerInterceptor接口</li>
<li>优化，登录的时候我们直接传了User对象，这个对象里面有很多敏感信息，我们就使用BeanUtil里的copyProperties拷贝给UserDTO，这样就可以把信息传递给DTO，这样很多函数传参的时候也只传给DTO版本而不是完完整整的User版本</li>
<li>基于Redis实现共享session登录：因为后期如果要部署到集群上，nginx会把请求转发到不同的服务器上，这些服务器之间不共享session，这时候就需要缓存，redis是一种key-value的数据库，我们每时每刻会发送许多的请求到内存，要保证唯一性，那就使用key token+value：code来实现存储</li>
<li>转换变量的时候使用BeanUtil工具包来，想复制就是copyProperties，想要转换成map就是beanToMap</li>
<li>本来使用session的都是用stringRedisTemplate去操作，这样又可以实现什么时候token失效，然后如果续期的话，就去拦截器里续期！</li>
<li>获得请求头就是用request.getHeader()</li>
<li>DEBUG了十万年，传错了tokenKey</li>
<li>双拦截器的好处：单拦截器的时候只拦截了登录请求，但是如果用户一直没去点登录请求，redis就不会去刷新有效期，所以我们再设置一个拦截一切路径的拦截器，这样子就可以每点击或者刷新一次，都能重新更新TTL</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul>
<li>ThreadLocal 不是“线程”，而是一个 线程本地变量工具类。它的作用是：<ul>
<li>每个线程都有一个独立的副本，互不影响。</li>
<li>用来保存某些需要在同一个线程内共享，<strong>但又不能被其他线程访问的数据</strong>。</li>
<li>在我们点击一些商品链接的时候，如果我们没有登陆，是不是就被拦截了，有一些商品信息能直接查看详情，就说明放行了</li>
</ul>
</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul>
<li>缓存的逻辑是这样的：一个查询过来的时候，先查缓存，如果缓存里面没有再去查数据库，如果数据库里也没有，就返回错误；如果数据库里有，就写入缓存(opsForValue().set(key,value))，然后返回商铺信息就可以；redis里面的数据一般都是json格式，可以使用JSONUtil.toBean反序列化为shop对象；也可以反过来使用StrUtil.toJsonStr序列化成json格式。</li>
</ul>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><ol>
<li>对于低一致性需求：使用Redis自带的内存淘汰机制</li>
<li>对于高一致性需求：主动更新并以超时剔除作为兜底方案</li>
</ol>
<ul>
<li>读操作<ul>
<li>缓存命中直接返回</li>
<li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作<ul>
<li>先写数据库，再删除缓存</li>
<li>要确保数据与缓存操作的原子性</li>
</ul>
</li>
<li>主动更新(Cache Aside)<ul>
<li>先删除缓存，再操作数据库</li>
<li>先操作数据库，再删除缓存 这个好一点</li>
</ul>
</li>
</ul>
<h3 id="缓存三大问题"><a href="#缓存三大问题" class="headerlink" title="缓存三大问题"></a>缓存三大问题</h3><ul>
<li>雪崩、击穿、穿透<ul>
<li>击穿有两种解决方式：逻辑过期、互斥锁</li>
<li>雪崩加上随机时间TTL</li>
<li>穿透缓存空值&#x2F;布隆过滤器</li>
</ul>
</li>
<li>互斥锁：可以使用setnx来实现，setnx当且仅在key不存在的时候才能成功创建，如果key存在的话是不能更改值的，所以有多个线程来访问的时候，只有第一个线程能够修改值</li>
<li>QPS(query per seconds)可以用jmeter来查</li>
</ul>
<h2 id="优惠券"><a href="#优惠券" class="headerlink" title="优惠券"></a>优惠券</h2><ul>
<li>优惠券秒杀，每一张优惠券需要有一个唯一的全局id，但是这个id不能是自增的太明显的，所以必须要进行一些拼凑 1 + 31 + 32；首位是0，中间31位是时间，可以用69年，最后32就是每秒生成2的32次方个优惠券</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试补充知识点</title>
    <url>/2025/08/19/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="HashMap-的底层原理以及如何扩容？"><a href="#HashMap-的底层原理以及如何扩容？" class="headerlink" title="HashMap 的底层原理以及如何扩容？"></a>HashMap 的底层原理以及如何扩容？</h1><ul>
<li>HashMap 由 <strong>数组 + 链表 + 红黑树</strong> 构成</li>
<li>初始大小为 <strong>16</strong>，通过哈希策略将数据分布到不同的桶中</li>
<li>扩容机制：<ul>
<li>当数组长度小于 64 时，扩容并且会 <strong>Rehash</strong></li>
<li>当数组长度大于等于 64 且链表长度超过 8 时，链表转为 <strong>红黑树</strong>，查询复杂度从 O(n) 变为 O(logN)</li>
<li>扩容时数组大小翻倍（*2），<strong>装载因子</strong>默认为 0.75，可自定义</li>
</ul>
</li>
</ul>
<h1 id="Redis-的穿透、击穿、雪崩"><a href="#Redis-的穿透、击穿、雪崩" class="headerlink" title="Redis 的穿透、击穿、雪崩"></a>Redis 的穿透、击穿、雪崩</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li><strong>现象</strong>：客户端访问不存在的数据，缓存和数据库均未命中，大量请求直达数据库，导致负载过大甚至宕机  </li>
<li><strong>原因</strong>：<ul>
<li>业务层误删缓存和数据库的数据</li>
<li>恶意请求不存在的数据</li>
</ul>
</li>
<li><strong>解决方案</strong>：<ol>
<li>未命中时将空值写入缓存，下次请求直接返回空值  </li>
<li>使用 <strong>布隆过滤器</strong>拦截不存在的请求</li>
</ol>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><ul>
<li><strong>现象</strong>：某个热点数据在缓存失效的瞬间，大量并发请求直达数据库，导致服务崩溃  </li>
<li><strong>解决方案</strong>：<ol>
<li>对热点数据设置 <strong>永不过期</strong>  </li>
<li>使用 <strong>互斥锁</strong>，一个线程重建缓存，其他线程等待</li>
</ol>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ul>
<li><strong>现象</strong>：大量缓存同时过期，或 Redis 节点故障，导致所有请求直达数据库，造成数据库宕机  </li>
<li><strong>解决方案</strong>：<ol>
<li>避免同时过期，设置 <strong>随机过期时间</strong>  </li>
<li>启用 <strong>降级和熔断</strong>措施  </li>
<li>热点数据设置 <strong>永不过期</strong>  </li>
<li>使用 <strong>Redis 集群</strong>，单点宕机时仍有节点可用</li>
</ol>
</li>
</ul>
<h1 id="创建线程的方法？"><a href="#创建线程的方法？" class="headerlink" title="创建线程的方法？"></a>创建线程的方法？</h1><ol>
<li>继承Thread类，重写run()方法；</li>
<li>实现Runnable接口，实现run()方法；</li>
<li>实现Callable接口，实现call方法；</li>
<li>线程池创建。</li>
</ol>
<h1 id="Spring-SpringBoot怎么理解"><a href="#Spring-SpringBoot怎么理解" class="headerlink" title="Spring&#x2F;SpringBoot怎么理解"></a>Spring&#x2F;SpringBoot怎么理解</h1><ul>
<li>其实Spring就是一个管理类的容器，我们通过注解将我们定义好的类添加到Spring容器里，在我们需要的时候就是用注解从Spring容器里拿出之前定义好的类，可以理解为Spring就是一个Map结构，K是类名，V是类，取出来类后就可以调用类的方法了。</li>
<li>存进银行的注解：@Component，@Component可以细化为这三个：@Service@Controller@Repository</li>
<li>从银行取出来的注解：@Resource@Autowired</li>
</ul>
<h1 id="单点登录和鉴权"><a href="#单点登录和鉴权" class="headerlink" title="单点登录和鉴权"></a>单点登录和鉴权</h1><ul>
<li>可以使用SpringSecurity进行鉴权的判断，当用户第一次登陆的时候，就去数据库查询该用户的权限并封装成token，这样之后每一个请求都会去token判断用户的类型进而判断是否放行。</li>
</ul>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul>
<li>其实消息队列就是一个Map，然后用List存取很多个Map，当生产数据的时候，就把他存进List，消费数据的时候，就是用get()，然后remove掉；</li>
</ul>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><ul>
<li>docker是一个容器，我们之前部署上线的时候是把项目生成一个jar包，然后上Linux服务器启动这个jar包，但是我们可能还需要redis，mysql等一系列的东西，如果有多台服务器，安装就很麻烦；</li>
<li>于是我们使用docker把jar包、mysql、redis、nginx、jdk17全部打包成一个镜像，然后把这个镜像上传到linux上，这样linux只需要安装一个docker，然后docker run就可以运行了。</li>
<li>但是镜像过多，所以出现了k8s去管理镜像。</li>
</ul>
<h1 id="索引失效的场景有哪些？"><a href="#索引失效的场景有哪些？" class="headerlink" title="索引失效的场景有哪些？"></a>索引失效的场景有哪些？</h1><ul>
<li>使用左或者左右模糊匹配的时候，<code>like %超 /like %超%</code></li>
<li>对索引使用函数：where length(name)&#x3D;6，这样就没有走原来定义好的name了</li>
<li>对索引进行表达式计算：where id+1&#x3D;10</li>
<li>联合索引非最左</li>
<li>where的or条件前语句是索引列后语句不是where id &#x3D; 1 or age &#x3D; 2;id是索引但是age不是就不会走。</li>
</ul>
<h1 id="线程池参数该如何设置？"><a href="#线程池参数该如何设置？" class="headerlink" title="线程池参数该如何设置？"></a>线程池参数该如何设置？</h1><ul>
<li>如果是IO密集型，线程的大部分时间都花在了IO上，就会导致CPU利用率低，所以我们需要多开线程让cpu运作起来，一般是2*核心数</li>
<li>如果是计算密集型，大部分线程都在处理计算任务，不会频繁进行上下文切换，所以设置为核心数+1即可</li>
</ul>
<h1 id="hashCode和equals方法有什么关系？"><a href="#hashCode和equals方法有什么关系？" class="headerlink" title="hashCode和equals方法有什么关系？"></a>hashCode和equals方法有什么关系？</h1><ul>
<li>如果两个对象相等，那他们equals和hashCode的返回值都相等</li>
<li>但如果两个对象的hashCode返回值相同，两个对象不一定相同</li>
<li>所以重写equals方法的时候一定要重写hashCode方法，以保证在使用hash等数据结构的时候能正常工作</li>
</ul>
<h1 id="如何使用Spring实现事务？"><a href="#如何使用Spring实现事务？" class="headerlink" title="如何使用Spring实现事务？"></a>如何使用Spring实现事务？</h1><ul>
<li>事务四大原则ACID：原子、隔离、持久、一致</li>
<li>使用注解@Transactional</li>
<li>@Transactional失效的场景有哪些？<ul>
<li>方法不是public：Spring默认基于代理，只有public方法才会被代理拦截</li>
<li>方法内部调用，不会经过代理对象</li>
<li>final&#x2F;static方法</li>
<li>异常没有抛出</li>
<li>多线程调用，因为新线程不会继承老线程的上下文</li>
</ul>
</li>
</ul>
<h1 id="Cookie和Session有什么区别？"><a href="#Cookie和Session有什么区别？" class="headerlink" title="Cookie和Session有什么区别？"></a>Cookie和Session有什么区别？</h1><ul>
<li>cookie和session都是用来跟踪用户状态的，不同的是cookie存在客户端，session存在用户端</li>
<li>cookie容易被篡改，session相对安全</li>
<li>cookie一般有大小限制，限制为4kb，session没有，但是会占用服务器内存；<blockquote>
<p>在分布式系统下，很多网站会使用jwt，token+redis进行登录。</p>
</blockquote>
</li>
</ul>
<h1 id="过滤器和拦截器有什么区别？"><a href="#过滤器和拦截器有什么区别？" class="headerlink" title="过滤器和拦截器有什么区别？"></a>过滤器和拦截器有什么区别？</h1><ul>
<li>过滤器(Filter)只能拿到<code>HttpServletResponse</code>以及<code>HttpServletRequest</code>,不知道调用的是哪一个Controller</li>
<li>拦截器能精准的拦截到某一个Controller<blockquote>
<p>过滤器通常用于统一编码处理，日志打印；而拦截器用来做登录校验，权限校验。</p>
</blockquote>
</li>
</ul>
<h1 id="HashMap和ConcurrentHashMap有什么区别？后者如何保证线程安全？"><a href="#HashMap和ConcurrentHashMap有什么区别？后者如何保证线程安全？" class="headerlink" title="HashMap和ConcurrentHashMap有什么区别？后者如何保证线程安全？"></a>HashMap和ConcurrentHashMap有什么区别？后者如何保证线程安全？</h1><ul>
<li>HashMap是非线程安全的，多个线程同时写有可能会导致数据不一致；ConcurrentHashMap是线程安全的，通过<code>CAS+synchronized</code>来保证线程安全，在<strong>链表&#x2F;红黑树的节点级别</strong>加锁，实现更细粒度的并发控制，提高性能。</li>
<li>不用Hashtable的原因是Hashtable粗暴的给整个表加锁；常见的原子方法有computeIfAbsent</li>
</ul>
<h1 id="什么是数据库事务？其四大特性-ACID-是什么？"><a href="#什么是数据库事务？其四大特性-ACID-是什么？" class="headerlink" title="什么是数据库事务？其四大特性(ACID)是什么？"></a>什么是数据库事务？其四大特性(ACID)是什么？</h1><ul>
<li>数据库事务就是把一组数据库操作当作一个整体，要么全部成功，要么全部失败</li>
<li>原子性、隔离性、持久性、一致性</li>
<li>隔离级别是读未提交、读提交、可重复读、串行化</li>
</ul>
<h1 id="String-StringBuilder-StringBuffer有什么区别"><a href="#String-StringBuilder-StringBuffer有什么区别" class="headerlink" title="String\StringBuilder\StringBuffer有什么区别"></a>String\StringBuilder\StringBuffer有什么区别</h1><ul>
<li>他们三个都是处理字符串的类</li>
<li>String不可变，StringBuilder和StringBuffer可变</li>
<li>但StringBuilder不是线程安全的，StringBuffer带synchronized，线程安全<blockquote>
<p>如果需要线程安全的可变字符串，才会考虑StringBuffer</p>
</blockquote>
</li>
</ul>
<h1 id="HashMap的数据结构，put流程，以及发生hash冲突的解决方法，为什么是红黑树而不是二叉树"><a href="#HashMap的数据结构，put流程，以及发生hash冲突的解决方法，为什么是红黑树而不是二叉树" class="headerlink" title="HashMap的数据结构，put流程，以及发生hash冲突的解决方法，为什么是红黑树而不是二叉树"></a>HashMap的数据结构，put流程，以及发生hash冲突的解决方法，为什么是红黑树而不是二叉树</h1><ul>
<li>HashMap的底层是<code>数组+链表+红黑树</code>，当链表长度过长(超过8)转为红黑树</li>
<li>put流程<ul>
<li>先根据key的hashCode进行hash运算确定下标</li>
<li>如果该位置为空直接放进去</li>
<li>如果不为空，比较key，如果相同就覆盖掉，不同就挂在链表&#x2F;红黑树上</li>
<li>插入后若超出阈值(0.75)会触发扩容</li>
</ul>
</li>
<li>如果使用二叉树有可能会退化成链表，最坏的查询复杂度是O(n)，而红黑树是<strong>自平衡二叉搜索树</strong>，删改查的复杂度为O(n*logn)</li>
</ul>
<h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><ul>
<li>全局锁：对整个表加锁，变为只读状态&#x2F;可以在开始备份的时候创建一个Read View</li>
<li>表级锁：<ul>
<li>表锁<ul>
<li>表读锁：多个线程可以同时读，但不能写</li>
<li>表写锁：只有持锁线程可以读写，其他线程的读写都会被阻塞</li>
</ul>
</li>
<li>意向锁</li>
</ul>
</li>
</ul>
<h1 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h1><ul>
<li>Synchronized是关键字，ReentrantLock是类，需要手动lock(),unlock();</li>
<li>都是可重入锁，同一个线程可以反复去获得锁</li>
<li>synchronized自动获取、自动释放、不可中断，非公平</li>
<li>ReentrantLock可中断、可以尝试去获得锁、提供Condition对象实现多条件等待&#x2F;通知</li>
<li>ReentrantLock默认构造的是非公平锁，获取锁的时候会直接尝试CAS抢占；如果使用构造<code>ReentrantLock relock = new ReentrantLock(true);</code>就是公平锁，会按照锁的请求顺序(FIFO)，底层是AQS（AbstractQueuedSynchronizer）维护了一个队列，获取锁的时候会先去看队列是否有线程，如果有的话就排队，没有就获取锁。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>React</title>
    <url>/2025/11/24/React/</url>
    <content><![CDATA[<h1 id="React的基础api"><a href="#React的基础api" class="headerlink" title="React的基础api"></a>React的基础api</h1><ul>
<li>React.createElement() <ul>
<li>作用：用来创建一个React元素</li>
<li>参数：<ol>
<li>参数的名称 button&#x2F;div&#x2F;p(<strong>html标签必须小写</strong>)</li>
<li>标签中的属性<ul>
<li>class属性需要使用className来设置</li>
<li>在设置事件时，属性名修改需要驼峰命名法</li>
</ul>
</li>
<li>元素的内容（子元素）</li>
</ol>
</li>
<li>注意点<ul>
<li>React元素最终会通过虚拟DOM转换为真实DOM元素</li>
<li>React元素一经创建就无法修改，只能通过<strong>新创建的元素进行替换</strong></li>
</ul>
</li>
</ul>
</li>
<li>ReactDOM.createRoot() 操作dom，将要挂载的dom转为React对象</li>
<li>root.render()<ul>
<li>用来将React元素渲染到根元素上</li>
<li>根元素中所有内容都会被删除，被React元素替换</li>
<li>当重复调用render()时，React会将两次渲染的结果对比(diff)，它会确保只修改那些变化的元素，对DOM做最少的操作</li>
</ul>
</li>
<li>事件命名</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;你干嘛&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">id</span>:<span class="string">&#x27;btn&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;button&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>事件</strong>需要<strong>驼峰命名法</strong>，并且要写成函数的形式</p>
<h1 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h1><ul>
<li>要使用jsx有两步<ul>
<li>引入babel</li>
<li>将script type设置为text&#x2F;babel</li>
</ul>
</li>
<li>jsx就是js的扩展，可以把html和js混合在一起写，比如jsx就是React.createElement()的语法糖</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>我是一个大按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意事项<ul>
<li>jsx中的html标签要小写，React组件应该大写开头</li>
<li>jsx中有且仅有一个根标签，且标签必须要正确结束</li>
<li>在jsx中可以使用{}嵌入表达式(有值的就是表达式：{1+1},{name})</li>
<li><h2 id="在jsx中，属性可以直接在标签里面设置"><a href="#在jsx中，属性可以直接在标签里面设置" class="headerlink" title="在jsx中，属性可以直接在标签里面设置"></a>在jsx中，属性可以直接在标签里面设置</h2>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;alert(&#x27;哈喽google&#x27;)&#125;&#125;&gt;我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>style必须传对象设置：</li>
</ul>
  <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">style&#123;&#123;<span class="attr">backgroundColor</span>:<span class="string">&#x27;yello&#x27;</span>,<span class="attr">border</span>:<span class="string">&#x27;10px red solid&#x27;</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h1><p>比如我们有一个数组num &#x3D; [1,2,3,4,5,6],想要让它成为ul里的列表，其实每一个就是</p>
<ul>
<li>想要渲染列表，所以我们可以调用数组中的map方法，map方法就是重新创建一个新数组，让新数组重新赋值为</li><li>{item}</li>，num.map(item&#x3D;&gt;<li>{item}</li>)
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">arr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">item</span>=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>)</span><br><span class="line"><span class="keyword">const</span> list = <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">root.<span class="title function_">render</span>(list)</span><br></pre></td></tr></table></figure>
<h1 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h1><ul>
<li>在React我们操作的元素被称为React元素，并不是真正的原生DOM，React通过虚拟DOM 将React元素 和 原生DOM，进行映射，虽然操作的React元素，但是这些操作操作最终都会真实DOM中体现<ul>
<li>好处有以下三点：<ol>
<li>降低API复杂度</li>
<li>解决兼容问题</li>
<li>提升性能（减少DOM的不必要操作）</li>
</ol>
</li>
<li>每当我们调用root.render(),页面就会发生重新渲染，React通过diffing算法，将新的元素和旧的元素进行比较，并且只对变化的元素进行修改，没有变化的不去修改</li>
<li>每一个item都需要有一个key，相当于是key-value的形式，如果数组现在是[1,2,3],我想添加一个[4,1,2,3]，虽然看起来只添加了一个元素，但是其实后面三个的顺序都改变了，如果没有key就会造成性能问题，因此我们需要给每一个item都添加一个key，可以就是他们本身，这样diff算法在比对的时候就知道该如何高性能修改了。</li>
<li>注意：开发中一般会采用数据的id作为key，尽量不要使用index作为key，因为你添加了一个元素在数组中，这个元素后面的所有索引也会被改变。<strong>用稳定、不重复的 id，比如数据库里的主键。</strong></li>
</ul>
</li>
</ul>
<h1 id="创建React项目"><a href="#创建React项目" class="headerlink" title="创建React项目"></a>创建React项目</h1><ul>
<li>使用React脚手架</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>前端知识补全</title>
    <url>/2026/01/29/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%A8/</url>
    <content><![CDATA[<h1 id="前端知识"><a href="#前端知识" class="headerlink" title="前端知识"></a>前端知识</h1><ul>
<li>接下来的内容会是我 <strong>面试</strong> &#x2F; <strong>遇到</strong> 不会的点，或者是掌握得不清楚的点，我会尽可能将整个流程写明白，让我自己能跑通整个流程。</li>
</ul>
<h2 id="浏览器的同源策略？"><a href="#浏览器的同源策略？" class="headerlink" title="浏览器的同源策略？"></a>浏览器的同源策略？</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><ul>
<li>当我们写好一个后端程序和前端程序的时候，前端向后端发送请求，提示CORS未通过，这通常是浏览器的同源策略导致的。</li>
<li>同源策略是浏览器对<strong>跨源读写</strong>的限制，例子：js不能读另一个源的响应内容。</li>
<li>链路：浏览器先执行同源策略 – 如果跨源，则需要带上CORS响应头显式访问 – 否则浏览器拦截<blockquote>
<p>同源策略是拦截策略，而CORS是服务器给浏览器的许可证明</p>
</blockquote>
</li>
</ul>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><ul>
<li>这是为了防止Web里的跨源攻击，运行在某个 origin 下的脚本，不能读取其他 origin 的存储（localStorage&#x2F;cookie&#x2F;DOM）和响应内容；哪怕这些请求是用户本人在同一个浏览器里触发的。</li>
</ul>
<h3 id="How"><a href="#How" class="headerlink" title="How"></a>How</h3><ul>
<li>服务端通过 CORS 配置决定向哪些 Origin 返回允许头；若未允许，浏览器会拦截前端 JS 读取响应（即使请求到达并拿到 200）。</li>
<li>校验三大部分：协议、主机名、端口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        config.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:5173&quot;</span>));</span><br><span class="line">        config.setAllowedMethods(List.of(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        config.setAllowedHeaders(List.of(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        config.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="XSS攻击？"><a href="#XSS攻击？" class="headerlink" title="XSS攻击？"></a>XSS攻击？</h2><h3 id="What-1"><a href="#What-1" class="headerlink" title="What"></a>What</h3><ul>
<li>XSS攻击是用户将一段脚本(js)代码伪装成评论插入到系统里，当别人展开评论的时候，这段脚本会在网站里执行（因为当你展开评论的时候，浏览器把用户输入当 HTML 解析，前端可能会将评论使用innerHTML插入进到页面里，脚本被执行）<ul>
<li>用户可能会看到奇奇怪怪的弹窗或者跳转到别的页面</li>
<li>账号被莫名改资料</li>
</ul>
</li>
<li>如果你是权限比较高的用户，执行了恶意脚本，很可能就会让系统崩溃。</li>
</ul>
<h3 id="How-to-prevent"><a href="#How-to-prevent" class="headerlink" title="How to prevent"></a>How to prevent</h3><ul>
<li><strong>核心原则</strong>：<strong>永远不要把用户的输入当成HTML渲染</strong><ul>
<li>React默认渲染字符串是转义的，{content}</li>
<li>坑：如果为了支持富文本(图片，代码，换行)使用了dangerouslySetInnerHTML，这样就会插入脚本。</li>
</ul>
</li>
<li>解决方法：<ol>
<li>输出编码要默认转义，用纯文本来渲染，不允许用html</li>
<li>白名单清洗：如果必须要富文本，过滤掉事件脚本，事件属性，危险的url结构</li>
<li>token尽量不要放在localstorage里，可以放在HttpOnly cookie，这样js读不到cookie</li>
<li>设置SameSite，有三种模式，strict，lax以及none，分别控制跨站是否自动带上cookie</li>
</ol>
</li>
<li>解决markdown富文本的XSS攻击策略<ol>
<li>设置白名单，只允许我们可以的标签，比如p，a，strong，code等，对属性也要白名单，禁止所有的事件属性，比如on*</li>
<li>禁止inline script</li>
<li>代码块永远escape(转义)后放进code和pre里展示</li>
</ol>
</li>
</ul>
<h2 id="JWT更安全的登录？双Token"><a href="#JWT更安全的登录？双Token" class="headerlink" title="JWT更安全的登录？双Token"></a>JWT更安全的登录？双Token</h2><h3 id="What-2"><a href="#What-2" class="headerlink" title="What"></a>What</h3><ul>
<li>我发现了原来的逻辑是改Localstorage就可以让前端渲染出管理员的界面，这样不行</li>
<li>于是引入了JWT的accessToken以及refreshToken<ul>
<li>accessToken一般时间短，15-30分钟，存放在React的内存里，一刷新就没有</li>
<li>refreshToken时间在7-30天，存放在httponly的cookie里</li>
<li>此外这个refreshToken还存放在了redis里，使用版本号控制，让非法用户强制下线</li>
</ul>
</li>
</ul>
<h3 id="How-1"><a href="#How-1" class="headerlink" title="How"></a>How</h3><h4 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h4><ul>
<li>用户首次登陆的时候后端校验账户和密码是否合法，如果合法就签发两个token</li>
<li>access token 过期 → 前端请求业务接口返回 401</li>
<li>前端调用 &#x2F;api&#x2F;v1&#x2F;auth&#x2F;refresh（不带 refresh token，浏览器会自动附带 HttpOnly Cookie）</li>
<li>后端从 Cookie 里拿 refresh token，去 Redis 校验是否存在&#x2F;是否有效</li>
<li>校验通过 → 生成新 access token（和新的 refresh token），并在 Redis 里更新</li>
<li>返回新的 access token 给前端，继续请求<blockquote>
<p>来回时间就是一个rtt</p>
</blockquote>
</li>
</ul>
<h4 id="踢人功能"><a href="#踢人功能" class="headerlink" title="踢人功能"></a>踢人功能</h4><ul>
<li>在redis里添加tokenVersion，因为我们登陆的时候用户还是有当前的accessToken，所以他还能存活这么久<ul>
<li>加一个<code>user:tokenVersion:&lt;uid&gt;</code>在redis里，签发的时候把ver写进JWT，</li>
<li>踢人就增加版本号，这样让他的所有旧accessToken失效。原因是我们的在redis里的逻辑是 <code>user:tokenVersion:&lt;uid&gt; = N</code>，拦截器校验时比较Redis ver，如果不一致就401</li>
</ul>
</li>
</ul>
<h2 id="浏览器的事件循环机制是什么？"><a href="#浏览器的事件循环机制是什么？" class="headerlink" title="浏览器的事件循环机制是什么？"></a>浏览器的事件循环机制是什么？</h2><h3 id="What-3"><a href="#What-3" class="headerlink" title="What"></a>What</h3><ul>
<li>事件循环是浏览器在单线程上运行 JS 的调度机制：把“同步 JS 执行”与“外部事件&#x2F;异步结果（定时器、网络、交互等）”通过任务队列串起来，循环取任务执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会打印2，1。是因为这一段script是一个宏任务，然后setTimeout先是注册了一个定时器任务，把这个回调函数log1放到了宏任务队列里，就到微任务，微任务将这一段script的宏任务收尾，所以先log，然后清空了微任务之后。script 这个宏任务已经执行完了；之后从宏任务队列里取的是 定时器回调这个新的宏任务。</p>
</blockquote>
<h3 id="Why-1"><a href="#Why-1" class="headerlink" title="Why"></a>Why</h3><ul>
<li>js是单线程的，同一时间只能做一件事，避免多线程共享DOM带来的竞态</li>
<li>让页面响应可控，长任务不会永远占住</li>
</ul>
<h3 id="How-2"><a href="#How-2" class="headerlink" title="How"></a>How</h3><ul>
<li>“执行一个宏任务 → 然后清空微任务队列 →（必要时渲染）→ 下一轮宏任务”。</li>
<li>执行的顺序<ul>
<li>宏任务：定时器(setTimeout,setInterval)回调、点击回调、整段Script</li>
<li>微任务：<code>Promise.then、catch/finally</code>用于“本轮宏任务的收尾&#x2F;延续”</li>
</ul>
</li>
<li>如果浏览器一直执行宏任务？<ul>
<li>问题：理论上来说因为是单线程，宏任务如果一直不返回（同步死循环&#x2F;超长计算），浏览器确实会一直卡在这个宏任务里。</li>
<li>解决方法<ul>
<li>把大任务分成多个短任务</li>
<li>时间分片</li>
<li>给Worker</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="节流和防抖有什么区别？"><a href="#节流和防抖有什么区别？" class="headerlink" title="节流和防抖有什么区别？"></a>节流和防抖有什么区别？</h2><h3 id="What-4"><a href="#What-4" class="headerlink" title="What"></a>What</h3><ul>
<li>防抖(debounce)：在连续触发中不断重置计时器，停止触发一段时间后才执行一次（“取最后一次”）。</li>
<li>节流(throttle)：在连续触发中按固定间隔执行，单位时间最多执行一次（“限速”）。</li>
</ul>
<h3 id="How-3"><a href="#How-3" class="headerlink" title="How"></a>How</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn,wait = <span class="number">300</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)&#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,wait = <span class="number">200</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">        <span class="keyword">if</span> (now - last &gt;= wait) &#123;</span><br><span class="line">            last = now</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Why-2"><a href="#Why-2" class="headerlink" title="Why"></a>Why</h3><ul>
<li>防抖：解决“抖动触发导致的重复计算&#x2F;重复请求”，减少无效开销（如输入联想、频繁点击）。</li>
<li>节流：解决“持续高频触发导致的性能压力&#x2F;掉帧”，让回调执行频率可控（如滚动、鼠标移动、拖拽）。<blockquote>
<p>为什么要return function，因为function是一个函数，需要返回值，这里的返回值就是一个函数</p>
</blockquote>
</li>
</ul>
<h2 id="遍历找到D盘的两个重复文件？"><a href="#遍历找到D盘的两个重复文件？" class="headerlink" title="遍历找到D盘的两个重复文件？"></a>遍历找到D盘的两个重复文件？</h2><h3 id="How-4"><a href="#How-4" class="headerlink" title="How"></a>How</h3><ul>
<li>文件夹有递归嵌套的结构，每一个文件夹就像是树一样，遍历树就使用DFS&#x2F;BFS&#x2F;递归</li>
<li>构建 Map&lt;size, filePaths[]&gt;，只保留 filePaths.length &gt;&#x3D; 2 的桶作为候选（不同 size 必不相同）。</li>
<li>对候选文件用流式读取计算内容 hash（如 SHA-256&#x2F;BLAKE3），构建 Map&lt;hash, filePaths[]&gt;；同一 hash 下的文件认为“高度可能相同”。</li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><h3 id="What-5"><a href="#What-5" class="headerlink" title="What"></a>What</h3><ul>
<li>浅拷贝：只复制一层属性；若属性值是<code>对象/数组/函数</code>等引用类型，复制的是引用，因此会共享同一份深层数据。</li>
<li>深拷贝：递归复制各层级，让嵌套对象&#x2F;数组变成新的引用，通常不共享深层引用。<blockquote>
<p>Object.create 不是拷贝，是“以某对象作为原型”创建新对象。</p>
</blockquote>
</li>
</ul>
<h3 id="Why-3"><a href="#Why-3" class="headerlink" title="Why"></a>Why</h3><ul>
<li>React&#x2F;Redux 等依赖<code>不可变更新 + 浅比较（===）</code>做渲染与 memo 判断：你只需要“沿修改路径拷贝”（结构共享），而不是全量深拷贝。</li>
<li>全量深拷贝会带来：CPU&#x2F;内存开销、GC 压力、缓存失效（引用每次都变，memo 失效）。</li>
</ul>
<h3 id="How-5"><a href="#How-5" class="headerlink" title="How"></a>How</h3><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：使用structuredClone</span></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;lala&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">arr</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="title function_">structuredClone</span>(p)</span><br></pre></td></tr></table></figure>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1：展开运算符</span></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;lala&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">arr</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &#125;</span><br><span class="line"><span class="keyword">let</span> s = &#123;...p&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：使用Object的assign方法</span></span><br><span class="line"><span class="title class_">Demo</span></span><br><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line"><span class="comment">// Expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnedTarget === target);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line">s = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,p)</span><br></pre></td></tr></table></figure>

<h2 id="对React的理解"><a href="#对React的理解" class="headerlink" title="对React的理解"></a>对React的理解</h2><h3 id="What-6"><a href="#What-6" class="headerlink" title="What"></a>What</h3><ul>
<li>JSX 不是 HTML，它会被编译成 <code>React.createElement(...)</code> 的调用，产出的是一棵<code>React Element</code> 树（普通 JS 对象描述 UI）。它是“UI 的描述”，不是浏览器 DOM。</li>
<li>React 以组件为单位，由 <code>state/props</code> 驱动渲染：每次 render 本质是“根据当前 state&#x2F;props 计算下一棵 element 树”。</li>
</ul>
<h3 id="How-6"><a href="#How-6" class="headerlink" title="How"></a>How</h3><ul>
<li>当 <code>state/props</code> 变化时，React 会重新执行组件函数得到 <code>next element tree</code>，再和 <code>prev element tree</code> 做 reconciliation（协调&#x2F;对比），决定哪些地方需要更新。</li>
</ul>
<blockquote>
<p>所以React是一个声明式的UI框架，依托于Props&#x2F;State，JSX会被编译为createElement，得到一个Element树，当<strong>状态变化</strong>时就会render一颗新树，然后通过diff算法来比较计算最小开销，最后把差异提交到真实的DOM</p>
</blockquote>
<h2 id="useMemo和useCallback是什么？-react优化相关"><a href="#useMemo和useCallback是什么？-react优化相关" class="headerlink" title="useMemo和useCallback是什么？(react优化相关)"></a>useMemo和useCallback是什么？(react优化相关)</h2><h3 id="What-7"><a href="#What-7" class="headerlink" title="What"></a>What</h3><ul>
<li><code>useMemo</code>：记住“计算出来的值”（数组&#x2F;对象&#x2F;数字都行），依赖不变就复用上次结果。</li>
<li><code>useCallback</code>：记住“函数本身”（保持函数引用稳定）。它等价于：<blockquote>
<p>useCallback(fn, deps)  ≈  useMemo(() &#x3D;&gt; fn, deps) 它们都不会阻止组件 re-render；组件仍会 render，只是你拿到的值&#x2F;函数不重新创建。就类似于，你唯一的输入一定会得到唯一的输出</p>
</blockquote>
</li>
</ul>
<h3 id="How-7"><a href="#How-7" class="headerlink" title="How"></a>How</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">expensiveFilter</span>(data, keyword), [data, keyword])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> onSend = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">sendMessage</span>(text)</span><br><span class="line">&#125;, [text])</span><br></pre></td></tr></table></figure>

<h3 id="Why-4"><a href="#Why-4" class="headerlink" title="Why"></a>Why</h3><ul>
<li><strong>省计算</strong>：过滤&#x2F;排序&#x2F;聚合很贵时，用 useMemo 避免每次 render 重算。</li>
<li><strong>稳定引用，配合浅比较优化</strong>：用 useMemo&#x2F;useCallback 让引用稳定，避免“不必要的触发”。<blockquote>
<p>“数组&#x2F;对象&#x2F;函数每次 render 都会创建新引用；如果它们作为 props&#x2F;依赖，会让浅比较认为变了，从而触发不必要更新。useMemo&#x2F;useCallback 用来稳定这些引用。”</p>
</blockquote>
</li>
</ul>
<h4 id="浅比较"><a href="#浅比较" class="headerlink" title="浅比较"></a>浅比较</h4><ul>
<li>对基本类型(Number,Boolean,String):比 <strong>值（&#x3D;&#x3D;&#x3D;）</strong>。</li>
<li>对引用类型(arr[],obj{},function()):比 <strong>引用地址（&#x3D;&#x3D;&#x3D;）</strong>，不看里面内容。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line">a === b <span class="comment">// false（内容一样，但不是同一个引用）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = a</span><br><span class="line">a === c <span class="comment">// true（同一个引用）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">arr1 === arr2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在 React 里常见浅比较场景：</p>
<ul>
<li><code>React.memo</code> 默认用浅比较 props：只要某个 prop 引用变了，就认为“变了”。</li>
<li><code>useEffect/useMemo/useCallback 的依赖数组比较</code>：每一项用 Object.is（和 &#x3D;&#x3D;&#x3D; 很像）做浅比较。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>思考复盘</title>
    <url>/2026/01/29/%E6%80%9D%E8%80%83%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h1 id="面试心得"><a href="#面试心得" class="headerlink" title="面试心得"></a>面试心得</h1><h2 id="Meshy"><a href="#Meshy" class="headerlink" title="Meshy"></a>Meshy</h2><ul>
<li>由于是第一次面试前端，会有一些紧张，并且有一些基础并不牢固，很多事情都是想当然，以为看过就会，实际上一动手就废。这是一次我想提前终止的面试，因为我真的被他问的有些不知所措。<ul>
<li>在最后的交流环节里，我向他请教：<strong>在您学习开发的过程中，您是如何将知识内化的？</strong></li>
<li>他给我的答复是：<strong>他会尝试模拟这个过程，看看自己的逻辑是否能跑通，如果不行，学习一下他跑不通的逻辑，也就是无穷尽的探索欲。</strong></li>
<li>这给了我很大启发，我动手其实也有，但是感觉更像是一个typer，instead of thinker，我虽然得到了结果，但是这些东西并没有内化到我自己的心里。所以在今天回家的高铁上，我总结了五个点。<ol>
<li>当你遇到一个问题，尝试去可视化这个问题，比如用笔写下来或者用你的大脑想 </li>
<li>尝试去模拟这个过程，看看目前的知识是否足以解决这个问题 </li>
<li>写下你的想法并且去找到标准答案，尝试去想一下这个答案是否完美，如果不完美，我们自己可以进行优化吗？ </li>
<li>回忆刚刚的整个过程，并且尝试将过程复述给其他人，或者自己。 </li>
<li>不要直接抄答案，要自己从大脑里面检索出想法。</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
