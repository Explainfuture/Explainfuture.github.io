<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringAiMySelf</title>
      <link href="/2025/06/03/SpringAiMySelf/"/>
      <url>/2025/06/03/SpringAiMySelf/</url>
      
        <content type="html"><![CDATA[<p>AI 问答系统（Chat 接口）<br>用户在前端输入问题，后端 Spring Boot 调用 AI 接口（如 OpenAI &#x2F; 通义千问 &#x2F; 自定义模型），返回回答并展示。</p><h1 id="创建配置"><a href="#创建配置" class="headerlink" title="创建配置"></a>创建配置</h1><ul><li>JDK17</li><li>在IDEA中勾选依赖项<ul><li>SpringWeb &#x2F;&#x2F;搭建REST接口，用于对外提供API</li><li>Spring Data Redis &#x2F;&#x2F;使用Redis进行缓存&#x2F;AI结果存储</li><li>MySQL Driver &#x2F;&#x2F;用于连接数据库，存储用户、记录等结构化数据</li><li>Lombok &#x2F;&#x2F;简化实体类开发，自动生成Getter&#x2F;Setter&#x2F;构造器等</li></ul></li><li>配置application.yml(src&#x2F;main&#x2F;resources)</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span>  <span class="comment">#默认端口号</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据库</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo_db?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#配置redis</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#JSON输出格式优化</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br></pre></td></tr></table></figure><h2 id="配置测试之Redis"><a href="#配置测试之Redis" class="headerlink" title="配置测试之Redis"></a>配置测试之Redis</h2><ul><li>先在本机启动Redis</li><li>在src&#x2F;main&#x2F;java&#x2F;com.explainsf&#x2F;springai下新建一个包<code>controller</code>，编写TestController类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.explainsf.springai.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/redis&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//写入redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;test - key&quot;</span>, <span class="string">&quot;hello redis!&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis里读</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;test - key&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redis 中的值是：&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开发问答环节"><a href="#开发问答环节" class="headerlink" title="开发问答环节"></a>开发问答环节</h3><ol><li>@RestController注解有什么用？</li></ol><ul><li>它是一个<strong>控制器类</strong>，用于处理前端发过来的请求</li></ul><hr><ol start="2"><li>@RequestMapping(“&#x2F;test”)有什么用？</li></ol><ul><li>为这个控制器类编写一个统一的URL前缀，所有这个类里的接口，都会带上这个前缀；比如我们写了@GetMapping(“&#x2F;redis”)，最终完整的路径就是&#x2F;test&#x2F;redis</li></ul><hr><ol start="3"><li>@Autowired有什么用？</li></ol><ul><li>让Spring<strong>自动注入（创建和管理）这个对象</strong>，不然我们就需要手动的new。每一个新创建的对象都要进行一次注解添加</li></ul><hr><ol start="4"><li>@GetMapping有什么用？</li></ol><ul><li>我们写了<code>GetMapping(&#39;/redis&#39;)</code>，就<strong>去执行下面的这个方法</strong></li></ul><hr><ol start="5"><li>StringRedisTemplate是什么？opsForValue()方法又有什么用？</li></ol><ul><li>是Spring提供的类，用来专门操控redis;opsForValue()用来操作字符串，有不同的方法可以操作不同的数据类型<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603204613935.png"></li></ul><blockquote><p>Spring Boot 会把你写的每个接口，组合成一个 URL 路径：&#x2F;test是前缀，&#x2F;redis是后缀（调用的方法），拼在一起就可以<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603203821427.png" alt="Redis测试"></p></blockquote><h2 id="配置测试之MySQL"><a href="#配置测试之MySQL" class="headerlink" title="配置测试之MySQL"></a>配置测试之MySQL</h2><ul><li>先创建一个表(也叫做架构)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE demo_db;</span><br></pre></td></tr></table></figure><ul><li>再使用架构并建表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">                      id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">                      name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">                      email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603205500499.png" alt="建表"></p><ul><li><p>创建一个entity包，里面有User类</p></li><li><p>创建一个repository包，目录在包名下，包里含有一个UserRepository接口</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.explainsf.springai.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.explainsf.springai.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;User, Long&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承了Jpa这个类，我们自己的接口会有以下方法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603211809647.png" alt="继承Jpa"></p></blockquote><h3 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h3><ol><li><code>@Entity</code></li></ol><ul><li><strong>作用</strong>：标识这个类是一个实体类，会映射为数据库中的一张表。</li><li><strong>来自</strong>：<code>jakarta.persistence</code></li><li><strong>说明</strong>：如果没有这个注解，Spring Boot 不会将该类作为数据库表处理。</li></ul><hr><ol start="2"><li><code>@Table(name = &quot;user&quot;)</code></li></ol><ul><li><strong>作用</strong>：指定实体类对应的数据库表名为 <code>user</code>。</li><li><strong>默认行为</strong>：如果不写该注解，JPA 会默认使用类名作为表名（大小写敏感，容易报错）。</li></ul><hr><ol start="3"><li><code>@Id</code></li></ol><ul><li><strong>作用</strong>：标识该字段为<strong>主键</strong>（Primary Key）。</li><li><strong>必须使用</strong>：否则 JPA 无法知道如何唯一标识一条记录。</li></ul><hr><ol start="4"><li><code>@GeneratedValue(strategy = GenerationType.IDENTITY)</code></li></ol><ul><li><strong>作用</strong>：设置主键的生成策略为数据库自增（MySQL 中的 AUTO_INCREMENT）。</li><li><strong>常见策略</strong>：<ul><li><code>AUTO</code>：由 JPA 自动选择策略</li><li><code>IDENTITY</code>：数据库自增（适用于 MySQL）</li><li><code>SEQUENCE</code>：使用序列（适用于 Oracle）</li><li><code>TABLE</code>：使用数据库表记录主键（性能较差）</li></ul></li></ul><hr><ol start="5"><li><code>@Data</code>（Lombok 提供）</li></ol><ul><li><strong>作用</strong>：自动生成以下方法：<ul><li><code>get</code> &#x2F; <code>set</code></li><li><code>toString()</code></li><li><code>equals()</code> &#x2F; <code>hashCode()</code></li></ul></li><li><strong>简化代码</strong>： 相当于加了：@Getter @Setter @ToString @EqualsAndHashCode ，@RequiredArgsConstructor<blockquote><p>在下文中，虽然我们没写getMessage()方法，但是由于我们在ChatRequest这个类上加了Data注解，于是自动生成了Get方法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603213050247.png" alt="数据库连接"></p></blockquote></li></ul><h2 id="配件测试之Qwen"><a href="#配件测试之Qwen" class="headerlink" title="配件测试之Qwen"></a>配件测试之Qwen</h2><ul><li>在application.yml中使用Qwen创建的api-key以及api-url(不同的模型有不同的http响应)</li><li>在pom.xml配置dependecy</li><li>在软件包下创建config包并在里面配置<code>QwenConfig</code>类</li><li>然后在Service里开发QwenService负责</li><li>最后在ChatController中提供对外的接口</li></ul><h3 id="配置API之Qwen"><a href="#配置API之Qwen" class="headerlink" title="配置API之Qwen"></a>配置API之Qwen</h3><ol><li>@Component有什么用？</li></ol><ul><li>将这个类注册为Spring容器中的一个Bean，@Component是注册Bean，<strong>告诉 Spring 这个类&#x2F;对象你要负责创建和管理。</strong><blockquote><p>@Component：你告诉 Spring “这个类要托管给你管理”（注册到容器）<br>@Autowired：你告诉 Spring “我要用那个托管的类”（注入使用）</p></blockquote></li></ul><ol start="2"><li>@ConfigurationProperties(prefix &#x3D; “qwen”)有什么用？</li></ol><ul><li>SpringBoot会自动将application.yml中的api-key和api-url注入到QwenConfig中的配置环境。</li></ul><hr><p>到目前，后端的基础就已经写好了。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604103258227.png"></p><p>阶段性总结</p><ul><li>我们写的这个结构是SpringBoot的三层架构：<ul><li>配置类Config</li><li>服务类Service</li><li>控制器类Controller</li></ul></li></ul><h1 id="功能完善"><a href="#功能完善" class="headerlink" title="功能完善"></a>功能完善</h1><h2 id="聊天接口完善"><a href="#聊天接口完善" class="headerlink" title="聊天接口完善"></a>聊天接口完善</h2><ul><li>支持POST请求</li><li>返回统一的JSON格式</li></ul><ol><li>在包下新建model包，并在里面新建ChatRequest类和统一响应类</li><li>重写ChatRequest类(使用了@Data)</li><li>使用了统一返回类</li><li>最后使用PostMan进行POST请求的调试<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604110257747.png"></li></ol><h3 id="聊天接口之完善问答"><a href="#聊天接口之完善问答" class="headerlink" title="聊天接口之完善问答"></a>聊天接口之完善问答</h3><ol><li>为什么要新建一个model并在里面创建ChatRequest和统一响应类？</li></ol><ul><li>之前我们调用API的回答方式是&#x2F;chat方法，是一种get请求，简单来说就是我们只需要传一个参数<code>问题</code>，浏览器就会给我们模型的回答，现在我们使用ChatRequest和统一响应类来接收JSON请求体，可以把接口返回格式统一，也是主流的开发。</li></ul><p>&#x2F;&#x2F;json格式混乱，我们使用json格式解析器回复更好<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604111310245.png"><br>现在我们就成功调用了ai</p><h2 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h2><ul><li>创建一个chat.html(src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;chat.html)</li><li>修改ChatController作为页面路由</li><li>前端代码生成<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604114943104.png"></li><li>但现在问题是：无法记录上下文，这时候我们就要用到redis存储历史记录<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604115410587.png"></li></ul><h2 id="Redis实现上下文记录"><a href="#Redis实现上下文记录" class="headerlink" title="Redis实现上下文记录"></a>Redis实现上下文记录</h2><ul><li>创建util包，里面存放着ChatMemoryManager实现类<ul><li>ChatMemoryManager的实现类思路<br>我们先使用了<code>StringRedisTemplate</code>和<code>ObjectMapper</code>这两个类，并且定义了最大历史记录为5.</li></ul></li><li>修改QwenService以及Controller，让它们带上了userId和Message<ul><li>我们使用了一个<strong>集合</strong>来存放历史消息</li></ul></li></ul><h3 id="Redis问答"><a href="#Redis问答" class="headerlink" title="Redis问答"></a>Redis问答</h3><ol><li>StringRedisTemplate类是哪里来的？</li></ol><ul><li>它是Spring提供的操作redis的类，专门用于字符串类型的读写操作。</li></ul><ol start="2"><li>ObjectMapper是哪里来的？</li></ol><ul><li>这是Jackson提供的核心类，用来进行java对象&lt;–&gt;JSON字符串的切换，在发送请求和存redis的时候会经常用到</li></ul><ol start="3"><li>那我们现在的redis会不会自动删除聊天记录呢？</li></ol><ul><li>其实不会，使用的是 redisTemplate.opsForValue().set(key, value)，也没有设置过期时间TTL，所以历史记录会<strong>永久存放在redis</strong>中；那我们是否需要删除呢？要取决于我们的上下文聊天是否持久<ul><li>保证每次进入页面都有记忆：不删除，可以永久存放在redis中</li><li>只在本次对话中记忆：需要删除，聊完就清空redis</li><li>长期登录用户的对话记录：建议写入数据库，redis仅做缓存，<strong>MySQL做历史保存，Redis做上下文</strong></li></ul></li></ul><ol start="4"><li>所以chatGPT的策略是什么？</li></ol><ul><li>所有的<code>记忆</code>都是靠<strong>拼接历史对话内容</strong>到当前请求中完成的，并不是”主动记得”，当每次用户提问的时候，系统把之前的消息打包发送给模型。所谓的上下文能力全部来源于<code>调用者的message消息列表</code>，<ul><li>调用chatGPT时，OpenAI会构造出这样一个message数组：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你好&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你好，有什么我可以帮你的吗？&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;你知道我刚才问了什么吗？&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><ul><li>只有这样模型才知道刚刚发生了什么。</li></ul></li><li>所以我们有两种方式实现长期记忆<ol><li>前端或服务端主动保存历史聊天</li></ol><ul><li>每次用户发言就持久化（如存到 MySQL）</li><li>用户进入新聊天时自动加载历史上下文到 Redis，再发送给模型</li></ul><ol start="2"><li>方式二：Embedding + 概念记忆（更高阶）</li></ol><ul><li>把用户历史对话转为向量（embedding），存入向量库</li><li>在新问题触发时从向量库中“召回相似的历史”，附加给 prompt<blockquote><p>现在构建的 Redis-based 对话记忆系统，是行业内标准方案。<br>现在消息记录已经被成功存入到redis中了<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604124304164.png"><br>成功了！<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604131807919.png"></p></blockquote></li></ul></li></ul><h2 id="MySQL实现持久化聊天记录到本地"><a href="#MySQL实现持久化聊天记录到本地" class="headerlink" title="MySQL实现持久化聊天记录到本地"></a>MySQL实现持久化聊天记录到本地</h2><ul><li>基于Redis我们可以实现上下文记忆，但我们需要保存聊天记录，有以下好处<ul><li>MySQL可以持久化数据，<strong>适合做用户聊天记录展示、检索以及分析</strong></li><li>Redis重启可能数据会丢失，MySQL可以长期备份保存</li><li>用这些保存的数据继续去分析</li><li>多端跨平台跨设备查看历史聊天记录<blockquote><p>🔒 Redis 用于短时上下文记忆（对话中），MySQL 用于长期存储与用户功能（查看历史、数据分析），两者配合才完整。</p></blockquote></li></ul></li></ul><ol><li>我们需要建表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> chat_log (</span><br><span class="line">    id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    user_id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">    role <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,          <span class="comment">-- user / assistant</span></span><br><span class="line">    content TEXT <span class="keyword">NOT NULL</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (user_id) <span class="keyword">REFERENCES</span> <span class="keyword">user</span>(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在entity添加实体类<code>ChatLog</code>(对应MySQL表)</p></li><li><p>添加Repository(操作数据库)</p></li></ol><h3 id="数据库问答"><a href="#数据库问答" class="headerlink" title="数据库问答"></a>数据库问答</h3><ol><li>JPA是什么？<br>(Java Persistence API) Java官方定义的一套ORM规范，可以把<strong>数据库当Java中的类来操作，把数据行当成对象来操作</strong>，我们使用的是SpringBoot + JPA</li></ol><ul><li>实体类：@Entity + @Table描述数据库表结构</li><li>接口：extends JpaRepository&lt;实体，主键类型&gt;直接获得数据库</li><li>不用写SQL，自动生成</li></ul><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604141206470.png"><br>我们成功创建了MySQL和后端的连接，但是有个问题！我们没有注册登录用户，当我们拿一个从来没有插入进数据库的id进行回答时，虽然模型成功给出了答案，但是并没有成功在前端页面返回，是因为我们没有在user表里插入这个人，所以我们现在可以使用一个办法，先让用户注册并登录，让这个用户和chat_log表中的对应数据关联。</p><ul><li>所以我们接下来先实现用户注册登录功能</li><li>我们有两张表，一张是chat_log，另一张是user，user里可以设置字段id以及password，在chat_log里面的表也有一个id字段，作为外键指向user表让两张表相连。</li></ul><h2 id="登陆注册"><a href="#登陆注册" class="headerlink" title="登陆注册"></a>登陆注册</h2><ol><li>复写User类，新增password字段，@Data直接帮我们省去了Setter和Getter的写</li><li>写UserRepository，主要是添加</li><li>创建UserService实现登录注册逻辑</li><li>添加Spring Security依赖<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604153637030.png"></li></ol><h3 id="登陆注册问题"><a href="#登陆注册问题" class="headerlink" title="登陆注册问题"></a>登陆注册问题</h3><ol><li>@Server注解有什么用？</li></ol><ul><li>它是 Spring 的组件注解之一，用于标识一个类是“服务层组件”（Service）。被标注的类会被 Spring 容器自动识别并托管为 Bean，可以在其他地方通过 @Autowired 自动注入使用。</li></ul><ol start="2"><li>@Override有什么用？</li></ol><ul><li>表示当前方法是 重写了父类或接口中定义的方法。</li></ul><ol start="3"><li>我们采用了什么加密算法？</li></ol><ul><li>加密方式：BCrypt 哈希加密，是一种<strong>不可逆</strong>的密码加密方式；<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604154714565.png"></li></ul><h2 id="JWT登陆注册"><a href="#JWT登陆注册" class="headerlink" title="JWT登陆注册"></a>JWT登陆注册</h2><blockquote><p>既然我们已经有了数据库登录，那为什么还要做JWT登录？</p></blockquote><ul><li>数据库<ul><li>当前数据库的登陆方式是用户登陆时提交ID和密码</li><li>服务端查数据库验证密码</li><li>前端之后每次请求仍需要传用户ID，服务端继续查数据库验证</li><li>问题在于<strong>每一次都要去请求数据库，太麻烦了！</strong></li></ul></li><li>JWT<ul><li>我们在登陆成功后给用户发一个令牌token，代表用户身份，每次请求只去查询<code>token</code>，实现无状态认证。</li><li>易扩展，可以加入用户角色、权限、过期时间等<blockquote><p>数据库登录是“身份验证的方式”，而 JWT 是“身份验证后的认证令牌机制”，两者是互补不是重复。</p></blockquote></li></ul></li></ul><ol><li>添加依赖</li><li>修改UserService.login和UserController</li></ol><ul><li>登陆成功后生成JWT Token</li><li>将Token和用户信息一起返回给前端</li><li>创建一个DTO(LoginResponse)</li><li>修改登录逻辑，使用LoginResponse类型来接收<blockquote><p>成功返回了jwt令牌<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604160458678.png"></p></blockquote></li></ul><h2 id="编写JwtAuthFilter实现Token校验与用户认证"><a href="#编写JwtAuthFilter实现Token校验与用户认证" class="headerlink" title="编写JwtAuthFilter实现Token校验与用户认证"></a>编写JwtAuthFilter实现Token校验与用户认证</h2><ul><li>使用 OncePerRequestFilter 保证每次请求只调用一次；</li><li>我们把 userId 放入了认证上下文，可以在控制器里用 @AuthenticationPrincipal 获取；</li><li>不做角色权限处理，使用空权限列表 Collections.emptyList() 即可。</li></ul><ol><li>增加我们自定义的jwt过滤器</li></ol><ul><li>addFilterBefore(…) 是关键，把我们自定义的 JWT 过滤器插入到 Spring Security 过滤器链中；</li><li>现在所有接口如果没有 Token，都会被拒绝访问（除了 permitAll() 的那些）；</li></ul><h2 id="但现在又出现了新的问题"><a href="#但现在又出现了新的问题" class="headerlink" title="但现在又出现了新的问题"></a>但现在又出现了新的问题</h2><ul><li>我们在单一账号下能够实现记忆，但是用了两个不同的账号来回切换，就发现它们无法读取之前的记忆了，问题在于我们之前使用的是getMessages(userId)从 Redis 拉取历史，上下文丢失了<blockquote><p>用户登录或重新进入聊天时，如果 Redis 中无上下文，则从 MySQL 中加载最近 N 条对话记录“恢复记忆”。</p></blockquote></li></ul><ol><li>在chat方法添加如果redis是空，从mysql里找回之前的消息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: 如果 Redis 无上下文，自动从数据库恢复</span></span><br><span class="line">    <span class="keyword">if</span> (chatMemory.getMessages(userId).isEmpty()) &#123;</span><br><span class="line">        List&lt;ChatLog&gt; recent = chatLogRepository.findTop10ByUserIdOrderByCreateTimeDesc(Long.valueOf(userId));</span><br><span class="line">        Collections.reverse(recent); <span class="comment">// 确保顺序正确（旧 → 新）</span></span><br><span class="line">        <span class="keyword">for</span> (ChatLog log : recent) &#123;</span><br><span class="line">            chatMemory.saveMessage(userId, log.getRole(), log.getContent());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>成功加入历史记录！<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604163808292.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250604163859488.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL八股</title>
      <link href="/2025/06/02/SQL%E5%85%AB%E8%82%A1/"/>
      <url>/2025/06/02/SQL%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p>MySQL是关系型数据库RDB</p><ol><li>什么是SQL？<br>SQL(Structured Query Language)，专门用于和数据库打交道，从数据库中高效提取数据。</li><li>什么是MySQL？<br>MySQL是一种关系型数据库，用于<strong>持久化</strong>我们系统中的一些数据，比如用户信息。</li><li>整数类型的UNSIGNED属性有什么用？<br>UNSIGNED可以将表示的正整数范围提升一倍，比如TINYINT只能表示-128-127，如果使用UNSIGNED TINYINT就可以变为0-255，可以用在年龄，员工id等一些值不为<strong>负的场景</strong>。</li><li>CHAR和VARCHAR有什么区别？</li></ol><ul><li>CHAR：<ul><li>长度：<strong>定长字符串</strong>，比如CHAR(10)，无论输入abc还是abcdefghij，都只会占用10个字符（如果输入超过十个就截断）</li><li>适用场景：长度固定的字符串，比如身份证号，性别，<strong>MD5算法</strong>加密后的密码等。</li><li>类比：CHAR 就像定长的信封，无论你放几张纸，都塞满；</li></ul></li><li>VARCHAR：<ul><li>长度：<strong>变长字符串</strong>，VARCHAR 在存储时需要使用 1（长度小于255） 或 2（长度大于255） 个额外字节记录字符串的长度，检索时不需要处理。比如我存放’abc’，还需要一个字节来记录长度，所以一共是四字节。VARCHAR(10)代表最多能存放10个字节</li><li>适用场景：字段长度不确定，如用户名、地址等。</li><li>类比：VARCHAR 是塑料袋，放多少张纸占多少空间，节省但形状不规则。</li></ul></li></ul><ol start="5"><li>DECIMAL和&#x2F;FLOAT&#x2F;DOUBLE有什么区别</li></ol><ul><li>DECIMAL(定点数)<ul><li><strong>精度高，用于存储精确的小数，不会有误差；</strong></li><li>适用于<strong>金融、电商、计量</strong>等要求精确的小数场景；</li></ul></li><li>FLOAT&#x2F;DOUBLE<ul><li>近似值，以二进制表示，会有微小误差；</li><li>适用于<strong>科学计算、图像处理等对速度要求高但可容忍误差</strong>的场景；</li></ul></li></ul><ol start="6"><li>DATETIME和TIMESTAMP的区别是什么？<br><strong>DATETIME 类型没有时区信息</strong>，TIMESTAMP 和时区有关。</li></ol><ul><li>DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li><li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><ol start="6"><li>NULL和’’(空字符串)的区别是什么？</li></ol><ul><li>含义不同：<ul><li>NULL 表示值缺失、未知或未定义；</li><li>‘’ 是一个已知的空字符串，值是明确存在的，只是没有内容。</li></ul></li><li>比较运算：<ul><li>NULL 无法直接参与 &#x3D;、!&#x3D; 等运算，任何和 NULL 比较的结果都是 NULL（未知），只能用 IS NULL &#x2F; IS NOT NULL；</li><li>‘’ 可以正常比较，比如 ‘’ &#x3D; ‘’ 是 TRUE。</li></ul></li><li>聚合函数行为：<ul><li>NULL 会被 SUM、AVG 等聚合函数自动忽略；</li><li>COUNT(*) 统计所有行，包括 NULL；</li><li>COUNT(col) 只统计非 NULL 值；</li><li>‘’ 会被当成普通值参与运算，比如 SUM(‘’) 视为 0，MIN(‘’) 是空字符串。<blockquote><p>为什么不建议使用 NULL 作为默认值？<br>NULL 表达不明确，查询时需要特殊处理，无法高效使用索引，也容易被聚合函数忽略，导致语义和性能问题。除非明确表示“未知&#x2F;缺失”，否则推荐使用更有意义的默认值如 0、’’、1970-01-01 等。</p></blockquote></li></ul></li></ul><ol start="7"><li><p>BOOLEAN该如何表示？<br>MySQL中没有专门的BOOLEAN，使用TINYINT来存储0&#x2F;1来表示false&#x2F;true</p></li><li><p>InnoDB有什么强大之处？</p></li></ol><ul><li>支持<strong>行级锁</strong>，实现高并发</li><li>支持<strong>事务（ACID）</strong><ul><li>A：原子性 一组操作要么全部完成，要么全部回滚</li><li>C：一致性    执行前后数据保持一致，符合约束和逻辑</li><li>I：隔离性    并发事务彼此隔离，不互相干扰</li><li>D：持久性    提交后的数据永久保存，即使系统崩溃也不丢失<blockquote><p>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</p></blockquote></li></ul></li></ul><h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><ol><li>为什么 MySQL 采用 B+ 树作为索引？<br>MySQL是将数据持久化在硬盘上，磁盘 I&#x2F;O 成本高，<strong>索引的核心目标就是减少磁盘访问次数</strong>。B+树只在叶子节点存放索引和数据，且最底层是双向链表，叶子节点通过链表串联，可以高效支持范围查询和排序；非叶子节点只存键值，不存数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603142536027.png" alt="B+树结构"></li><li>索引的分类有哪些？<br>有主键索引和二级索引</li></ol><ul><li>主键索引的B+树的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的B+树的叶子节点里<ul><li>主键索引通过PRIMARY KEY创建，主键索引是<strong>聚簇索引</strong>（<strong>索引结构和数据一起存放的索引</strong>）</li></ul></li><li>二级索引的B+树的叶子节点存放的是主键值，而不是实际数据。查完了数据要回表，也就是查两次B+树<ul><li>二级索引是非聚簇索引（<strong>索引结构和数据分开存放的索引</strong>）</li></ul></li></ul><ol start="3"><li>什么时候使用索引&#x2F;不使用索引？<br>索引需要占用物理空间，创建索引和维护索引要耗费时间，所以要看场景决定是否使用。</li></ol><ul><li>使用索引<ul><li>字段有<strong>唯一限制的</strong>，比如商品编码</li><li>经常用where</li><li>经常用<code>group by</code> 和<code>order by</code>的字段，因为b+树已经自动排序了。</li></ul></li><li>不使用索引<ul><li>不能快速定位</li><li>大量重复数据，比如性别</li><li>表数据太少</li><li>经常更新的字段</li></ul></li></ul><ol start="4"><li>有什么优化索引的办法？</li></ol><ul><li>前缀索引优化<ul><li>使用某个字段的前几个字符串建立索引</li></ul></li><li>覆盖索引优化<ul><li><strong>覆盖索引就是“只从索引就能拿到结果”的优化技巧，避免回表，提高效率。</strong> 多用于只查几个字段的业务场景。</li></ul></li><li>主键索引最好自增<ul><li>避免新开空间割裂。</li></ul></li><li>防止索引失效</li></ul><h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><p>有三种日志</p><h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p>是Innodb存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，用于<strong>事务的回滚和MVCC</strong></p><ol><li>MVCC</li></ol><ul><li>MVCC（Multi-Version Concurrency Control），是Innodb实现高并发读写的核心机制，它允许多个<strong>事务并发读写而不加锁</strong>，实现读写不冲突。</li><li>MVCC让读操作不必等写操作完成，写操作也不会阻塞读，<strong>大大提升并发性能</strong></li><li>如何做到的？<ul><li>InnoDB为每行记录维护了两个隐藏字段：<ul><li>trx_id：创建&#x2F;最后修改这行的事务id</li><li>roll_pointer：指向undo log的指针，可回溯历史版本</li></ul></li><li>读操作会根据当前事务的版本号判断哪些数据是“自己能看到的旧版本”。<blockquote><p>MVCC 让读操作看到的是符合事务隔离的“历史快照”，避免加锁冲突，是 InnoDB 实现高并发的核心机制。</p></blockquote></li></ul></li></ul><ol start="2"><li>日志增加<blockquote><p>每当InnoDB引擎对一条记录进行增删改时，要把回滚时所需的信息记录到undo log里。</p></blockquote><ul><li>在<strong>插入</strong>一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录<strong>删掉</strong>就好了；</li><li>在<strong>删除</strong>一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录<strong>插入</strong>到表中就好了；</li><li>在<strong>更新</strong>一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列<strong>更新为旧值</strong>就好了。</li></ul></li></ol><h2 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h2><ul><li><strong>写入磁盘很慢</strong>，但事务必须保证“提交就不能丢”，所以InnoDB先把sql语句记录在redo log上，再异步刷新到磁盘上，一旦宕机，只要redo log在，就能重做，保证事务数据不丢。</li><li>redo log是循环写，会边写边擦除日志，binlog是全局日志。如果数据库被删了，要通过binlog还原。</li></ul><h2 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h2><p>binlog<strong>Binary Log是 MySQL 层的日志，记录所有涉及数据修改的 SQL 语句如 INSERT、UPDATE、DELETE</strong>，作用是：</p><ol><li>主从复制的基础<ul><li>MySQL 主库会将 binlog 传给从库；从库通过 binlog 重放主库的操作，实现数据同步。</li></ul></li><li>数据恢复（逻辑级）<ul><li>搭配全量备份 + binlog，可以恢复任意时间点的数据（类似“时光机”）；比如误删了数据，可以通过 binlog 找出执行的 SQL 语句。<blockquote><p>binlog 是 MySQL 层的“操作录像机”，记录了所有数据变更语句，是主从复制和数据恢复的核心。</p></blockquote></li></ul></li></ol><p>问题：那有了binlog，为什么还要有redo log？</p><ol><li><p>binlog 是“逻辑日志”，写入在事务提交之后：</p><ul><li>如果系统崩溃在提交前，binlog 根本没写，还原不了；</li><li>会导致事务丢失，违背了“已提交不能丢”的承诺。</li></ul></li><li><p>binlog 只能“重演 SQL”，不能“恢复内存页”：</p><ul><li>redo log 是物理日志，可以快速恢复脏页（Buffer Pool）；</li><li>binlog 没法修复页级一致性。<br>✅ 二者配合流程（WAL机制）：</li></ul></li><li><p>执行 SQL，修改内存页（Buffer Pool）；</p></li><li><p>写 redo log（物理变更） → 写入 redo log buffer；</p></li><li><p>写 binlog（逻辑变更）；</p></li><li><p>同时持久化 redo log + binlog；</p></li><li><p>执行 COMMIT，事务才算真正提交成功。</p></li><li><p>为什么需要两阶段提交？</p></li></ol><ul><li>有两种情况：<ul><li>如果在将redolog刷入到磁盘之后，MySQL突然宕机了，而binlog还没有来得及写入。MySQL重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D;1这行数据的 name字段恢复到新值 xiaolin,但是 binlog里面没有记录这条更新语句，在主从架构中，binlog会被复制到从库，由于binlog丢失了这条更新语句，从库的这一行name字段是旧值jay，与主库的值不一致性;</li><li>如果在将binlog刷入到磁盘之后，MySQL突然宕机了，而redolog还没有来得及写入。由于redolog还没写，崩溃恢复以后这个事务无效，所以id&#x3D;1这行数据的name字段还是旧值jay，而binlog里面记录了这条更新语句，在主从架构中，binlog会被复制到从库，从库执行了这条更新语句，那么这一行name字段是新值xiaolin，与主库的值不一致性;</li></ul></li><li>所以MySQL为了避免半成功，使用了<strong>两阶段提交</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603160127646.png"></li><li>把单个事务拆分成了两部分：准备 和 提交<ul><li>准备：将XID(内部XA事务的ID)写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log持久化到磁盘(innodb_flush_log_at_trx_commit &#x3D; 1的作用);</li><li>提交：把XID写入到binlog，然后将binlog持久化到磁盘(sync_binlog&#x3D;1的作用)，接着调用引擎的提交事务接口，将redolog状态设置为commit，此时该状态并不需要持久化到磁盘，只需要write到文件系统的page cache中就够了，因为只要binlog写磁盘成功，就算redo log的状态还是prepare也没有关系，一样会被认为事务已经执行成功；</li></ul></li></ul><h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><p>多个事务并发执行的时候可能会遇到脏读、不可重复读、幻读</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603161259993.png"></p><ul><li>如果一个事务读到了另一个未提交事务所修改的数据，就发生了脏读。</li></ul><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603161758686.png"></p><ul><li>在一个事务内多次读取同一个数据，如果前后两次的数据不一致，就发生了不可重复读</li></ul><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250603161940832.png"></p><ul><li>在一个事务内多次查询<strong>记录数量</strong>，如果出现前后两次查询记录数量不一致，就发生了幻读。<blockquote><p>幻读和不可重复读的区别在于：一个是行数变了，一个是内容变了</p></blockquote></li></ul><blockquote><p>脏读靠“读已提交”(每次查询都只能看到其他事务“已提交”的数据”；)解决，不可重复读靠“可重复读”(一个事务开始后，无论查询多少次，看到的都是事务开始时的一致快照；)，幻读还需“间隙锁”防插入(主要用来防止其他事务在已查询范围内插入新记录，从而防止幻读。)。InnoDB 全都能搞定。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS八股</title>
      <link href="/2025/06/01/OS%E5%85%AB%E8%82%A1/"/>
      <url>/2025/06/01/OS%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><ol><li>系统调用&#x2F;用户态和内核态</li></ol><ul><li>用户态：用户态可以直接读取用户程序的数据。</li><li>内核态：内核态运行的程序几乎可以访问计算机的任何资源，不受限制。<blockquote><p>用户态<strong>无法直接访问硬件资源</strong>，而内核态可以；系统通过硬件保护机制防止用户态程序直接访问关键资源，确保系统稳定和安全。</p></blockquote></li></ul><ol start="2"><li>什么是系统调用？</li></ol><ul><li>日常情况下我们的程序基本运行在用户态，当遇到与<strong>内核态</strong>级别有关的资源调用时，就需要进行<strong>系统调用</strong>，大致分为五类<ul><li>设备管理：完成设备的请求或释放，以及设备的启动等。</li><li>文件管理：完成文件的<code>增删改查</code>。</li><li>进程管理：完成进程的<code>创建、撤销、阻塞及唤醒</code>等功能。</li><li>进程通信：完成进程间的消息传递或信号传递。</li><li>内存管理：完成内存的分配、回收以及获取作业占用内存的大小及地址等功能。</li></ul></li></ul><ol start="3"><li>什么情况下发生系统调用？<ol><li>主动系统调用<ul><li>用户态<strong>主动请求</strong>切换到内核态，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如read操作，比如fork()操作。系统调用的核心是OS为用户开了一个特别的中断来实现。</li></ul></li><li>异常<ul><li>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li></ul></li><li>外围设备的中断<ul><li>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。如网卡接收到数据包、定时器中断等也会导致从用户态切入内核态，执行中断服务程序。</li></ul></li></ol></li></ol><blockquote><p>用户态程序无法直接访问硬件资源，为了在受限的权限下完成磁盘读写、网络通信、进程创建等操作，用户程序需要通过系统调用请求内核代为执行。以 Linux 为例，系统调用通过特殊的 syscall 指令触发软中断（软中断是调用方法，硬中断不可控，比如IO完成通知、定时器、外设输入），由操作系统内核中的中断处理程序接管执行，完成如 <code>read(), fork()</code> 等功能后再返回用户态。</p><ol start="4"><li>其他必会知识<ol><li>并行与并发<ul><li>并行(Parallelism)：多个任务在同一时刻被<code>多个处理器</code>或<code>多个核心</code>同时执行，是物理上的同时发生，常用于计算密集型任务。</li><li>并发(concurrency)：在一个时间段内多个任务被启动，并由<code>单个处理器交替执行</code>，依<code>靠任务调度</code>机制实现“看似同时”进行，适用于IO密集型任务或资源共享的场景。<blockquote><p>并发更侧重于任务间的切换与调度控制，可在单核或多核系统中实现；而并行依赖于多核资源，更强调同时执行多个任务的能力。<br> &#x2F;&#x2F;todo()<br>在Java中，<code>synchronized</code> 和 <code>ReentrantLock</code> 是并发控制工具；他们用来控制<strong>多个线程并发访问共享资源的行为，防止出现竞态</strong>，知识扩展到锁。<br><code>ForkJoinPool</code> 和 <code>parallelStream()</code> 是实现并行计算的常用工具</p></blockquote></li></ul></li><li>同步和异步</li></ol><ul><li>同步（Synchronous）是指调用方发出请求后必须等待任务执行完成并返回结果才能继续执行下一步，期间调用线程会被阻塞。</li><li>异步（Asynchronous）是指调用方发出请求后不等待结果立即返回，任务通常由其他线程或事件回调处理，调用线程可继续执行后续逻辑，不被阻塞。<blockquote><p>异步编程：<code>线程池</code></p></blockquote></li></ul></li></ol></blockquote><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><ol><li>线程，进程，协程的区别<ul><li>进程是操作系统分配资源的基本单位，每个进程有独立的地址空间、文件描述符等资源。</li><li>线程是CPU调度的基本单位，是进程内的执行流，多个线程共享进程资源但独立调度。</li><li>协程是用户态轻量级线程，由程序自身控制切换，不需要内核参与，调度成本低，适合高并发IO场景。</li></ul></li><li>进程vs线程<ul><li>资源管理：进程拥有独立的资源，线程共享所属进程的资源</li><li>调度机制：线程是调度单位，切换成本低；线程切换仅需保存少量寄存器，不涉及页表&#x2F;地址空间切换；而进程切换需要保存和恢复全部上下文，包括内存映射，开销更大。</li><li>系统开销：进程创建&#x2F;销毁需要分配内存、句柄等系统资源，线程的系统开销更小。</li><li>通信机制：线程可以直接共享内存通信；进程需要使用IPC机制，如管道，socket，或共享内存。</li></ul></li><li>PCB是什么？（Process Control Block）<ul><li>PCB主要包含以下几部分内容：<ul><li>进程的描述信息，比如进程的名称，标识符。</li><li>处理机的状态信息。当程序中断时保留此时的信息，以便CPU返回时能从断点处执行。</li><li>进程调度信息，比如阻塞原因，状态，优先级等。</li><li>进程控制和资源占有，同步通信机制，链接指针。</li></ul></li><li>PCB的作用？<ul><li>PCB是进程实体中的一部分，是操作系统中最重要的数据结构</li><li>由于它的存在，可以使程序并发运行。</li><li>系统通过PCB来感知进程的存在。</li><li>进程的组成可以用这张图来表示，换句话说，PCB是程序的唯一标识符。<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250601122001745.png"></li></ul></li></ul></li><li>进程的五种状态<ul><li>创建、就绪、运行、阻塞、结束</li><li>就绪和运行可以互相转化，当进程为就绪态时，若CPU为其分配时间篇，即可运行，状态变为运行。</li><li>运行状态结束后又变回就绪态。</li><li>阻塞状态是进程在运行状态中，需要等待某个资源，比如打印机资源，从而挂起的状态，等资源拿到后会回到就绪态，等待CPU时间片。<br> <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250419221319250.png"></li></ul></li><li>进程调度算法<ul><li>先来先服务(FCFS)、短作业优先(SJF)、最短剩余时间有限(SRTN)、时间片轮转、优先级调度、多级反馈队列</li></ul></li><li>进程同步的方式<ol><li>临界区<ul><li>多个进程对<code>共享资源</code>的访问代码区域称为临界区，系统通过<code>加锁</code>等机制确保任意时刻<code>仅有一个进程</code>执行临界区代码。</li></ul></li><li>同步和互斥<ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后顺序。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul></li><li>信号量(Semaphore)<ul><li>信号量是一个<strong>整型计数器</strong>，用于控制进程间访问临界资源的个数。通过原子操作 P()（等待）和 V()（释放）实现：</li><li>P：如果信号量大于零，就对其进行减 1 操作；如果信号量等于 0，进程进入 waiting 状态，等待信号量大于零。</li><li>V：对信号量执行加 1 操作，并唤醒正在 waiting 的进程<blockquote><p>如果信号量只能取 0 或者 1，那么就变成了互斥量，其实也可以理解成加锁解锁操作，0 表示已经加锁，1 表示解锁。</p></blockquote></li><li>信号量是什么？是一种用于控制多进程或多线程并发访问共享资源的<strong>同步机制</strong>，汉堡店例子，有两种信号量：整型信号量和记录型信号量。记录型信号量执行P操作先–，然后判断当前值是否小于0，如果小于0，将其添加进阻塞队列；如果此时执行V操作让值大于等于0，说明在阻塞队列中存在进程已经预定了库存，分配给他。</li></ul></li><li>管程(Monitor)<ul><li>管程是高级语言层面的同步机制，封装了共享资源、临界区操作和条件变量。管程内部自动实现互斥，外部无法直接访问内部资源。Java 中 synchronized、wait&#x2F;notify 就是典型的管程模型实现。<blockquote><p>Java中的ReentrantLock、Condition、Semaphore等都是对底层同步机制的封装。合理选用这些同步原语是高并发编程的核心。</p></blockquote></li></ul></li></ol></li><li>进程间通信的方式(<strong>重要！</strong>)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250601141818349.png"></li></ol><ul><li>两个进程都只能访问自己的那一片地址空间，如果一个进程可以随意访问另一个进程的地址空间，会修改另一个进程的数据，导致数据不安全。<ol><li>共享存储</li></ol><ul><li>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。但需要借助**同步机制（如信号量、互斥锁）**来防止竞态。</li></ul><ol start="2"><li>管道</li></ol><ul><li>管道只能采用<strong>半双工通信</strong>，某一时间段只能实现单向的传输，如果要实现<strong>双向同时通信</strong>，则需要设置两个管道。</li><li>各进程<strong>互斥</strong>地访问管道</li><li>当管道被写满的时候，写进程应该被阻塞。</li><li>当管道空的时候，读进程应该被阻塞。</li></ul><ol start="3"><li>Socket和 MQ</li></ol></li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ol><li>讲讲死锁发生的条件是什么？<ol><li>是资源分配是互斥的，资源要么处于被分配给一个进程的状态，要么就是可用状态。</li><li>等待和占有条件：进程在请求资源得不到满足的时候，进入阻塞等待状态，且不释放已占有的资源。</li><li>不剥夺条件：已经分配给一个进程的资源不能强制性地被抢占，只能等待占有他的进程释放。</li><li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程释放所占有的资源。</li></ol></li><li>如何避免死锁的发生？<ol><li>预防策略：从形成死锁的四个条件入手，打破这四个条件的一个或多个<ul><li>破坏互斥条件：比如只读文件、磁盘等软硬件资源可采用这种办法处理。</li><li>破坏占有和等待条件：在进程开始执行之前，就把其要申请的所有资源全部分配给他，直到所有资源都满足，才开始执行。</li><li>破坏不剥夺条件：允许进程强行从资源占有者那里夺取某些资源</li><li>破坏环路等待条件：给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次执行。</li></ul></li><li>避免死锁<ul><li>银行家算法</li></ul></li><li>如果发生了死锁怎么办？<ul><li>先检测到死锁</li><li>撤销进程法<ul><li>撤销陷于死锁的全部进程</li><li>逐个撤销陷于死锁的进程，直到思索不存在</li></ul></li><li>资源剥夺法<ul><li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失；</li><li>从另外的进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li></ul></li></ul></li></ol></li><li>你能举出一个死锁的例子吗？</li></ol><ul><li>假设生产者进程先加锁再检查缓冲区是否已满，而消费者进程先检查锁再访问缓冲区。当缓冲区满，生产者阻塞；消费者因锁被占用也阻塞，形成相互等待 —— 死锁。<blockquote><p>死锁问题的本质是对有限资源的不当管理，在设计并发程序时应优先关注资源分配顺序和锁粒度控制。</p></blockquote></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ol><li>内存管理的几种机制<br> 操作系统常见的内存管理机制包括分区管理、分页管理、分段管理和段页式管理。<ol><li><strong>分区管理</strong>（固定&#x2F;可变）<ul><li>最早的机制是将内存划分为若干固定大小或可变大小的区域（分区），每个进程占用一个区域。**缺点是会产生内部或外部碎片，且灵活性差，**因此被现代机制所取代。</li></ul></li><li><strong>分页管理</strong><ul><li>将逻辑地址空间划分为固定大小的页（Page），将物理内存划分为相同大小的页框（Frame），通过页表实现逻辑地址与物理地址的映射。<strong>分页提高了内存利用率，解决了外部碎片问题，但可能会增加访问开销。</strong></li></ul></li><li>分段管理<ul><li>将程序按照逻辑结构划分为多个段（如代码段、数据段、堆栈段等），每段具有独立的基址和长度，通过段表映射到物理内存。<strong>分段体现了程序的逻辑结构，便于共享和保护，但可能产生外部碎片。</strong></li></ul></li><li>段页式管理<ul><li>是分页与分段的结合。先将逻辑地址空间划分为段，再将每个段分页，结合段表和页表进行地址转换。<strong>该机制既保留了分段的逻辑性，又解决了分段带来的碎片问题，是现代操作系统广泛采用的方式。</strong></li></ul></li></ol></li><li>分页和分段有什么区别呢？</li></ol><ul><li>共同点的话：<ul><li>首先都是离散分配的，单每个页和每个段的内存是连续的。</li><li>都是为了提高内存利用率，减少内存碎片。</li></ul></li><li>不同点：<ul><li>分页式管理的页面大小是固定的，由操作系统决定；分段式管理的页面是由用户程序所决定的。</li><li>分页是为了满足操作系统内存管理的需求，每一页是没有实际的意义的；而段是有逻辑意义的，在程序中可认为是代码段、数据段。</li><li>分页的内存利用率高，不会产生外部碎片；而分段如果单段长度过大，为其分配很大的连续空间不方便，会产生外部碎片。</li></ul></li></ul><ol start="3"><li>讲讲分页管理的快表和多级页表（按照why how的方式来回答，即为什么出现快表，是如何解决痛点的）<br>why?</li></ol><h2 id="快表（TLB，Translation-Lookaside-Buffer）"><a href="#快表（TLB，Translation-Lookaside-Buffer）" class="headerlink" title="快表（TLB，Translation Lookaside Buffer）"></a>快表（TLB，Translation Lookaside Buffer）</h2><ol><li>为什么要有快表？（Why）<br>在分页管理中，<strong>每次内存访问前都要先查页表</strong>，再根据页表找到物理地址。这样一来，<strong>访问一个内存地址要两次内存访问</strong>（查页表 + 真正访问数据），开销非常大。为了优化访问速度，操作系统引入了快表（TLB），它是一个小型的、快速的硬件缓存，专门用来缓存<strong>页表项</strong>。</li><li>快表是如何工作的（How）<br>每次访问内存地址时，先用页号去查快表：</li></ol><ul><li>如果<strong>命中</strong>（也叫TLB Hit），就直接拿到对应的物理页框号，速度非常快；</li><li>如果<strong>不命中</strong>，就去查主存中的页表，查到后再把这个页表项加入快表；</li><li>如果快表满了，会使用替换策略（如LRU）淘汰掉旧的页表项。<blockquote><p>快表的设计基于<strong>局部性原理</strong>：最近访问的页很可能会被再次访问，所以把它缓存在硬件里可以大幅提高访问速度。</p></blockquote></li></ul><h2 id="多级页表（Multi-level-Page-Table）"><a href="#多级页表（Multi-level-Page-Table）" class="headerlink" title="多级页表（Multi-level Page Table）"></a>多级页表（Multi-level Page Table）</h2><ol><li><p>为什么要有多级页表？（Why）<br>在32位系统中，假如虚拟地址空间是4GB，页大小是4KB，那就需要<br>4𝐺𝐵&#x2F;4𝐾𝐵&#x3D;1𝑀 个页表项。每个页表项4字节，总共页表大小就是4MB，<strong>光是页表就占了很多内存</strong>，对资源是一种浪费。于是提出多级页表，用<strong>树形结构按需加载页表项，节省内存空间。</strong></p></li><li><p>多级页表是怎么工作的？（How）<br>以两级页表为例，虚拟地址被分成三部分：</p></li></ol><ul><li>一级页表索引</li><li>二级页表索引</li><li>页内偏移<br>访问地址时，先根据一级索引找到对应的二级页表地址，再用二级索引找到具体页表项，最后加上页内偏移得到物理地址。<br>多级页表的好处是：只有用到的页表项才会被加载到内存中，节省了大量内存空间，但代价是地址转换过程变长（可以通过快表优化）。</li></ul><ol start="4"><li>讲讲虚拟内存</li></ol><h2 id="一、为什么需要虚拟内存？（Why）"><a href="#一、为什么需要虚拟内存？（Why）" class="headerlink" title="一、为什么需要虚拟内存？（Why）"></a>一、为什么需要虚拟内存？（Why）</h2><p>早期的程序运行时，必须整个程序全部装入内存才能执行。这个方式有几个问题：</p><ul><li>程序太大时根本装不下；</li><li>多个程序同时运行，内存不够用；</li><li>程序之间容易互相干扰，缺乏隔离性。<br>而事实上，程序在某个时刻真正会用到的数据往往只是很小一部分，所以我们没必要一次性全部加载。这就引出了虚拟内存的概念。</li></ul><h2 id="二、虚拟内存是怎么实现的？（How）"><a href="#二、虚拟内存是怎么实现的？（How）" class="headerlink" title="二、虚拟内存是怎么实现的？（How）"></a>二、虚拟内存是怎么实现的？（How）</h2><p>虚拟内存的核心思想是：让程序以为它有一整块连续的内存空间，而操作系统背后悄悄地在做“地址映射”和“按需加载”。<br>具体来说：</p><ul><li>每个进程<strong>有一个虚拟地址空间</strong>，和物理内存空间隔离；</li><li>程序执行时，只<strong>加载当前需要的页面</strong>，其余放在磁盘（也叫“后备存储”）；</li><li>如果程序访问了一个不在内存的页，会触发<strong>缺页中断</strong>；</li><li>操作系统此时从磁盘中把该页加载进内存；</li><li>如果内存满了，还会触发<strong>页面置换</strong>，将旧的页换出去，把新的页换进来。<blockquote><p>这一整套机制依赖于硬件支持的<strong>地址映射（MMU）</strong>，以及操作系统的<strong>分页管理、页面置换算法和缺页中断机制。</strong></p></blockquote></li></ul><ol start="5"><li><p>虚拟内存的三种实现技术？</p><ol><li>请求分页式存储管理<ul><li>程序运行时只加载当前需要的部分；</li><li>没有加载的部分先留在磁盘中；</li><li>一旦访问未加载的部分，就<strong>触发缺页（或缺段）中断</strong>，把需要的数据调入内存；</li><li>若内存不足，还要进行<strong>页面或段的置换。</strong><blockquote><p>核心目标都是：<strong>基于局部性原理，按需加载，提高内存利用率。</strong></p></blockquote></li></ul></li><li>请求分段式存储管理</li><li>请求段页式存储管理（主流，先分段再分页）</li></ol></li><li><p>讲讲页面置换算法？</p></li></ol><h2 id="一、为什么需要页面置换？（Why）"><a href="#一、为什么需要页面置换？（Why）" class="headerlink" title="一、为什么需要页面置换？（Why）"></a>一、为什么需要页面置换？（Why）</h2><p>在请求分页的机制下，程序访问的页面不一定都在内存中，一旦访问了不在内存的页面，就会产生缺页中断。如果这时内存已经满了，就需要将某个当前在内存中的页面换出去，把新的页面换进来，这就需要用到页面置换算法。换句话说，页面置换就是一种淘汰策略，目的是在内存空间有限的前提下，尽量保留“有用的页面”，提高命中率。</p><h2 id="二、常见的页面置换算法（How）"><a href="#二、常见的页面置换算法（How）" class="headerlink" title="二、常见的页面置换算法（How）"></a>二、常见的页面置换算法（How）</h2><ol><li>OPT（最优置换算法）</li></ol><ul><li>思想：总是淘汰未来最长时间不会用到的页面。</li><li>优点：命中率最高，是理想状态的上限。</li><li>缺点：无法实现，因为操作系统无法预知未来。<blockquote><p>一般用于评估其他算法性能的理论上限。</p></blockquote></li></ul><ol start="2"><li>FIFO（先进先出）</li></ol><ul><li>思想：按页面进入内存的先后顺序，最早进入的最先淘汰。</li><li>优点：实现简单，基于队列结构。</li><li>缺点：可能淘汰掉频繁使用的页面，存在Belady异常（页框变多反而缺页率升高）。</li></ul><ol start="3"><li>LRU（最近最久未使用）</li></ol><ul><li>思想：淘汰最长时间没被访问的页面，基于时间局部性原理。</li><li>实现方式有：<ul><li>使用链表或栈，记录访问顺序；</li><li>用时间戳、计数器等辅助信息。</li></ul></li><li>优点：性能较好，效果接近OPT。</li><li>缺点：实现复杂，开销大，需要硬件支持或软件模拟。</li></ul><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ol><li>文件系统主要做了什么？</li></ol><ul><li>文件系统主要负责管理和组织计算机存储设备上的文件和目录<ol><li>存储管理：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够多的空间存储。</li><li>文件管理：文件的创建、删除、移动、重命名、压缩、加密、共享等。</li><li>目录管理：目录的创建、删除、移动、重命名。</li><li>文件访问控制：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权的文件，保证文件的安全性和保密性。</li></ol></li></ul><ol start="2"><li>硬链接和软链接有什么区别？<ol><li>硬链接<ul><li>在 Linux&#x2F;类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li><li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li><li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li><li><code>ln</code>命令用于创建硬链接。</li></ul></li><li>软链接（Symbolic Link 或 Symlink）<ul><li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li><li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li><li>软连接类似于 Windows 系统中的快捷方式。</li><li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li><li>ln -s 命令用于创建软链接。</li></ul></li></ol></li><li>硬链接为什么不能跨文件系统？</li></ol><ul><li>硬链接是通过 inode 节点号建立连接的，而硬链接和源文件共享相同的 inode 节点号。然而，每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。</li></ul><ol start="4"><li>提高文件系统性能的方式有哪些？</li></ol><ul><li>优化硬件：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘，使用 RAID（Redundant Array of Inexpensive Disks）等技术提高磁盘性能。</li><li>选择合适的文件系统选型：不同的文件系统具有不同的特性，对于不同的应用场景选择合适的文件系统可以提高系统性能。</li><li>运用缓存：访问磁盘的效率比较低，可以运用缓存来减少磁盘的访问次数。不过，需要注意缓存命中率，缓存命中率过低的话，效果太差。</li><li>避免磁盘过度使用：注意磁盘的使用率，避免将磁盘用满，尽量留一些剩余空间，以免对文件系统的性能产生负面影响。</li><li>对磁盘进行合理的分区：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。</li></ul><ol start="5"><li>常见的磁盘调度算法<ol><li>先来先服务算法（First-Come First-Served，FCFS）：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。</li><li>最短寻道时间优先算法（Shortest Seek Time First，SSTF）：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。</li><li>扫描算法（SCAN）：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。</li><li>循环扫描算法（Circular Scan，C-SCAN）：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点(0)，重新开始循环。</li><li>均衡循环扫描算法（C-LOOK）：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且<strong>磁头只需要返回到有磁道访问请求的位置即可</strong>。</li><li>边扫描边观察算法（LOOK）：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 八股文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2025/05/30/RocketMQ/"/>
      <url>/2025/05/30/RocketMQ/</url>
      
        <content type="html"><![CDATA[<p>实际开发：短信分发，第一次进行预处理 用三个消息队列分别存储 ： 移动&#x2F;联通&#x2F;电信的号码</p><h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>MQ ： Message Queue 消息队列，是在<strong>消息传输过程中保存消息的容器</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530124156919.png"></p><h3 id="1-优势"><a href="#1-优势" class="headerlink" title="1.优势"></a>1.优势</h3><ol><li>应用解耦</li></ol><ul><li>耦合度：指的是模块或组件之间的依赖程度。耦合度越高，容错越低。</li><li>防止消费者&#x2F;生产者某一方崩了导致整个流程崩溃。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530125404194.png"> <blockquote><p>提高系统容错性以及可维护性</p></blockquote></li></ul><ol start="2"><li>异步提速</li></ol><ul><li>生产方发完消息，可以继续下一步业务逻辑。<blockquote><p>提升用户体验和系统吞吐量</p></blockquote></li></ul><ol start="3"><li>削峰填谷<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530130717717.png"><br>相当于数据先打到缓存中，然后消费者从缓存中拿数据，而不是直接打到消费者，如果1w&#x2F;s打到物流系统会崩溃<blockquote><p>提高系统稳定性</p></blockquote></li></ol><h3 id="2-劣势"><a href="#2-劣势" class="headerlink" title="2.劣势"></a>2.劣势</h3><ol><li>系统可用性降低</li></ol><ul><li>如果MQ崩了，就会对业务造成影响。<blockquote><p>如何保障MQ的高可用？</p></blockquote></li></ul><ol start="2"><li>系统复杂度提高<br>如何保障消息没有被重复消费，如何处理信息丢失，如何保障信息传递的顺序性</li><li>一致性问题<br>A处理完业务通过MQ发给BCD，BC都成功处理，那D处理失败，如何保障消息处理数据的一致性？</li></ol><h2 id="RocketMQ-工作原理总结"><a href="#RocketMQ-工作原理总结" class="headerlink" title="RocketMQ 工作原理总结"></a>RocketMQ 工作原理总结</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250530134621660.png"><br>RocketMQ 主要由以下四个核心组件组成：</p><h3 id="1-Producer（消息生产者）"><a href="#1-Producer（消息生产者）" class="headerlink" title="1. Producer（消息生产者）"></a>1. Producer（消息生产者）</h3><ul><li>负责发送消息到 Broker。</li><li>启动时向 NameServer 获取 Topic 的路由信息。</li><li>根据路由选择合适的 Broker 和队列进行发送。</li><li>支持普通消息、顺序消息、事务消息、延迟消息等。</li></ul><h3 id="2-NameServer（注册中心）"><a href="#2-NameServer（注册中心）" class="headerlink" title="2. NameServer（注册中心）"></a>2. NameServer（注册中心）</h3><ul><li>提供轻量级服务注册与发现。</li><li>Broker 启动时将自身信息（Topic、IP、端口等）注册到多个 NameServer。</li><li>Producer 和 Consumer 从 NameServer 拉取最新路由信息。</li><li>是无状态、可水平扩展的集群。</li></ul><h3 id="3-Broker（消息中转与存储）"><a href="#3-Broker（消息中转与存储）" class="headerlink" title="3. Broker（消息中转与存储）"></a>3. Broker（消息中转与存储）</h3><ul><li>接收来自 Producer 的消息，进行持久化存储。</li><li>按 Topic 和 Queue 分类组织消息。</li><li>支持主从架构，提升高可用性。</li><li>提供消费进度管理、消息拉取服务等。</li></ul><h3 id="4-Consumer（消息消费者）"><a href="#4-Consumer（消息消费者）" class="headerlink" title="4. Consumer（消息消费者）"></a>4. Consumer（消息消费者）</h3><ul><li>从 NameServer 获取路由并从指定 Broker 拉取消息。</li><li>支持集群模式（负载均衡）和广播模式（每个消费者都收到）。</li><li>支持 Push 或 Pull 两种消费方式。</li><li>消费成功后提交消费进度（Offset）。</li></ul><hr><h3 id="消息流动过程（简述）"><a href="#消息流动过程（简述）" class="headerlink" title="消息流动过程（简述）"></a>消息流动过程（简述）</h3><ol><li>Broker 启动并向 NameServer 注册。</li><li>Producer 启动并向 NameServer 获取路由信息。</li><li>Producer 向 Broker 发送消息。</li><li>Consumer 向 NameServer 获取路由，并从 Broker 拉取消息。</li><li>Consumer 消费消息并提交 Offset。</li></ol><hr><h3 id="特性支持"><a href="#特性支持" class="headerlink" title="特性支持"></a>特性支持</h3><ul><li>✅ 高吞吐、低延迟</li><li>✅ 顺序消息、事务消息、延迟消息</li><li>✅ 主从架构支持高可用</li><li>✅ 消费进度可控（精确到队列和偏移量）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>juc</title>
      <link href="/2025/05/28/juc/"/>
      <url>/2025/05/28/juc/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><h3 id="1-进程与线程-1"><a href="#1-进程与线程-1" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><ol><li>进程</li></ol><ul><li>程序由指令和数据组成，指令需要运行，数据需要读写，就要将指令加载到cpu上，数据加载至内存。在指令运行过程中还需要使用磁盘，网络等设备。 进程就是用来加载指令、管理内存、管理I&#x2F;O的。</li><li>当一个程序被运行，指令代码被加载至内存，这时就开启了一个进程。</li><li>进程可以视为程序的一个实例。有些可以多开（记事本），有些只能开一个（网易云）</li></ul><ol start="2"><li>线程</li></ol><ul><li>一个进程之内可以有多个线程</li><li>一个线程就是一个指令流，是 CPU 调度的基本单位，线程按照一定顺序执行代码，多个线程可以并发地被 CPU 核心调度执行。</li><li>java中，线程作为最小调度单位，进程作为资源分配最小单位。</li></ul><hr><p>两者对比</p><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为IPC(Inter-process communication) 常见的 IPC 方式包括管道（pipe）、共享内存、消息队列、socket 等。</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h3 id="3-并行与并发"><a href="#3-并行与并发" class="headerlink" title="3.并行与并发"></a>3.并行与并发</h3><ul><li>并发(concurrency)：同一时间应对(dealing with)多件事情</li><li>并行(parallel)：同一时间动手做(doing)多件事情的能力</li></ul><h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>同步&amp;&amp;异步调用<br>从方法调用的角度来说，如果</p><blockquote><p>类比：去奶茶店点单后站在原地等，做好了再走。 同步（调用一个方法，要等它执行完，拿到结果才能继续。）<br>类比：下单后坐下玩手机，等叫号取奶茶。 异步（调用一个方法后，不用等它完成，可以继续做别的事，结果准备好后再通知你。）</p></blockquote><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h3><ul><li>单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使<br>用cpu，不至于一个线程总占用cpu，别的线程没法干活</li><li>多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li>IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞IO】和【异步IO】优化</li></ul><h2 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2.Java线程"></a>2.Java线程</h2><h3 id="1-创建和运行线程"><a href="#1-创建和运行线程" class="headerlink" title="1.创建和运行线程"></a>1.创建和运行线程</h3><p>创建线程有三个方法</p><ol><li>方法一，直接创建</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二，使用runnable对象，使用lambda表达式简化，可以在方法二的基础上使用alt+enter让idea自己改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">void</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;我是线程哈哈哈&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是进程哈哈哈&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用任务和线程分开的写法好一些。</p><h3 id="2-原理之线程运行"><a href="#2-原理之线程运行" class="headerlink" title="2.原理之线程运行"></a>2.原理之线程运行</h3><h4 id="1-运行原理"><a href="#1-运行原理" class="headerlink" title="1.运行原理"></a>1.运行原理</h4><p>每个线程启动后，虚拟机会为其分配一块栈内存</p><ul><li>每个栈由多个栈帧组成，对应着每次方法调用使用的内存。</li><li>每个线程只能有一个活动栈帧。</li></ul><h4 id="2-线程上下文切换（Thread-Context-Switch）"><a href="#2-线程上下文切换（Thread-Context-Switch）" class="headerlink" title="2.线程上下文切换（Thread Context Switch）"></a>2.线程上下文切换（Thread Context Switch）</h4><ul><li>原因：<ul><li>cpu时间用完</li><li>垃圾回收（gc）</li><li>有更高优先级的线程运行</li><li>线程自己调用了sleep,yield,wait,join,synchronized,lock等方法</li></ul></li><li>当ContextSwitch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是程序计数器(ProgramCounter Register)，它的作用是记住下一条jvm指令的执行地址，是线程私有的<ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>ContextSwitch频繁发生会影响性能</li></ul></li></ul><h3 id="3-线程中的常见方法"><a href="#3-线程中的常见方法" class="headerlink" title="3.线程中的常见方法"></a>3.线程中的常见方法</h3><h4 id="run-VS-start"><a href="#run-VS-start" class="headerlink" title="run VS start"></a>run VS start</h4><ul><li>run()只是普通方法调用，不会并发</li><li><strong>start才是启动线程</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">System.out.println(t1.getState());</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(t1.getState());</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(t1.getState());</span><br></pre></td></tr></table></figure><p>记住，start只能调用一次，会让state变为runnable。</p><h4 id="sleep-VS-yield"><a href="#sleep-VS-yield" class="headerlink" title="sleep VS yield"></a>sleep VS yield</h4><ul><li>sleep<ol><li>调用sleep会让当前线程从Running进入Timed Waiting状态（阻塞）</li><li>其它线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行（不能够马上获得cpu，看线程的状态）</li><li>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</li></ol></li><li>yield（让出，谦让）<ol><li>调用yield会让当前线程从Running变为runnable就绪态，然后调度执行其他线程</li><li>具体的实现依赖于OS<br>应用：防止CPU占用100%<br>在没有利用cpu进行计算的时候，不要让while(true)空转浪费cpu，可以使用yield或sleep让出cpu的使用权</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以使用wait &#x2F; 条件变量达到类似效果</li><li>不同的是，后两种都需要加锁，并且需要相应的唤醒(notify &#x2F; notifyall)操作，一般适用于要同步的场景<ul><li>wait() 必须放在 <strong>synchronized</strong> 中；</li><li>被 wait() 的线程会<strong>释放锁并阻塞</strong>；</li><li>notify() 在同一个锁对象上唤醒一个线程，notifyAll() 唤醒所有等待线程。</li></ul></li><li>sleep适用于无需锁同步的场景</li></ul><h4 id="interrupt-isInterrupted-interrupted"><a href="#interrupt-isInterrupted-interrupted" class="headerlink" title="interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()"></a>interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()</h4><ul><li>thread.interrupt();<ul><li>并不会立刻杀死线程！</li><li>它只是设置线程的“中断标志位”为 true</li><li>如果线程正在 sleep、wait、join 等阻塞操作，会抛出 InterruptedException 异常</li></ul></li><li>Thread.currentThread().isInterrupted();<ul><li>返回当前线程的中断状态（true&#x2F;false）</li><li>不会清除这个标志位</li></ul></li><li>Thread.interrupted(); &#x2F;&#x2F; 检查当前线程是否中断，并清除标志位<blockquote><p>Thread.interrupted()：“我看一下我被打断没？顺便把这事忘了”<br>isInterrupted()：“我看你有没有被打断，我不动你状态”</p></blockquote></li></ul><h5 id="拓展：设计模式（两阶段终止）"><a href="#拓展：设计模式（两阶段终止）" class="headerlink" title="拓展：设计模式（两阶段终止）"></a>拓展：设计模式（两阶段终止）</h5><blockquote><p>有两个线程t1和t2，t2已经完成了，t1该如何帮t2料理后事？</p></blockquote><ul><li>不能使用暴力stop()，因为t2可能有一些上了锁的资源，当t2被杀死后就再也没有机会释放锁，导致其它线程无法获得锁。</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程是为用户线程提供服务的线程。当所有用户线程都结束时，守护线程会被 JVM 自动终止，不会阻止程序退出。</p><h5 id="GC-是守护线程的例子"><a href="#GC-是守护线程的例子" class="headerlink" title="GC 是守护线程的例子"></a>GC 是守护线程的例子</h5><ul><li>JVM 启动时会创建 GC 守护线程</li><li>它在后台自动运行，清理不再使用的对象</li><li>主线程（用户线程）结束后，GC 守护线程也会随 JVM 退出而结束</li><li>守护线程适合执行日志、监控、GC 等后台任务</li></ul><h2 id="3-共享模型之管程-Monitor"><a href="#3-共享模型之管程-Monitor" class="headerlink" title="3.共享模型之管程(Monitor)"></a>3.共享模型之管程(Monitor)</h2><h3 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1.共享带来的问题"></a>1.共享带来的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">sout(cnt);</span><br></pre></td></tr></table></figure><p>不一定是0。<br>多个线程<strong>对共享资源进行读写操作</strong>，上下文交换引起的指令交错<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250528160715423.png"></p><ul><li>问题出现在多个线程访问<strong>共享资源</strong></li><li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为临界区</li><li>竞态条件（Race Condition）<ul><li>多个线程在临界区内执行，由于代码的执行顺序不同而导致结果无法预测，称之发生了<strong>静态条件</strong></li></ul></li></ul><h3 id="2-静态条件解决方案"><a href="#2-静态条件解决方案" class="headerlink" title="2.静态条件解决方案"></a>2.静态条件解决方案</h3><ul><li>阻塞式<ul><li>Synchronized、lock</li></ul></li><li>非阻塞式<ul><li>原子变量</li></ul></li></ul><h4 id="synchronized（对象锁）"><a href="#synchronized（对象锁）" class="headerlink" title="synchronized（对象锁）"></a>synchronized（对象锁）</h4><ol><li>语法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">    <span class="comment">//临界区代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类比说明"><a href="#类比说明" class="headerlink" title="类比说明"></a>类比说明</h5><ul><li>把 <code>obj</code> 想象成一个 <strong>房间</strong>，房间只有一个 <strong>门</strong>。</li><li>每个线程（如 <code>t1</code>、<code>t2</code>）就像是 <strong>想进房间干活的人</strong>。</li><li>一次只能一个线程进房间，其他线程必须在门外 <strong>排队等待</strong>。</li></ul><hr><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><ol><li><code>t1</code> 运行到 <code>synchronized(obj)</code><br>→ 拿到钥匙，进入房间（获得锁）<br>→ 门被锁上，其他线程进不来。</li><li><code>t2</code> 也运行到 <code>synchronized(obj)</code><br>→ 发现门被锁，<strong>阻塞在门外</strong>，等待钥匙。</li><li><code>t1</code> 时间片用完，被系统挂起<br>→ 虽然暂停了，但<strong>钥匙还在它手上</strong>（锁未释放）<br>→ <code>t2</code> 仍无法进入房间。</li><li><code>t1</code> 被重新调度回来<br>→ 执行完同步代码块，<strong>出门还钥匙</strong>（释放锁）<br>→ 唤醒 <code>t2</code>，<code>t2</code> 拿到钥匙进入房间继续执行。</li></ol><hr><h6 id="关键类比总结"><a href="#关键类比总结" class="headerlink" title="关键类比总结"></a>关键类比总结</h6><table><thead><tr><th>Java 概念</th><th>房间类比</th></tr></thead><tbody><tr><td>锁对象（如 obj）</td><td>房间</td></tr><tr><td>synchronized(obj)</td><td>进入房间前先锁门</td></tr><tr><td>获得锁</td><td>拿到钥匙，进入房间</td></tr><tr><td>阻塞线程</td><td>在门外排队等待钥匙</td></tr><tr><td>释放锁</td><td>出门还钥匙，唤醒别人</td></tr></tbody></table><h6 id="面向对象加锁"><a href="#面向对象加锁" class="headerlink" title="面向对象加锁"></a>面向对象加锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                r.Increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                r.Decrease();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        r.getCnt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increase</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Decrease</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCnt</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="在方法上加锁"><a href="#在方法上加锁" class="headerlink" title="在方法上加锁"></a>在方法上加锁</h6><ol><li>在实例上加锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在类上加锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>this 就像你家门 → 每家自己锁</li><li>Test.class 就像整栋楼大门 → 所有人公用<br>区别是静态方法（类对象） 非静态方法（当前实例）<br>synchronized锁的是当前实例，Test锁的是整个类<br>搜 <code>线程八锁</code>进行练习，主要分析锁住的是不是同一个对象，如果不是同一个对象，那就是并行，不存在多线程；是同一个对象，就是并发。<br>实例方法加锁锁 this，每个对象一把锁；<br>静态方法加锁锁 class，全类共用一把锁；<br>不同对象加锁不冲突，相同对象才竞争；<br>类锁和实例锁互不影响。</li></ul><h4 id="线程安全：局部变量-vs-静态变量"><a href="#线程安全：局部变量-vs-静态变量" class="headerlink" title="线程安全：局部变量 vs 静态变量"></a>线程安全：局部变量 vs 静态变量</h4><h5 id="局部变量是线程安全的"><a href="#局部变量是线程安全的" class="headerlink" title="局部变量是线程安全的"></a>局部变量是线程安全的</h5><ul><li>每次方法调用会创建新的栈帧</li><li>局部变量存放在线程独立的栈中，不共享，不冲突</li></ul><h5 id="静态变量是线程不安全的"><a href="#静态变量是线程不安全的" class="headerlink" title="静态变量是线程不安全的"></a>静态变量是线程不安全的</h5><ul><li>静态变量属于类，全局共享</li><li>多线程访问会产生数据竞争，必须加锁保护</li></ul><hr><h5 id="习题：银行账户转账"><a href="#习题：银行账户转账" class="headerlink" title="习题：银行账户转账"></a>习题：银行账户转账</h5><p>两个账户 <code>a</code> 和 <code>b</code>，线程 T1 从 a 转账到 b，T2 从 b 转账到 a<br>如果两个账户是不同对象，用 <code>synchronized(this)</code> 是不安全的，因为<strong>锁的是两个不同的对象</strong>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">        target.balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Monitor底层原理-（这里去看jvm的jmm）"><a href="#Monitor底层原理-（这里去看jvm的jmm）" class="headerlink" title="Monitor底层原理 （这里去看jvm的jmm）"></a>Monitor底层原理 （这里去看jvm的jmm）</h3><p>Monitor被翻译为<strong>监视器或管程</strong>，可以理解为提到的<strong>锁</strong></p><ul><li>第一个线程获得对象的锁后，成为owner</li><li>后续来的线程发现owner被占用，只能进入等待队列并切换状态为阻塞</li><li>当临界区代码被执行完后，owner空出，通知Monitor唤醒阻塞队列的线程，（此时的阻塞队列竞争是非公平的，不一定是先进来的就先得到锁）</li><li>对象总是与一个monitor相关联的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529100222307.png"></li></ul><h3 id="notify-和wait"><a href="#notify-和wait" class="headerlink" title="notify()和wait()"></a>notify()和wait()</h3><p>在重量级锁的环境下，一个线程如果缺乏资源，就会调用wait方法<strong>主动放弃锁</strong>，进入等待池，自己的状态设置为waiting；等到别的线程将资源送来了，就会调用notify，告诉这个线程资源来了，这时候第一个线程就会离开等待池，状态变为blocking，进入锁池(EntryList)重新去竞争锁。</p><h3 id="park-和unpark"><a href="#park-和unpark" class="headerlink" title="park()和unpark()"></a>park()和unpark()</h3><p><code>park()</code> 和 <code>unpark()</code> 是 Java 中底层线程阻塞&#x2F;唤醒的原语，属于 <code>LockSupport</code> 类提供的工具，用于实现更灵活的并发控制（比 <code>wait/notify</code>、<code>sleep/yield</code> 更底层、更强大）。</p><h3 id="锁的活跃性"><a href="#锁的活跃性" class="headerlink" title="锁的活跃性"></a>锁的活跃性</h3><ul><li>死锁：各自持一把锁，又都想获得对方的锁，哲学家问题<br>  <strong>产生死锁的条件</strong><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待 ✅ （最常通过避免循环等待解决）<br>  <strong>解决策略</strong></li><li>固定加锁顺序：如先锁 A 再锁 B，所有线程统一顺序，避免循环等待。</li><li>使用 tryLock()：尝试加锁，失败就放弃，避免永久等待。</li><li>死锁检测与恢复：定期检测资源等待图，发现死锁强制中断线程（一般用于数据库&#x2F;操作系统）。</li></ul></li><li>饥饿：线程<strong>优先级不公平</strong>、<strong>锁分配不均</strong><br>  解决策略<ul><li>使用 公平锁：如 <code>ReentrantLock(true)</code>，按请求顺序分配锁；</li><li>避免线程优先级过高差距；</li><li>控制资源分配策略，避免让某些线程长期得不到调度。</li></ul></li><li>活锁：</li></ul><h4 id="ReentrantLock-可重入锁，公平锁"><a href="#ReentrantLock-可重入锁，公平锁" class="headerlink" title="ReentrantLock(可重入锁，公平锁)"></a>ReentrantLock(可重入锁，公平锁)</h4><ol><li>优点</li></ol><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置公平锁</li><li>支持多个条件变量（所有条件满足了才从waitSet出来去锁池）<blockquote><p>与synchronized一样支持<strong>可重入</strong></p></blockquote></li></ul><ol start="2"><li>可重入</li><li>语法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 非公平锁（默认）</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">unfairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure><ol start="4"><li>条件变量</li></ol><ul><li>用于线程间通信，代替 wait() 和 notify()；</li><li>支持多个等待队列（更细粒度的控制）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><blockquote><p>ReentrantLock + Condition：可以为不同条件建多个等待队列（每个condition内部有一个独立的等待队列）</p><ol start="5"><li>锁超时</li></ol></blockquote><ol start="6"><li>总结</li></ol><ul><li>ReentrantLock 是显式锁，功能强于 synchronized；</li><li>支持更细粒度的锁策略；</li><li>搭配 Condition 可实现更复杂的线程通信模型；</li><li><strong>需手动释放锁，推荐 try-finally 结构</strong>。</li></ul><h2 id="4-共享模型之不可变"><a href="#4-共享模型之不可变" class="headerlink" title="4.共享模型之不可变"></a>4.共享模型之不可变</h2><ol><li>什么是Java中的不可变类</li></ol><ul><li>不可变类是指无法修改对象的值（<strong>无法继承、线程安全</strong>），String不可变<ul><li>追问：怎么实现不可变类？<ul><li>通过看String的源码，String添加了final(类似于cpp的const)关键字，并且是private对象</li><li>替换方法replace()的实现是返回一个新的字符串。</li></ul></li></ul></li></ul><h2 id="5-并发工具"><a href="#5-并发工具" class="headerlink" title="5.并发工具"></a>5.并发工具</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-ThreadPoolExcutor"><a href="#1-ThreadPoolExcutor" class="headerlink" title="1.ThreadPoolExcutor"></a>1.ThreadPoolExcutor</h4><ol><li>线程池状态<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529164801644.png" alt="线程池状态"></li></ol><ul><li>五状态：Running、Shutdown、Stop、Tidying、Terminated<br>Shutdown就像终结对方的连胜，但不代表这局游戏结束咯。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529165203047.png"><br>数字比较，是有符号数，最高位为-4，也可以去看ThreadPoolExecutor的源码</li></ul><ol start="2"><li>线程池构造方法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529165901446.png" alt="线程池构造方法"></li></ol><ul><li>corePoolSize核心线程数目（最多保留的线程数）</li><li>maximumPoolSize最大线程数目</li><li>keepAliveTime生存时间-针对救急线程</li><li>unit时间单位-针对救急线程</li><li>workQueue阻塞队列</li><li>threadFactory线程工厂-可以为线程创建时起个好名字</li><li>handler拒绝策略<blockquote><p>最大线程数 &#x3D; 核心线程数 + 救急线程数</p></blockquote></li><li>核心线程和救急线程的区别？<ul><li>核心线程在任务执行完成后仍留在线程池中，救急线程执行完后会离开线程池。（外包）</li></ul></li></ul><h4 id="2-Fork-Join"><a href="#2-Fork-Join" class="headerlink" title="2.Fork&#x2F;Join"></a>2.Fork&#x2F;Join</h4><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1.AQS"></a>1.AQS</h4><p>全称是：AbstractQueuedSynchronized，是<strong>阻塞式锁</strong>和相关的同步器工具的框架<br><strong>AQS 就是一套模板机制，你通过实现它的几个抽象方法，就可以“自定义一把锁”或“同步器”</strong></p><ul><li>特点：<ul><li>用<code>state</code>属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获得锁和释放锁<ul><li>getState：获取state状态</li><li>setState：设置state状态</li><li>compareAndSetState：乐观锁机制设置state状态</li><li>独占模式只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>基于FIFO的等待队列，类似于monitor的Entrylist</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor 的 WaitSet</li></ul></li><li>子类要实现下列方法<ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul></li><li>并发工具类：是一个能让多个线程安全的去访问共享资源的一个工具，每个线程访问的时候要去<strong>判断</strong>当前共享资源是否被占用，是否正在被访问；如果没有线程访问，那当前线程就可以访问；如果当前资源被访问了，要么<strong>重试</strong>，要么<strong>阻塞</strong>，要么<strong>放弃</strong>。</li><li>如何表示共享资源当前正在被访问呢？<ul><li>状态变量。为0时表示空闲，为1时表示被占有，同样是Reentrantlock的思想</li><li>公平策略：AQS是基于FIFO的队列设计的，只需要重写tryAcquire方法就可以自定义公平&#x2F;非公平策略了</li></ul></li><li>Reentrantlock和Synchronized有什么区别？<ul><li>Reentrantlock基于FIFO实现了公平锁和非公平锁；而Synchronized都是非公平</li></ul></li></ul><h4 id="2-Reentrantlock"><a href="#2-Reentrantlock" class="headerlink" title="2.Reentrantlock"></a>2.Reentrantlock</h4><ul><li>类型：独占、可重入、支持公平&#x2F;非公平</li><li>关键 AQS 方法：tryAcquire() &#x2F; tryRelease()</li><li>state 表示：当前线程持有锁的次数（支持递归加锁）</li><li>典型用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3.Semaphore"></a>3.Semaphore</h4><ul><li>类型：共享锁</li><li>关键 AQS 方法：tryAcquireShared() &#x2F; tryReleaseShared()</li><li>state 表示：剩余可用许可数量</li><li>典型用法：限流、连接池并发控制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire();   <span class="comment">// 获取许可</span></span><br><span class="line">semaphore.release();   <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure><h4 id="4-CountDownLatch-（倒计时锁）"><a href="#4-CountDownLatch-（倒计时锁）" class="headerlink" title="4.CountDownLatch （倒计时锁）"></a>4.CountDownLatch （倒计时锁）</h4><ul><li>类型：共享同步器（不可重置）</li><li>关键 AQS 方法：tryAcquireShared()（为 0 才通过） &#x2F; tryReleaseShared()</li><li>state 表示：倒计时数量</li><li>典型用法：等待多个线程完成后再执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">latch.countDown(); <span class="comment">// 调用 3 次后 latch.await() 才能继续，countDown计数--</span></span><br><span class="line">latch.await(); <span class="comment">//等待计数归零</span></span><br></pre></td></tr></table></figure><h4 id="5-ReentrantReadWriteLock"><a href="#5-ReentrantReadWriteLock" class="headerlink" title="5.ReentrantReadWriteLock"></a>5.ReentrantReadWriteLock</h4><ul><li>类型：读锁共享，写锁独占</li><li>关键点：<ul><li>写锁使用 tryAcquire()，互斥；</li><li>读锁使用 tryAcquireShared()，可多个同时获取；</li></ul></li><li>state 表示：高 16 位写锁计数，低 16 位读锁计数（位运算拆解）</li><li>典型用法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readLock.lock();   <span class="comment">// 多线程可以同时读</span></span><br><span class="line">writeLock.lock();  <span class="comment">// 写操作互斥，读写互斥</span></span><br></pre></td></tr></table></figure><h4 id="6-FutureTask"><a href="#6-FutureTask" class="headerlink" title="6.FutureTask"></a>6.FutureTask</h4><ul><li>类型：任务状态控制器（封装线程执行结果）</li><li>关键 AQS 方法：用独占锁管理任务执行与等待线程；</li><li>state 表示：任务状态（NEW、RUNNING、COMPLETED）</li><li>典型用法：配合线程池异步获取结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">task.get(); <span class="comment">// 等待并获取结果</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2025/05/27/jvm/"/>
      <url>/2025/05/27/jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h2><ul><li>定义：Java Virtual Machine <strong>java程序的运行环境（更确切：java二进制字节码的运行环境）</strong></li><li>好处：<ul><li>一次编写，到处运行的基石（跨平台）</li><li>自动内存管理，垃圾回收功能（垃圾回收处理<strong>堆内存</strong>的无用对象）</li><li>数组下标越界检查</li><li>多态</li></ul></li><li>比较：<strong>Jvm Jre Jdk的关系</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527085752230.png"></li></ul><h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><h3 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul><li>Program Counter Register 使用<strong>寄存器</strong>实现</li></ul><h4 id="2-作用："><a href="#2-作用：" class="headerlink" title="2. 作用："></a>2. 作用：</h4><ul><li>记住下一条jvm指令的执行地址</li></ul><h4 id="3-特点："><a href="#3-特点：" class="headerlink" title="3. 特点："></a>3. 特点：</h4><ul><li>线程私有：每一个线程都是独立的，都有自己的时间片，以及自己的程序计数器</li><li>不会存在内存溢出</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="1-定义（java-virtual-machine-stacks）"><a href="#1-定义（java-virtual-machine-stacks）" class="headerlink" title="1. 定义（java virtual machine stacks）"></a>1. 定义（java virtual machine stacks）</h4><ul><li>每个线程运行时所需要的内存称为虚拟机栈，<strong>线程私有</strong></li><li>栈由多个<strong>栈帧（Frame）组成，每个栈帧对应一次方法调用。</strong></li><li>每个线程只能有一个活动栈帧，<strong>对应着当前正在执行的那个方法</strong>（人话：栈顶）</li></ul><h4 id="2-问题辨析："><a href="#2-问题辨析：" class="headerlink" title="2. 问题辨析："></a>2. 问题辨析：</h4><ol><li>垃圾回收是否涉及栈内存？<ul><li>不涉及。虚拟机栈随着方法调用自动创建和销毁，不由 GC 管理。</li></ul></li><li>栈内存分配越大越好吗？<ul><li>大栈空间意味着系统能够同时创建的线程数减少，影响并发能力。 比如栈空间1m，物理内存500m，可以跑500个线程，但如果栈空间2m，只能跑250个线程。</li><li>上下文切换开销大，线程切换需要<strong>保存&#x2F;恢复</strong>上下文信息。</li><li>若程序调用栈不深，反而浪费内存。</li></ul></li><li>方法内的局部变量是否是线程安全的？（判断是否是线程安全要看变量是否是<strong>共享&#x2F;私有</strong>的）<ul><li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</li><li>如果是局部变量引用了对象，并逃离方法的作用方法，需要考虑线程安全</li></ul></li></ol><h4 id="3-栈内存溢出"><a href="#3-栈内存溢出" class="headerlink" title="3. 栈内存溢出"></a>3. 栈内存溢出</h4><ul><li>方法调用层级过深（递归未终止）导致<strong>栈帧过多。</strong></li><li>单个栈帧过大（如定义超大数组、局部变量过多）导致<strong>内存耗尽。</strong></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>native method，不是由java代码编写的方法，由c&#x2F;c++实现。用本地方法接口</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="1-定义（Heap）"><a href="#1-定义（Heap）" class="headerlink" title="1. 定义（Heap）"></a>1. 定义（Heap）</h4><ul><li>通过new关键字创建的对象都会使用堆内存</li><li>是<strong>JVM中最大的一块内存区域</strong>，用于<strong>存储所有对象实例和数组</strong>。</li></ul><h4 id="2-特点"><a href="#2-特点" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li><strong>线程共享</strong>：多个线程可以访问堆中的同一对象，需考虑线程安全问题。</li><li><strong>由垃圾回收器管理</strong>：GC 自动清理无引用对象，回收内存空间。</li></ul><h4 id="3-堆内存溢出（OutOfMemoryError-Java-heap-space）"><a href="#3-堆内存溢出（OutOfMemoryError-Java-heap-space）" class="headerlink" title="3. 堆内存溢出（OutOfMemoryError: Java heap space）"></a>3. 堆内存溢出（OutOfMemoryError: Java heap space）</h4><ul><li>只要new出来的对象还在被使用，就不会被回收，一直在添加，最后会溢出。</li></ul><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul><li>JVM 内存结构的一部分，用于<strong>存储类的元数据信息</strong>，包括：<ul><li>类的结构（字段、方法、接口等）</li><li>常量池（如字符串字面量、符号引用）</li><li>静态变量</li><li>类的代码（字节码）、JIT 编译后的代码等</li></ul></li></ul><h4 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2. 特点"></a>2. 特点</h4><ul><li><strong>所有线程共享</strong>；</li><li>属于 JVM 规范中规定的逻辑区域；</li><li>在 HotSpot 虚拟机中，早期称为 <strong>永久代（PermGen）</strong>，从 <strong>JDK 8</strong> 起被 <strong>元空间（Metaspace）</strong> 取代；</li><li>元空间使用 <strong>本地内存</strong>（非堆内存）进行分配；</li><li>方法区也会发生内存溢出，例如：动态加载大量类时抛出 <code>OutOfMemoryError: Metaspace</code>。</li></ul><h4 id="3-常见用途"><a href="#3-常见用途" class="headerlink" title="3. 常见用途"></a>3. 常见用途</h4><ul><li>类加载（包括反射、代理等）</li><li>存放静态成员和常量</li><li>热点代码编译缓存（如 JIT 编译结果）</li></ul><h4 id="4-简洁记忆"><a href="#4-简洁记忆" class="headerlink" title="4. 简洁记忆"></a>4. 简洁记忆</h4><blockquote><p>方法区用于存放类信息、常量、静态变量，是线程共享的逻辑区域，从 JDK 8 起由元空间替代。</p></blockquote><h4 id="5-运行时常量池"><a href="#5-运行时常量池" class="headerlink" title="5. 运行时常量池"></a>5. 运行时常量池</h4><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>.class 文件里有一张“常量池表”（静态的）；加载这个类时，这张表内容就复制进 JVM 的运行时常量池；JVM 执行方法时，所有的名字、字面量、描述信息都要从这里查；它就像“JVM的大字典”，翻译代码里各种符号，让它知道具体地址和内容。</li></ul><h5 id="StringTable（串池）"><a href="#StringTable（串池）" class="headerlink" title="StringTable（串池）"></a>StringTable（串池）</h5><ol><li>StringTable特性<br>在预编译的时候会创建常量池，将字符串都添加进常量表中，比如s1,s2,s3就会被添加进串池里，s4的时候使用拼接字符串，其实底层调用了StringBuilder的append方法，new出了一个StringBuilder对象，一个在方法区，一个在堆区，他们所指向的对象不同，比较结果自然false；<br>如果使用equals，只需要比较值，如果使用&#x3D;&#x3D;，需要比较值和指向的对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1+s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1+s2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s4==s5);</span><br><span class="line">        System.out.println(s3==s6);</span><br><span class="line">    &#125;v</span><br></pre></td></tr></table></figure><blockquote><p>一句话总结 ： &#x3D;&#x3D; 比较的是“是不是同一个人”，.equals() 比较的是“名字是不是一样”。</p></blockquote><ul><li>常量池中的字符串仅是符号，第一次用到时才成为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder(1.8)</li><li>字符串常量拼接的原理是编译器优化 “a”+”b” 直接优化成 “ab”</li><li>可以使用intern方法，主动将串池中还没有的字符串放进串池。<ul><li>s.intern() 尝试将字符串s的内容放入常量池，如果常量池里有s，那就返回常量池的内容；如果常量池中没有s，就将s添加进入常量池，并返回常量池中的s</li></ul></li></ul><ol start="2"><li>StringTable位置</li></ol><h2 id="垃圾回收-GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。"><a href="#垃圾回收-GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。" class="headerlink" title="垃圾回收 GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。"></a>垃圾回收 GC（垃圾回收）的目的就是自动释放内存，防止内存泄漏和程序崩溃。</h2><h3 id="1-如何判断一个对象可以被回收"><a href="#1-如何判断一个对象可以被回收" class="headerlink" title="1.如何判断一个对象可以被回收"></a>1.如何判断一个对象可以被回收</h3><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>循环引用会导致内存泄漏</p><h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h4><h5 id="1-原理："><a href="#1-原理：" class="headerlink" title="1.原理："></a>1.原理：</h5><p>夏天吃葡萄，拎起一串葡萄，如果在根上的就不是垃圾，不能被回收；掉落下来的可以回收。</p><ul><li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活对象</li><li>扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到表示可以回收。</li><li>哪些对象可以作为GC Root？</li></ul><h5 id="2-四种（-一个终结器）引用"><a href="#2-四种（-一个终结器）引用" class="headerlink" title="2. 四种（+一个终结器）引用"></a>2. 四种（+一个终结器）引用</h5><h6 id="1-强引用（Strong-Reference）"><a href="#1-强引用（Strong-Reference）" class="headerlink" title="1. 强引用（Strong Reference）"></a>1. 强引用（Strong Reference）</h6><ul><li>最常见、默认的引用方式，例如：<code>Object obj = new Object();</code></li><li>只要强引用还存在，<strong>对象永远不会被 GC 回收</strong></li><li>应用场景：日常代码中创建对象时默认的引用类型</li></ul><h6 id="2-软引用（Soft-Reference）"><a href="#2-软引用（Soft-Reference）" class="headerlink" title="2. 软引用（Soft Reference）"></a>2. 软引用（Soft Reference）</h6><ul><li>使用类：<code>SoftReference&lt;T&gt;</code></li><li>当内存不足时才会被 GC 回收，<strong>适合做缓存</strong></li><li>示例：图片缓存、内存敏感对象</li><li>应用场景：避免 OOM 时自动释放内存</li></ul><h6 id="3-弱引用（Weak-Reference）"><a href="#3-弱引用（Weak-Reference）" class="headerlink" title="3. 弱引用（Weak Reference）"></a>3. 弱引用（Weak Reference）</h6><ul><li>使用类：<code>WeakReference&lt;T&gt;</code></li><li>一旦 GC 运行，无论内存是否足够，都会被回收</li><li>示例：<code>ThreadLocal</code> 中的值、<code>WeakHashMap</code></li><li>应用场景：辅助结构、缓存，但对象生命周期短</li></ul><h6 id="4-虚引用（Phantom-Reference）"><a href="#4-虚引用（Phantom-Reference）" class="headerlink" title="4. 虚引用（Phantom Reference）"></a>4. 虚引用（Phantom Reference）</h6><ul><li>使用类：<code>PhantomReference&lt;T&gt;</code> + <code>ReferenceQueue&lt;T&gt;</code></li><li><strong>无法通过引用获取对象</strong>，仅用于监听对象是否即将被 GC 回收</li><li>应用场景：资源清理、DirectMemory 手动释放等高级用途</li></ul><h6 id="5-终结器引用（Finalizer-Cleaner）"><a href="#5-终结器引用（Finalizer-Cleaner）" class="headerlink" title="5. 终结器引用（Finalizer &#x2F; Cleaner）"></a>5. 终结器引用（Finalizer &#x2F; Cleaner）</h6><ul><li>一种过时的引用机制，依赖 <code>finalize()</code> 方法</li><li>对象在被 GC 回收前，会被加入 Finalizer 队列，并延迟处理</li><li>缺点：性能差、不可控、不推荐使用</li><li>JDK 9+ 推荐使用 <code>java.lang.ref.Cleaner</code> 替代<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527153314738.png"><blockquote><p>记忆口诀：<strong>强软弱虚，越来越容易被回收</strong>；终结器引用用于回收通知，但现在被 Cleaner 替代。<br><strong>GC 就是根据“引用关系”判断对象是否还能活着；没有引用的对象，才是“垃圾”。</strong></p></blockquote></li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><h4 id="1-标记清除"><a href="#1-标记清除" class="headerlink" title="1.标记清除"></a>1.标记清除</h4><ul><li><strong>基本思想</strong>：从 GC Roots 出发，标记所有可达对象；标记完成后，清除未被标记的对象。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527153606894.png"></li><li>优点：速度快</li><li>缺点：内存碎片太多，内存空间不连续。</li></ul><h4 id="2-标记整理"><a href="#2-标记整理" class="headerlink" title="2.标记整理"></a>2.标记整理</h4><ul><li><strong>基本思想</strong>：先从 GC Roots 出发标记所有可达对象，然后<strong>将存活对象向一端移动</strong>，最后清理掉边界以外的无效内存。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527154143192.png"></li><li>优点：碎片化消失</li><li>缺点：效率降低，因为涉及地址的移动</li></ul><h4 id="3-复制"><a href="#3-复制" class="headerlink" title="3.复制"></a>3.复制</h4><ul><li><strong>基本思想</strong>：将内存分为两块等大小的区域（from 和 to）。每次 GC 时，从 GC Roots 标记存活对象，然后将其<strong>复制到另一块空间（to）</strong>，保持连续分布，最后清空 from 区并交换角色。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527154506611.png"></li><li>优点：避免碎片化</li><li>缺点：双倍空间</li></ul><h3 id="3-分代垃圾回收（Generational-Garbage-Collection）"><a href="#3-分代垃圾回收（Generational-Garbage-Collection）" class="headerlink" title="3. 分代垃圾回收（Generational Garbage Collection）"></a>3. 分代垃圾回收（Generational Garbage Collection）</h3><p>Java 堆内存被划分为两大区域：</p><ul><li><strong>新生代（Young Generation）</strong><ul><li>包括三部分：伊甸园 区、Survivor <strong>From</strong> 区、Survivor <strong>To</strong> 区</li><li>采用 <strong>复制算法</strong> 进行垃圾回收</li></ul></li><li><strong>老年代（Old Generation）</strong><ul><li>存放存活时间长、经过多次 GC 仍未回收的对象</li><li>通常采用 <strong>标记-整理算法</strong><blockquote><p>类比比喻：<strong>新生代 &#x3D; 日常清理，老年代 &#x3D; 每年大扫除</strong></p></blockquote></li></ul></li></ul><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250527160108307.png"></p><h4 id="新生代回收流程（Minor-GC）："><a href="#新生代回收流程（Minor-GC）：" class="headerlink" title="新生代回收流程（Minor GC）："></a>新生代回收流程（Minor GC）：</h4><ul><li>所有新对象优先分配在 <strong>Eden 区</strong>；</li><li>当 Eden 区满了，就触发一次 <strong>Minor GC</strong>；</li><li>GC 时，将 Eden 和 From 区存活的对象<strong>复制到 To 区</strong>，并<strong>对象年龄+1</strong>；</li><li>From 和 To 区角色互换（类似复制算法）；</li><li>若对象年龄超过一定阈值（如 15 次），就<strong>晋升到老年代</strong>。</li></ul><h4 id="老年代回收流程（Full-GC）："><a href="#老年代回收流程（Full-GC）：" class="headerlink" title="老年代回收流程（Full GC）："></a>老年代回收流程（Full GC）：</h4><ul><li>如果老年代空间不足，先尝试触发 Minor GC；</li><li>如果仍不足，将触发一次 <strong>Full GC</strong>，同时回收新生代和老年代；</li><li>Full GC 开销大，伴随 <strong>Stop The World（STW）</strong>，影响性能更显著。</li></ul><h4 id="额外说明："><a href="#额外说明：" class="headerlink" title="额外说明："></a>额外说明：</h4><ul><li><strong>Minor GC</strong>：发生频率高，时间短，只回收新生代；会触发一次stop the world</li><li><strong>Full GC</strong>：发生频率低，时间长，会暂停所有线程。</li></ul><blockquote><p>💡 新生代回收通常使用“复制算法”，老年代回收通常使用“标记-整理算法”。</p></blockquote><h2 id="类加载（ClassLoader）"><a href="#类加载（ClassLoader）" class="headerlink" title="类加载（ClassLoader）"></a>类加载（ClassLoader）</h2><h2 id="JMM（Java-Memory-Modle）"><a href="#JMM（Java-Memory-Modle）" class="headerlink" title="JMM（Java Memory Modle）"></a>JMM（Java Memory Modle）</h2><p>java内存模型，JMM定义了一套在多线程读写共享数据时（成员变量，数组）时，对数据的可见性、有序性和原子性的规则和保障。</p><h3 id="为什么要加锁"><a href="#为什么要加锁" class="headerlink" title="为什么要加锁"></a>为什么要加锁</h3><ul><li>可见性问题：CPU的速度高，当CPU修改了缓存中的数据但还没写回主存时，线程B读取了主存中的数据，就发生了数据读写冲突。一个线程修改了共享数据，但是另外一个线程无法立刻获取到最新的共享数据</li><li>有序性问题：CPU或编译器对指令进行重排序，导致代码执行顺序和书写顺序不一致。</li></ul><hr><ul><li>synchronized编译后是<code>monitor enter</code>和<code>monitor exit</code>两个指令<ul><li>monitor enter（加锁）会使用<strong>读屏障</strong>，强行从主存重新读取数据，保证数据是最新的</li><li>monitor exit（解锁） 会使用<strong>写屏障</strong>，强行将缓存中的变量刷新到主存中</li></ul></li></ul><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><blockquote><p>为什么要做锁升级</p></blockquote><ul><li>java线程模型是一对一的，每一个线程调用都涉及到操作系统的从用户态到内核态的转换，开销很大。所以在低并发的情况下就不让你阻塞，只要不阻塞，就不用有切换状态。并发量高的时候再去阻塞。如：购物软件凌晨低并发，周末，晚上休息时间高并发。</li><li>为了降低 低并发情况下获得锁的代价，为了提高低并发时候的性能</li></ul><blockquote><p>那为什么会慢？</p></blockquote><ul><li>synchronized说到底层还是要调用操作系统的原语mutex，然后又涉及到线程的<code>阻塞与唤醒</code></li></ul><h3 id="状态演变"><a href="#状态演变" class="headerlink" title="状态演变"></a>状态演变</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529133440600.png"></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>最开始是无锁状态，当有第一个线程来访问同步代码块时，JVM将对象头的Mark Word锁标志位设置为偏向锁，然后将线程id记录到markword中。偏向锁考虑只有一个线程抢锁的场景。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>当第二个线程来抢锁就升级为轻量级锁，第二个线程拿不到锁就采用CAS + 自旋不断尝试重复获得锁<br>为什么要有轻量级锁？</p><ul><li>考虑的是竞争锁的线程不多，而且线程持有锁的时间也不长。都没有进行上下文切换以及操作系统级的线程阻塞和切换</li></ul><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>当第二个线程自旋到一定次数之后还没获得锁，或者有别的线程也来抢锁了，那就升级为<code>重量级锁</code>。重量级锁加锁就需要调用操作系统的<strong>底层原语mutex</strong>，所以每次切换线程都需要操作系统从用户态切换成内核态，<strong>开销很大，所以称之为重量级锁</strong>。把那些没拿到锁的线程全都<strong>阻塞</strong>，当升级到重量级锁的时候，对象头的Markword指针就会指向锁监视器monitor。<br>为什么一定要升级为重量级锁？</p><ul><li>因为自旋只适合于锁的竞争比较小，而且执行时间比较短的程序。要是大量线程都在自旋等待，CPU时间被浪费了。</li></ul><h4 id="锁监视器Monitor"><a href="#锁监视器Monitor" class="headerlink" title="锁监视器Monitor"></a>锁监视器Monitor</h4><p>锁监视器主要是用来负责记录锁的拥有者，记录锁的重入次数，负责线程的阻塞唤醒，锁监视器就是一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectMonitior</span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *_owner; <span class="comment">//锁拥有者</span></span><br><span class="line">    WaitSet _WaitSet; <span class="comment">//等待池（管理调用wait()方法的线程）</span></span><br><span class="line">    EntryList _EntryList; <span class="comment">//锁池（管理因竞争锁失败而阻塞的线程）</span></span><br><span class="line">    <span class="type">int</span> _recursions <span class="comment">//记录锁重入次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重入次数作用？<ul><li>当一个线程重复去获取这个锁，这就是可重入锁，冲入一次++，释放一次–，减到0就是释放锁了。</li></ul></li><li>锁池和等待池是干什么的？<ul><li>在重量级锁状态下，当有线程拿到锁，此时监视器的owner字段就记录拿到锁的线程，没有拿到锁的就进入blocking状态，然后放到锁池中；当拿到锁的线程调用了wait()方法，那该线程就释放锁，然后进入waiting状态，然后被放到等待池中，然后某个线程调用了notify，唤醒了这个waiting线程，那这个线程就从waiting状态变成blocking状态，再被放入锁池中，重新去抢锁。</li></ul></li><li>锁竞争失败的线程和调用了wait方法的线程有什么本质区别吗？不都是在阻塞等待吗，为什么要放在锁池和等待池？<ul><li>锁池放的是竞争锁失败的线程，线程状态是blocking，他的目标是尽快去获得锁去执行任务，这是<strong>锁的互斥问题</strong>；等待池是主动放弃锁的进程，现在还暂时不想要锁，这个线程等待被其他线程唤醒后，他们的状态是waiting，是想等待其他资源到位了，然后再被notify唤醒，然后进入锁池中进行抢锁，这是<strong>锁通信问题</strong>。</li></ul></li></ul><h3 id="CAS-（Compare-and-Swap）-体现乐观锁的思想"><a href="#CAS-（Compare-and-Swap）-体现乐观锁的思想" class="headerlink" title="CAS （Compare and Swap） 体现乐观锁的思想"></a>CAS （Compare and Swap） 体现乐观锁的思想</h3><p><code>悲观锁</code></p><ul><li>定义：认为并发访问肯定会出问题，凡是共享资源都必须加锁，线程没获得锁前会被<strong>阻塞</strong>。<br>缺点：</li><li>性能差，线程频繁上下文切换；</li><li>在大量<strong>读操作或低冲突场景</strong>下显得臃肿；</li><li>synchronized、ReentrantLock 属于典型的悲观锁。<blockquote><p>Compare and Swap <strong>对比，交换</strong></p></blockquote></li></ul><p><code>乐观锁</code></p><ul><li>假设线程A\B要访问一个资源，资源门口挂的门牌号是0（表空闲），A，B都想去访问，A先看到了门牌号的值是0，A拿到了CPU的时间片，对比了一下门牌号上还是0，等于old value，就将其改为1。对比门牌号上的值是否和自己第一次看到的值相同。这时B来到了门牌号前，发现自己的值是0但门牌号已经是1了，说明已经有线程去访问了资源，这时候有两个选择。1.可以自旋等待（while true），不断用CAS修改，直到线程B耐心耗尽。</li><li>概念：乐观锁就是当线程访问共享资源的时候，总是乐观的认为没有线程和它竞争，所以不会加锁，只是比较状态值是否和他的预期值相同，相等说明没有被其他线程修改，然后修改状态值并访问共享资源。</li><li>原子性：这是两步操作，如何确保呢？ 软件层面上无法实现，必须要硬件。</li><li>效率：因为没有使用<code>synchronized</code>，所以不会引发阻塞，效率提升的原因。CAS+volatile实现<code>无锁并发</code></li><li>真的无锁吗？<ul><li>在 用户代码层面，CAS 不使用 synchronized 或 ReentrantLock 这类显式锁。</li><li>它通过 CPU 提供的原子指令（如 x86 架构中的 CMPXCHG 指令）实现对内存的原子读-改-写。</li><li>不会让线程进入阻塞状态（不会挂起、不会上下文切换）。</li><li>底层会锁总线防止其他CPU核心访问。</li><li>在硬件层面，CAS 其实会短暂锁住某些资源，只不过它是极快的、非阻塞的，不像软件锁那样代价高。</li></ul></li><li>volatile 是 Java 中的一个<code>关键字</code>，用于修饰变量，主要用于多线程编程中的<code>可见性问题</code>。它的作用可以总结为：<ul><li>保证内存可见性：当一个线程修改了某个 volatile 变量的值，<strong>其他线程能立刻看到这个变化</strong>。</li><li>禁止指令重排序（部分场景）：在 volatile 写操作前的代码不会被编译器或 CPU 移动到写操作之后。<br>所以CAS保证<strong>原子性</strong>，volatile保证<strong>可见性</strong><br>数据库也可以使用CAS的思想</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 库存 <span class="operator">=</span> 新值 <span class="keyword">where</span> 库存 <span class="operator">=</span> 旧值</span><br></pre></td></tr></table></figure><ul><li>ABA问题<ul><li>假设变量 x 原本是 A</li><li>线程 T1 读取 A，要改成 B</li><li>在这之间，T2 把 A 改成了 C 又改回 A</li><li>T1 执行 CAS：发现 x 还是 A，就以为没变，结果错误更新<blockquote><p>Java 解决办法：加版本号（如 AtomicStampedReference）</p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaAlgorithm</title>
      <link href="/2025/05/19/javaAlgorithm/"/>
      <url>/2025/05/19/javaAlgorithm/</url>
      
        <content type="html"><![CDATA[<p>java是一种<strong>面向对象</strong>的语言，入口程序也是一个<strong>类</strong>，类的属性有public,private,protected;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>(String arg[])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2025.5.19</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>应用场景：<strong>有序</strong> <strong>数组</strong><br>二分三元素 ：<strong>left，mid，right</strong><br>目标可能存在的区间，在[left,right]之间，所以循环条件就是他。<br>循环变更的是：left和right，是基于这一次选择的mid来变更的，而不是left和right++ &#x2F; –1；<br>时间复杂度：logN<br><a href="https://leetcode.cn/problems/binary-search/">二分查找</a><br><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/description/">猜数字大小</a><br><a href="https://leetcode.cn/problems/search-insert-position/description/">搜索插入位置</a><br><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">在排序数组中查找元素的第一个和最后一个位置</a><br><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a><br><a href="https://leetcode.cn/problems/first-bad-version/description/">第一个错误的版本</a><br><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/">山脉数组的峰顶索引</a><br><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a><br><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">搜索旋转排列数组Ⅱ</a><br><a href="https://leetcode.cn/problems/find-in-mountain-array/description/">山脉数组中查找目标值</a></p><p>2025.5.20</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长字串</a><br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a><br><a href="https://leetcode.cn/problems/permutation-in-string/description/">最小覆盖字串</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈中使用push()&#x2F;pop()来 添加&#x2F;删除元素，peek()查看栈顶元素<br><a href="https://leetcode.cn/problems/simplify-path/description/">简化路径</a>StringBuilder以及字符串切割<br><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式</a><br><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></p><p>2025.5.21</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/3sum/">三数之和</a><br><a href="https://leetcode.cn/problems/3sum-closest/description/">最接近的三数之和</a></p><p>2025.5.22</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>优先队列视为堆，默认是最小堆，堆中使用add()&#x2F;poll() 进行添加&#x2F;删除元素，peek查看堆顶元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;T&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">//最小堆</span></span><br><span class="line">PriorityQueue&lt;T&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparation.reverseOrder()); <span class="comment">//最大堆 </span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第k个最大元素</a><br><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">前k个高频元素</a><br><a href="https://leetcode.cn/problems/sort-characters-by-frequency/description/">根据字符出现频率排序</a><br><a href="https://leetcode.cn/problems/k-closest-points-to-origin/description/">最接近原点的 K 个点</a></p><p>2025.5.23</p><h2 id="树-递归法"><a href="#树-递归法" class="headerlink" title="树 递归法"></a>树 递归法</h2><p>DFS用递归，BFS用队列，总结一下：充分利用好前中后序列以及层序遍历，善用队列以及递归。<br><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树的前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树的后序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">二叉树的层序遍历Ⅱ</a><br><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">二叉树的锯齿形层次遍历</a><br><a href="https://leetcode.cn/problems/same-tree/description/">相同的树</a><br><a href="https://leetcode.cn/problems/symmetric-tree/description/">对称二叉树</a><br><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">二叉树的右视图</a><br><a href="https://leetcode.cn/problems/invert-binary-tree/description/">翻转二叉树</a><br><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">平衡二叉树</a><br><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">二叉树的最大深度</a><br><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">二叉树的最小深度</a><br><a href="https://leetcode.cn/problems/path-sum/description/">路经总和</a><br><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></p><h2 id="图的遍历，回溯"><a href="#图的遍历，回溯" class="headerlink" title="图的遍历，回溯"></a>图的遍历，回溯</h2><p>2025.5.24 &amp;&amp; 2025.5.25<br><a href="https://leetcode.cn/problems/permutations/">全排列</a><br><a href="https://leetcode.cn/problems/path-sum-ii/description/">路径总和Ⅱ</a><br><a href="https://leetcode.cn/problems/permutations-ii/description/">全排列</a><br><a href="https://leetcode.cn/problems/flood-fill/">图像渲染</a><br><a href="https://leetcode.cn/problems/word-search/description/">单词搜索</a><br><a href="https://leetcode.cn/problems/number-of-islands/description/">岛屿数量</a></p><p>2025.5.26<br><a href="https://leetcode.cn/problems/surrounded-regions/description/">被围绕的区域</a><br><a href="https://leetcode.cn/problems/number-of-enclaves/description/">飞地的数量</a></p><h2 id="简单的动态规划"><a href="#简单的动态规划" class="headerlink" title="简单的动态规划"></a>简单的动态规划</h2><p><a href="https://leetcode.cn/problems/fibonacci-number/description/">斐波那契数</a><br><a href="https://leetcode.cn/problems/climbing-stairs/description/">爬楼梯</a><br><a href="https://leetcode.cn/problems/decode-ways/description/">解码方法</a></p><p>2025.5.28<br><a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">最大子数组和</a></p>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaweb</title>
      <link href="/2025/04/27/javaweb/"/>
      <url>/2025/04/27/javaweb/</url>
      
        <content type="html"><![CDATA[<p>Server后端开发：代码开发（java）–框架简化代码（Spring）–用包（库，包管理器：Maven）<br>总结就是三步：语言，框架，以及包</p><p>拼接起来就是：Fronted—www—Server—Database<br>前端发送到后端的叫请求(Request)，后端发给前端的叫响应(Response)。</p><h3 id="web网站的工作流程"><a href="#web网站的工作流程" class="headerlink" title="web网站的工作流程"></a>web网站的工作流程</h3><p>一个web网站大致由三个部分组成：前端服务器(前端程序)，后端服务器(后端程序)，数据库服务器<br>用户在浏览器输入域名，浏览器会根据域名请求访问前端服务器，前端服务器在接收到请求后会向浏览器返回前端代码，(浏览器也是一个程序，内置了解析前端代码的解析引擎)，从而解析出对应的页面样式<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250427193730312.png"><br>需要学习的技术：Maven、SpringBoot Web、MySQL(got it)、SpringBoot Mybatis</p><h3 id="初识web前端"><a href="#初识web前端" class="headerlink" title="初识web前端"></a>初识web前端</h3><ul><li>网页的组成部分：文字、图片、音频、超链接、视频</li><li>我们看到的网页背后的本质：<strong>前端代码</strong></li><li>前端代码如何转换成用户眼中的网页：<strong>浏览器</strong>转化(解析和渲染(浏览器内核))成用户看到的网页</li></ul><p>Web标准：</p><ul><li>HTML(HyperText Markup Language):负责网页的结构（页面元素和内容）</li><li>CSS：负责网页的表现（页面元素的外观，位置等页面样式，如颜色，大小）</li><li>JavaScript：负责网页的行为（交互效果）<br>常用标签</li><li>vscode装了插件之后直接!</li><li>hr:水平线，一般有两个</li><li>h1-h6：六级标题对应不同大小</li><li>img：插入图片，可以绝对路径或者相对路径，一般用相对路径。还可以设置宽高，但一般只设置一个，会等比例缩放</li><li>title：网页名字<br>2025.4.27</li></ul><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Maven 是一个项目管理和构建工具，主要用于管理 Java 项目的依赖库，以及自动化项目的编译、打包、测试、部署等过程。<br>简单理解就是：</p><ul><li>你在开发 JavaWeb 项目的时候，需要很多第三方库（比如数据库连接池、日志框架等等）。</li><li>Maven 帮你自动下载、管理版本，不用你手动找 jar 包。</li><li>它还能一键构建项目，比如一条命令就能打成 war 包部署到服务器上。<br>成功配置maven<br>2025.4.28</li></ul><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul><li>SpringBoot快速入门<ol><li>创建SpringBoot工程，勾选web开发</li><li>编写请求处理类（加上注解）</li><li>看本地占用端口，打开浏览器访问端口<br>要写注解</li></ol></li><li>@RequestController告诉SpringBoot直接返回内容到页面</li><li>@RequestMapping是访问路径<br>简单url是 <a href="http://localhost:8080/array?hobby=sing&hobby=jump&hobby=rap&hobby=basketball">http://localhost:8080/array?hobby=sing&amp;hobby=jump&amp;hobby=rap&amp;hobby=basketball</a></li></ul><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><strong>MySQL账号密码：root 1234</strong><br>MyBatis用来简化JDBC开发的框架，<strong>用来操作数据库</strong>。<br>包是组织<strong>类</strong>的，模块是组织<strong>包</strong>的。</p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><ul><li>准备数据库表(dept\emp)</li><li>创建SpringBoot工程，引入对应的依赖：web、mybatis、mysql驱动、lombok</li><li>配置文件：引入mybatis的配置信息，准备对应的实体类</li><li>准备对应的Mapper、Service（接口、实现类）、Controller基础结构</li></ul>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2025/04/25/MySQL/"/>
      <url>/2025/04/25/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL的数据模型"><a href="#MySQL的数据模型" class="headerlink" title="MySQL的数据模型"></a>MySQL的数据模型</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425151506824.png"><br>基于表存储的数据库叫做关系型数据库</p><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul><li>通用语法    <ol><li>SQL语句可以<strong>单行或多行</strong>书写，以<strong>分号</strong>结尾。</li><li>SQL语句可以使用空格&#x2F;缩进来增强可读性（空格缩进数量不限）</li><li>MySQL数据库的SQL语句<strong>不区分大小写</strong>，<strong>关键字</strong>建议使用大写</li><li>有多种注释</li></ol></li></ul><h3 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h3><p>语句分类<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425152338674.png"></p><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><ul><li>查询<ol><li>查询所有数据库 show databases;</li><li>查询当前数据库 select database();</li></ol></li><li>创建<ol><li>create database 数据库名;</li><li>创建表:<br> create table 表名 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段1 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段2 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段3 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段n 字段类型 comment &#x27;注释内容&#x27;   (注意最后一条注释没有逗号)</span><br><span class="line">)comment &#x27;表注释&#x27;;</span><br></pre></td></tr></table></figure> <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155452204.png"><br> <strong>varchar() 变长字符串 char() 定长字符串</strong></li><li>查看创建的表：</li></ol><ul><li>show tables;</li><li>desc 表名;<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155608018.png"></li></ul><ol start="4"><li>查看表的创建信息:</li></ol><ul><li>show create table 表名;<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155745479.png"></li></ul></li><li>删除<ol><li>数据库删除<br> drop database 数据库名;</li><li>表字段删除<br> alter table 表名 字段名;</li><li>表删除<br> drop table 表名;</li></ol></li><li>使用<ol><li>use 数据库名</li></ol></li><li>表修改操作<ol><li>修改（增加）<br>  alter table 表名 add 字段名 字段类型 comment ‘’;</li><li>修改数据类型<br>  alter table 表名 modify 字段名 新数据类型(长度)</li><li>修改字段名和字段类型<br>  alter table 表名 change 旧字段名 新字段名 类型(长度) comment ‘’;</li><li>修改表名<br>  alter table 表明 rename to 新表名;</li></ol></li></ul><h4 id="DML-data-manipulation-language"><a href="#DML-data-manipulation-language" class="headerlink" title="DML (data manipulation language)"></a>DML (data manipulation language)</h4><ol><li>添加数据(insert)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425174721753.png"></li><li>修改数据(update)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425180743091.png"><br>update em set name &#x3D; ‘itheima’ where id &#x3D; 1;<br>update em set entrytime &#x3D; ‘2008-01-01’; 如果不带where代表要执行整张表的数据</li><li>删除数据(delete)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425181556477.png"></li></ol><h4 id="DQL-data-query-language-用来-查询数据-的，设计的关键字select"><a href="#DQL-data-query-language-用来-查询数据-的，设计的关键字select" class="headerlink" title="DQL (data query language) 用来 查询数据 的，设计的关键字select"></a>DQL (data query language) 用来 查询数据 的，设计的关键字select</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425184335313.png"></p><ol><li>基本查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425184335313.png"></li><li>条件查询(<strong>加where</strong>)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425190554345.png"></li></ol><ul><li>查询没有身份证的员工select * from em where idcard is null; （使用is null）</li><li>查询有 is not null</li><li>查询姓名为两个字的员工，用like + 两个占位符__ select * from em where name like ‘__’;</li><li>查询身份证最后一个位是X  select * from em where idcard like ‘%X’;</li></ul><ol start="3"><li>聚合函数（将一列数据作为一个整体，进行纵向计算）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425192935227.png"></li><li>分组查询<br>注意：先where，然后在where里分组后执行聚合函数，然后再执行having，分组之后，查询的字段一般为<strong>分组字段和聚合函数，查询其他的是没有意义的</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425193446332.png"></li></ol><ul><li>分组性别统计数量  select gender,count(*) from em group by gender ;</li><li>分组性别统计年龄 select gender,avg(age) from em group by gender;</li><li>年龄小于45 根据工作地址分组 获取员工数量大于3的地址<br>select workaddress,count(*) from em where age &lt;45 group by workaddress having count(*)&gt;&#x3D;3;<br>先写年龄小于45，然后再写分组，然后再挑数量，想要知道数量前面是谁？加上你选择分组的东西，最后再额外条件。</li></ul><ol start="5"><li><p>排序查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425195312558.png"></p></li><li><p>分页查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425200216365.png"></p></li></ol><h4 id="DCL-Data-Control-Language数据控制语言-有哪些用户可以访问服务器，控制每一个用户的访问权限"><a href="#DCL-Data-Control-Language数据控制语言-有哪些用户可以访问服务器，控制每一个用户的访问权限" class="headerlink" title="DCL (Data Control Language数据控制语言) 有哪些用户可以访问服务器，控制每一个用户的访问权限"></a>DCL (Data Control Language数据控制语言) 有哪些用户可以访问服务器，控制每一个用户的访问权限</h4><ol><li>管理用户<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425201101284.png"></li><li>授予权限<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425201200579.png"></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425203403010.png"></p><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425203317834.png"><br>select lpad(round(rand()*1000000,0),6,’0’); 实现六位数的随机验证码</p><h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425204154624.png"><br>select name,datediff(curdate(),entrydate) ‘entrydays’ from em order by entrydays;</p><h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425205106262.png"></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>create table user(<br>    id int primary key auto_increment comment ‘主键’,<br>    name varchar(10) not null unique comment ‘姓名’,<br>    age int check ( age &gt; 0 &amp;&amp; age &lt; 120 ) comment ‘年龄’,<br>    status char(1) default (1) comment ‘状态’,<br>    gender char(1) comment ‘性别’<br>)comment ‘用户表’;<br>这些都是约束<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425205304798.png"></p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425211835852.png"></p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br>比如银行转账。如果出错就要执行rollback回滚，设置为手动提交，autocommit &#x3D; 0，commit<br>事务的四大特性：</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaLearn</title>
      <link href="/2025/04/23/JavaLearn/"/>
      <url>/2025/04/23/JavaLearn/</url>
      
        <content type="html"><![CDATA[<p>从今天开始，cpp转java，其实语言不是最重要的，重要的是思想，就像小学拿铅笔写字，初高中用水性笔，大学用电容笔一样，但做的都是同一件事情，写字。</p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>一开始就被环境变量上了一课，本博客使用hexo写的，我把D:\给删掉了，导致无法使用hexo指令，npm和node也找不到，添加完环境变量后就又能正常使用了。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>类名要和文件名相同，如果创建了Main.java文件，里面的类就要写为public class Main，否则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印helloworld</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h3><p>可以在语句后面使用\n（字符串），但通用的语法是 +”\n” +”\t”,\t是制表符，补齐8个空格，让文本对齐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">123</span>  );</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">-123</span> );</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">123.4566</span>  );</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">-123.4566</span> );</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&#x27;c&#x27;</span> + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;null\t&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="number">123</span> + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名建议"><a href="#命名建议" class="headerlink" title="命名建议"></a>命名建议</h3><p>小驼峰：方法、变量 firstName<br>大驼峰：类名 Student GoodStudent</p><h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>和python一样，使用import，这个就是cin</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>System.out.println(1+2+”abc”+2+1);<br>会输出3abc21，因为是从左到右进行运算，一开始没有加入字符串，所以就是int运算，后面是字符串的拼接操作。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>就是c&#x2F;c++的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;14&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;15&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;16&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;17&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        playGame();</span><br><span class="line">        playGame();</span><br><span class="line">        playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>写一个5位数的验证码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] Append() &#123;</span><br><span class="line">        <span class="type">char</span>[] newchar = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">63</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            newchar[i] = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i);        <span class="comment">// 大写A-Z</span></span><br><span class="line">            newchar[i + <span class="number">26</span>] = (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);   <span class="comment">// 小写a-z</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newchar[i + <span class="number">53</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newchar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span> []wchar = Append();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            input += wchar[rand.nextInt(<span class="number">62</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(input);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很简单，就是把大小写字母和0-9全部添加进数组里</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>和c++类似的，类里有成员变量，以及成员方法。<br><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</strong><br>this关键字：区别成员变量和局部变量，使用this就可以指向成员变量<br>标准的javabean类</p><ul><li>类名要见名知意</li><li>成员变量使用private修饰</li><li>提供至少两个构造方法<ul><li><strong>无参构造方法</strong></li><li><strong>带全部参数的有参构造方法</strong></li></ul></li><li>成员方法<ul><li><strong>提供每一个成员变量对应的set&#x2F;get</strong></li><li>如果还有其他行为也需要写入</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>next();<br>nextLine();<br>这两个都是接收字符串的，next相当于cin，nextLine相当于getline<br>java中的&#x3D;&#x3D;比较，如果是比较基本数据类型就是比较值，如果比较String，就是比较地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```如果是这样，这是对的，s2复用了字符串池中的abc</span><br><span class="line">但如果是接下来的</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就不对了，new是在堆开辟了一片内存，和原来的abc不是同一个abc了。所以比较的时候不能用&#x3D;&#x3D;，而是要用equals方法<br>常用的方法</p><ul><li>equals 比较字符串是否相等</li><li>equalsIgnoreCase 忽略大小写的比较是否相等</li><li>charAt 用来遍历字符串的字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较大小写，用ascii码来比较</p><ul><li>字符串切割s.subString(开始索引，结束索引)<br>StringBuilder对象不是String，要用toString将StringBuilder对象转换</li></ul><h3 id="集合ArrayList"><a href="#集合ArrayList" class="headerlink" title="集合ArrayList"></a>集合ArrayList</h3><p>相当于cpp的vector，有get，add，remove方法。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码<br>学生和老师都有吃饭，睡觉<br>但是学生可以有学习行为，老师有教书行为<br>子类在父类的基础上有更强的行为。<br>继承格式：public class 子类 extends 父类{}<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424114044935.png"><br>多层继承：子类A继承父类B，父类B继承父类C，祖孙三代。<br>java中所有的类都直接或间接继承于Object类</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同类型的对象，表现出的不同形态。<br>如果写一个学生管理系统，学生，老师，管理员都需要注册，不能写三个方法，应该是它们三个共同的父类人类接收他们三个。已经写了三个类了，它们都继承了Person<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424141834666.png"></p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象方法所在的类必须是抽象类，抽象就是你不知道它具体要干什么，但是你总结了它要干的这件事情。比如兔子吃胡萝卜，狗吃骨头，青蛙吃虫子，它们三个都能吃，但是具体吃什么就不知道了，就可以把吃这个行为给抽象出来。<br>public abstract void eat();<br><strong>super</strong>用来调用父类构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Animal(String name) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Dog: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424144053394.png"><br>应该是弥补java中不能多重继承的缺点，打补丁。接口是一种规则，是对行为的抽象<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424144345025.png"><br><strong>接口的子类要重写所有的抽象方法！</strong></p><h3 id="外部类和内部类"><a href="#外部类和内部类" class="headerlink" title="外部类和内部类"></a>外部类和内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">car</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String brand;</span><br><span class="line">        String color;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">engine</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age;</span><br><span class="line">            String engineName;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>内部类表示的事物是外部类的一部分,内部类单独出现没有任何意义,cpp中的结构体嵌套</p><p>java中的implements 表示：<strong>我承诺在这个类中会实现这个接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable是一个接口，里面只有一个方法run(),implement表明在thread类里会实现这个run</p>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp基础核心内容</title>
      <link href="/2025/04/20/cpp%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/"/>
      <url>/2025/04/20/cpp%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="三块核心内容"><a href="#三块核心内容" class="headerlink" title="三块核心内容"></a>三块核心内容</h2><h3 id="进程虚拟地址空间区域划分"><a href="#进程虚拟地址空间区域划分" class="headerlink" title="进程虚拟地址空间区域划分"></a>进程虚拟地址空间区域划分</h3><p>有四区</p><ol><li>代码区(.text) 存放程序的机器指令，通常是<strong>只读的</strong></li><li>数据段(.data) 存放<strong>已初始化的全局变量和静态变量</strong></li><li>BSS段 存放<strong>未初始化</strong>的<strong>全局变量和静态变量</strong>，操作系统在运行前会帮助自动初始化为0</li><li>堆栈区(Heap and Stack) <ul><li>堆区：程序运行时动态分配的内存(new 和 malloc)，由程序员管理</li><li>栈区：函数调用时使用的内存，存放局部变量和返回地址，由系统自动分配和释放<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420233311321.png"></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>；</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三条是其实是汇编的mov指令，存放在.text区，而main函数调用的时候会在栈开辟空间。</p><h3 id="函数调用堆栈详细过程"><a href="#函数调用堆栈详细过程" class="headerlink" title="函数调用堆栈详细过程"></a>函数调用堆栈详细过程</h3><h3 id="程序编译链接原理"><a href="#程序编译链接原理" class="headerlink" title="程序编译链接原理"></a>程序编译链接原理</h3><p>预处理-编译-汇编-链接</p><ol><li>预处理 处理#include 之类的，除了#pragma lib和#pragma link，这两个是在链接时处理。</li><li>编译 gcc &#x2F; g++（gcc用来编译c语言，g++用来编译c++，其实就是dev中的F9，只不过现在换成命令行形式）  在<strong>编译的过程中符号不分配虚拟地址</strong>，在链接分配。</li><li>汇编 <strong>符号表的生成</strong>，生成.o文件。.o文件为目标文件（Object File），目标文件是一个二进制文件，文件的格式是ELF(executable and linkable file)</li><li>链接 将各个段合并（比如main.o和sum.o）生成可执行文件，Linux下是.out&#x2F;Windows下是.exe<ul><li>步骤一：所有的.o文件段合并，符号表合并后，进行<strong>符号解析</strong>（要找到所有符号表引用的定义）。</li><li>步骤二：符号的重定向（让<em>UND</em>找到初始定义的位置）<strong>这是链接的核心</strong>，符号解析成功后，给所有的符号分配虚拟地址！</li></ul></li></ol><p>g++&#x2F;gcc语法</p><ul><li>gcc -c &#x2F; g++ -c  是编译 compile<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421103629431.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421103540512.png"><br>使用objdump -t查看<strong>符号表</strong>（t - table）<br>使用cat查看文件内容</li><li>在main.cpp中，我们看的定义gdata是一个外部引用的变量，sum是声明，看main.o的符号表，他们并不是没有符号，符号是<em>UND</em>(undefined)，这个意思是：<strong>我现在在当前代码上用到他们了，但是我却不知道他们是怎么定义的</strong>，UND是对于<strong>符号的引用</strong>，有确定数据段的是<strong>符号的定义</strong>需要在链接这一部分才能让他们找到“家”，main函数放在.text代码段上，我们定义了data，所以data放在了.data段</li><li>在sum.o中，因为sum.cpp定义好了每一个位置，所以符号表都有。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421110002638.png"><br>文件头，main.o 。 .o文件就是由<strong>各种各样的段</strong>来组成的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421110042215.png"><br>可以使用objdump -s xxx.o查看段的信息<br>ld是链接器，负责链接。</li><li>ELF文件头记录着文件的<strong>入口点地址</strong>，程序就知道从第几行开始执行了。</li></ul><p>总结 a.out和.o文件都是由各种段组成的，但区别在a.out多了一个#program headers段，有两个load，告诉程序在运行的时候需要加载哪些数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421112526387.png"></p><h2 id="C-基础部分"><a href="#C-基础部分" class="headerlink" title="C++基础部分"></a>C++基础部分</h2><h3 id="形参带默认值的函数"><a href="#形参带默认值的函数" class="headerlink" title="形参带默认值的函数"></a>形参带默认值的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a = <span class="number">20</span>, <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">cout &lt;&lt; ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码是错误的，因为在函数传参压入栈的时候，参数是由右往左压，现在b没有默认值，所以是错的，如果定义b为20，a不定义，代码是正确的。代码顺序：<strong>从上到下，从右到左给默认值</strong></p><h3 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><p>&#x2F;* inline内联函数和普通函数的区别？？？</p><ul><li>inline内联函数：在编译过程中，就<strong>没有函数的调用开销</strong>了，在函数的调用点直接<strong>把函数的代码进行展开处理</strong></li><li>inline函数不再生成相应的函数符号（objdump -t）</li><li>inline只是建议编译器把这个函数处理成内联函数，但是不是所有的inline都会被编译器处理成内联函数，比如递归，如果有符号说明没有内敛</li><li>debug版本上，inline是不起作用的；inline只有在release版本下才能出现<br>*&#x2F;<br>函数调用的过程：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">cout &lt;&lt; ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，第三行参数从右向左压栈，然后调用<strong>call</strong>指令，call 会把返回地址（main 函数中调用 sum 后的下一条指令）压入栈顶，然后跳转到 sum。要开辟函数栈帧，栈帧包含：返回地址、保存的寄存器、局部变量空间、对齐填充等。调用完后栈帧销毁，返回地址出栈，跳回 main 继续执行。虽然就是简简单单的x+y操作（三行汇编：mov add mov），但是如果循环了100000次呢？每一次都要这样开辟，很耗内存。<br>inline int sum(int x,int y)<br>{<br>    return x+y;<br>}<br>inline函数<strong>建议</strong>编译器内联展开函数（这是个建议，而不是强制），比如在第三行，很有可能编译成int ret &#x3D; a+b而不是调用函数。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>&#x2F;*</p><ol><li>c++为什么支持函数重载，c语言不支持函数重载<ul><li>C++代码产生函数符号的时候，是由函数名+参数列表组成的；C产生函数符号的时候，只由函数名组成。<br> 可以理解为C++：cmp_int_int &#x2F; cmp_double_double &#x2F; cmp_char *_char *，而c就会发生链接错误。</li></ul></li><li>函数重载需要注意什么</li><li>c++和c语言代码之间如何互相调用 （为何无法调用？因为函数符号不同，一个有列表一个没列表，会无法连接，<em>UND</em>）<ul><li>C调用C++：无法直接调用，把c++源码扩在extern “C”</li><li>C++调用C：把C函数的声明扩在extern “C”中<br>*&#x2F;<br>什么是重载函数？</li></ul></li><li>一组函数，其中函数名相同，参数列表的<strong>个数或类型不同</strong>，那么这一组函数就称为 函数重载</li><li>一组函数要称得上重载，一定先是处在同一个作用域中。</li><li>const &#x2F; volatile,是怎么影响形参类型的。</li><li>一组函数，函数名相同，参数列表也相同，仅仅是返回值不同，<strong>不叫重载</strong> 因为函数名参数列表都相同</li></ol><h3 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h3><ol><li>const与普通变量的区别<ul><li>const修饰的变量不能够再作为左值！！！初始化完成后，值不能被修改。</li><li>不能把常量的地址泄露给一个普通的指针或普通的引用变量 不能int <em>p &#x3D; const int</em></li></ul></li><li>c和c++中const的区别是什么?<br> const的编译方式不同，c中，const就是当作一个变量来编译生成指令的。<br> C++中，所有出现const常量名字的地方，都被常量的初始化替换了！！！所以在C++中使用const必须要初始化。比如const int a &#x3D; 20，接下来的int arr[a]，这个a不是a了，而是20。那使用指针有没有修改掉a的值呢？有，已经改掉了。</li><li>c++的const必须初始化，叫常量。如果用变量为const定义的量赋值，就叫常变量(和C一样了)，因为初始值不是立即数，是一个变量，这时候printf出来的都会是变量。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = b;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">*p = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(&amp;a)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const与一级指针-二级（多级）指针的结合"><a href="#const与一级指针-二级（多级）指针的结合" class="headerlink" title="const与一级指针&#x2F;二级（多级）指针的结合"></a>const与一级指针&#x2F;二级（多级）指针的结合</h3><p>c++语言规范：const修饰离它最近的类型<br><em><em>const右边如果没有指针</em>，是不参与类型的</em>*<br>const和一级指针的结合</p><ul><li>①const int <em>p &#x2F;&#x2F;修饰int，说明</em>p的值不能被改，但是p可以指向其他地方，一和二一样，const附近都是int</li><li>②int const *p  </li><li>③int *const p &#x2F;&#x2F;最靠近const的类型是：int *，修饰指针，说明指针指向不能改，但值可以改</li></ul><p><strong>总结const指针和指针类型的转换公式</strong> 理解：把一个普通指针变为const修饰的指针，告诉编译器：我不会再修改它了，是正确的</p><ul><li>int* &lt;&#x3D; const int* 是错误的</li><li>const int*  &lt;&#x3D; int* 是正确的</li></ul><h3 id="new-malloc-delete-free"><a href="#new-malloc-delete-free" class="headerlink" title="new&#x2F;malloc delete&#x2F;free"></a>new&#x2F;malloc delete&#x2F;free</h3><ol><li>delete和free的区别？malloc和free<strong>称作C的库函数</strong>，new和delete是运算符。</li><li>new不仅可以开辟内存，还可以初始化内存；malloc只负责开辟内存大小的空间，返回的指针是void *，所以要强制类型转换。 <code>c++int *p = (int*)malloc(sizeof(int)*20);</code></li><li>malloc开辟失败，是通过返回值和nullptr作比较；new开辟失败，通过<strong>抛出异常</strong>。</li><li>new有几种？<ul><li>int *p &#x3D; new int(20);</li><li>int *p2 &#x3D; new (nothrow) int; &#x2F;&#x2F;不抛出异常</li><li>const int *p3 &#x3D; new const int(40);</li><li>int data &#x3D; 0;int *p4 &#x3D; new (&amp;data) int(50); &#x2F;&#x2F;定位new，在指定的位置赋值</li></ul></li></ol><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>OOP语言的四大特征：抽象  封装&#x2F;隐藏  继承  多态<br>类：属性-&gt;成员变量  行为-&gt;成员方法<br>通过访问限定符体现：public  private  protected </p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h2><p>有三个主要部分：<strong>虚拟化（virtualization）</strong>、<strong>并发（concurrency）</strong>、<strong>持久性（persistence）</strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一、（共10分）操作系统的设计目标有哪些？</p><ul><li>抽象性：对硬件资源进行抽象，提供统一接口，简化程序开发；</li><li>并发性：支持多个程序同时运行，提高系统吞吐；</li><li>虚拟化：如虚拟内存、虚拟 CPU，使用户感觉拥有独占资源；</li><li>资源管理与调度：高效分配 CPU、内存、磁盘等资源，提升资源利用率；</li><li>安全与保护：防止程序互相干扰，保护用户数据；</li><li>用户友好性：提供简洁易用的接口和良好的使用体验。</li></ul><p>六、（ 共 10 分）UNIX 系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：<br>fork()和 exec()，解释说明 fork()和 exec()的作用（5 分），以 UNIX 的 Shell 为例说明为什么设<br>计这两个系统调用（5分）。 </p><ul><li>fork()创建一个和父进程几乎相同的子进程，除了PID等一些信息不同其它完全一样。</li><li>exec()用新的程序替换掉当前程序执行的内容，不改变其PID等信息。<br>UNIX SHELL启动一个新程序的时候，先通过fork()创建一个子进程，再通过exec()加载并执行用户命令，这样父进程（shell）仍能工作，分离设计提供灵活性。</li></ul><p>七、操作系统虚拟化CPU的机制是受限直接执行，为了实现这个机制，例举的硬件提供了哪些支持？简要说明操作系统如何利用硬件来实现LDE。<br>硬件</p><ul><li>模式划分：被划分为用户态和内核态</li><li>中断机制：支持外设中断和系统调用陷入内核态。</li><li>定时器中断：防止单一进程长时间占用CPU资源，实现抢占功能。</li><li>内存保护机制：通过页表和地址空间隔离来保护内核</li><li>指令限制：一些特权指令如（I&#x2F;O）只能被内核态执行。</li></ul><p>操作系统可以将进程调度执行化为内核态以及用户态，用户态不能执行一些特权指令比如I&#x2F;O，必须通过陷阱表的陷阱指令陷入内核态，并提供了从陷入返回指令回到用户态。操作系统还提供了中断机制，防止单一进程过度占用资源，而导致其他进程出现饥饿。结合内存保护，防止非法访问内核或其他进程内存区域，从而实现虚拟化CPU且保证系统安全和稳定。还有上下文切换，通过寄存器保存当前进程的值，然后读取另一个进程的寄存器所存储的值进行运行。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250419221319250.png"><br>1.三态：运行、就绪、阻塞<br>2.错误，进程在一个时刻只能处于一种状态。<br>3.错误，单核情况下，操作系统和进程需要通过时间片轮转轮流使用CPU，不会同时运行，操作系统也是一个程序。</p><h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>正在运行的程序会做一件非常简单的事情：从内存中读取指令，解码，并执行它，然后接着执行下一条指令。<br>总结为Fetch 、 Decode 、 Execute</p><p><strong>操作系统</strong>可以让程序<strong>共享内存</strong>、<strong>与设备交互</strong>、<strong>运行的更容易</strong>，操作系统确保系统既易于使用、又正确高效运行。为了做到这一点，采用了<strong>虚拟化</strong>的技术，在一些硬件的帮助下，操作系统负责提供虚拟化，使得<strong>单个（或一小部分）CPU可以看似认为有无限数量的CPU</strong>，从而可以同时运行多个程序，但问题就是在<strong>调度</strong>，在特定时间运行，该运行哪个？所以操作系统也承担了**资源管理器（resource manager）**的角色。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><ul><li><p>虚拟内存，每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，打游戏的时候每个角色都有一个背包，背包的0号格子可能装有不同的东西，但并没有冲突，操作系统把编号0分到了不同的内存地址上。<br>每个程序都有自己的“背包”（内存空间），从地址 0 开始。但实际的物理内存只有一块<br>程序 A 的地址 0x1000 → 实际是 物理地址 0xA000<br>程序 B 的地址 0x1000 → 实际是 物理地址 0xC000<br>这就是虚拟内存：给程序看的假地址，每个程序都以为自己独占整片内存，其实操作系统做了“背后映射”。</p></li><li><p>操作系统通过<strong>时间片轮转（time-sharing）<strong>技术虚拟化 CPU，将 CPU 时间划分成小片段，每次只分配给一个进程运行一个时间片，然后切换到其他进程，从而营造出“多个进程同时运行”的假象。这种时分复用机制使得单核 CPU 也能实现多任务并发。其代价是</strong>频繁的上下文切换带来一定的性能开销</strong>。</p></li><li><p>进程三态：运行、阻塞、就绪</p></li><li><p>fork()系统调用的返回值：<strong>父进程获得子进程的PID，子进程的返回值是0</strong></p></li></ul><h3 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h3><p>有两种模式：用户模式和内核模式，用户模式下功能受限，如I&#x2F;O请求无法发送，但可以通过<strong>特殊的陷阱（trap）指令</strong>从用户模式进入内核模式，进入内核后系统就可以执行任何需要的特权操作，执行完成后，操作系统调用一个特殊的从陷阱返回(return-from-trap)指令回到用户模式。</p><h3 id="多级反馈队列MLFQ"><a href="#多级反馈队列MLFQ" class="headerlink" title="多级反馈队列MLFQ"></a>多级反馈队列MLFQ</h3><p>五条规则</p><ul><li>任务A的优先级高于任务B，先执行任务A，再执行任务B（保证高优先级任务的响应速度，提高系统的实时性。）</li><li>任务A的优先级等于任务B，以轮询的方式执行任务A、B（在同等级中实现公平性，防止个别任务长期占用CPU。）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420102050486.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420102132273.png" alt="Round-Robin"></li><li>新任务进入队列，放在最高优先级的队列执行（提高新任务启动速度，增强系统交互性。）</li><li>一旦工作用完了其在某一层中的时间配额，无论中间主动放弃了多少次CPU，就降低其优先级。（避免任务通过频繁放弃CPU来“欺骗”调度器长期占用高优先级。）</li><li>经过一段时间S后，就将所有任务重新加入到最高优先级（避免低优先级任务长时间得不到执行，防止饥饿现象。）</li></ul><h3 id="调度-比例份额"><a href="#调度-比例份额" class="headerlink" title="调度-比例份额"></a>调度-比例份额</h3><p>彩票数(ticket)代表了进程(或用户或其他)占有某个资源的份额，一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。拥有的彩票数越多，那被调度的概率也就越大。<br>三大特性：</p><ul><li>彩票货币</li><li>彩票转让：一个进程临时将自己的彩票转移给另一个进程</li><li>彩票通胀：一个进程的彩票数可以临时提升或降低告诉操作系统我需要CPU。</li></ul><p>步长调度：其实就是时间片轮转，执行完当前的步长然后去看看队列中现在谁的总步长最短，就去执行它，如果所有人的步长都相同了，那就随机抽一个去执行。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>如何将内存中的逻辑地址转换为物理地址？</p><ol><li>绝对装入</li><li>静态重定位</li><li>动态重定位</li></ol><ul><li>基址寄存器 + 逻辑地址 &#x3D; 真实地址 （基址寻址） 采用动态重定位时<strong>允许程序在内存中发生移动</strong></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>单片机没有OS，每一次运行都需要重新烧录，<strong>单片机的CPU直接操作内存的物理地址。<strong>在单片机的情况下不可能同时运行两个程序，因为内存地址会被覆盖。<br>操作系统通过</strong>虚拟内存</strong>来解决这个问题。<br>操作系统通过为每一个进程分配一套独立的<strong>虚拟地址</strong>，进程在自己的虚拟地址里进行操作，最后OS通过映射关系映射到不同的物理地址上。进程持有的<strong>虚拟地址</strong>会通过CPU芯片上的MMU（Memory Management Unit）来转换成<strong>物理地址。</strong></p><blockquote><p>操作系统是如何管理虚拟内存和物理内存之间的关系？<br>主要有两种，<code>内存分段</code>和<code>内存分页</code>。</p></blockquote><h4 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h4><p>程序是由若干个逻辑分段组成的，如可用代码分段，数据分段，栈段，堆段组成，不同的段有不同的属性。<br>分段机制下的虚拟地址由两部分组成：<code>段选择子和段内偏移量</code></p><ul><li>段选择子：保存在段寄存器内，最重要的是段号，用作段的索引，段表里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li><li>段内偏移量：应位于<strong>0和段界限之间</strong>，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602121417844.png"></li></ul><h4 id="分段产生的两个问题：内存碎片和内存交换效率低"><a href="#分段产生的两个问题：内存碎片和内存交换效率低" class="headerlink" title="分段产生的两个问题：内存碎片和内存交换效率低"></a>分段产生的两个问题：<strong>内存碎片</strong>和<strong>内存交换效率低</strong></h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602121756991.png"></p><ul><li>游戏512MB</li><li>浏览器128MB</li><li>音乐256MB<br>如果浏览器被关闭了，新的200MB的程序也无法写入，出现了<strong>内存外部碎片</strong>的问题。此时可以通过<strong>内存交换</strong>来解决：</li><li>可以把音乐程序占用的那256MB内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的512MB内存后面。这样就能空缺出连续的256MB空间，于是新的200MB程序就可以装载进来。<blockquote><p>分段为什么导致内存交换效率低？</p></blockquote></li><li>对于多进程系统，外部碎片的产生很常见，就不得不使用Swap内存区域，但是硬盘上的访问速度远比内存低，每一次交换都需要把一大段连续内存数据写到硬盘上。</li></ul><h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>为了解决内存分段的交换效率低以及内存碎片问题，提出了内存分页。</p><ul><li>将内存空间分为一个个<strong>大小相等</strong>的分区，每个分区就是一个<strong>页框&#x3D;&#x3D;页帧&#x3D;&#x3D;物理块&#x3D;&#x3D;物理页面</strong></li><li>将<code>进程的逻辑地址空间</code>也分成与<strong>页框大小相等</strong>的一个个部分，每个部分称为一个<code>页</code>或<code>页面</code><br>进程的页面和内存的页框是一一对应的，大小相等。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602134849717.png"><br>每个进程都有一张页表，一个进程对应着一张页表，每个页表项由<code>页号</code>和<code>块号</code>组成，页表记录进程页面和实际存放的内存块之间的映射关系<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250602140351399.png"><br>前12位就代表在几号页，后20位就是页内偏移量</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>下标访问的复杂度为O(1)</li><li>末尾位置增加删除元素时间复杂度为O(1)  删除就是–，增加就是++</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>非末尾元素增加位置需要<strong>大量的数据移动</strong></li><li><strong>搜索的复杂度是O(n)</strong>  注意搜索和访问不是一个东西，搜索是遍历寻找这个值，而访问是a[0]–a[n-1]，在<strong>无序数组</strong>中采用遍历，是<strong>线性搜索</strong>；在<strong>有序数组</strong>中采用二分，复杂度为O(logn)</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>内存利用率高，不需要大块连续内存</li><li>插入和删除节点不需要移动其它节点，时间复杂度O(1)</li><li>不需要专门进行扩容操作</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>内存占用量大，每一个节点多出存放地址的空间</li><li>节点内存不连续，无法进行内存随机访问</li><li>链表搜索效率不高，只能从头节点开始逐节点遍历</li></ul><h4 id="内存碎片化"><a href="#内存碎片化" class="headerlink" title="内存碎片化"></a>内存碎片化</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411081508857.png"><br>现在我们有100M的内存空间（堆上），<strong>内存的释放是一块一块的，谁用完了谁就被释放了</strong>，如果将中间的20M和最右边的10M手动释放掉；我们就得到了两块内存碎片；现在我们有30M的空闲空间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411081846625.png"><br>如果现在进程运行需要25M的内存空间，我们能不能分配25M的数组呢？ <strong>不能</strong>，数组的内存是绝对连续的<br>在<strong>内存碎片</strong>过多的情况下，无法开辟大数组，这时候就可以用<strong>链表</strong>，每一个节点都是独立new出来的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411082625810.png"><br>从头节点访问到最后一个节点，最后一个节点的地址域为<strong>NULL</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> data = <span class="number">0</span>) : <span class="built_in">data_</span>(data),<span class="built_in">Next_</span>(<span class="literal">nullptr</span>)&#123;&#125; </span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">    Node *Next_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体其实就是一个public的类，现在写了一个<strong>Node</strong>的构造函数，如果不传参默认data就是0。为什么后面要加一个大括号？因为前面在初始化，初始化已经完成了，后面是函数体{}可以是空的。<br>不要总去判断当前节点的下一节点<strong>是否为空</strong>，老老实实判断当前节点是否为空，除非你真的要去找末尾节点。</p><h3 id="链表接口"><a href="#链表接口" class="headerlink" title="链表接口"></a>链表接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> data = <span class="number">0</span>):<span class="built_in">data_</span>(data),<span class="built_in">next_</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"><span class="type">int</span> data_;</span><br><span class="line">Node *next_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clink</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Clink</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//给head初始化，指向头节点 </span></span><br><span class="line">head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Clink</span>()</span><br><span class="line">&#123;</span><br><span class="line">Node *p = head;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">head = head-&gt;next_;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//尾插法 复杂度O(n) 因为要遍历整个链表 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertTail</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//先找到当前链表的末尾节点</span></span><br><span class="line">Node *p = head;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next_!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成新节点 </span></span><br><span class="line">Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">p-&gt;next_ = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头插法 复杂度O(1) 因为直接找到头节点的下一节点 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertHead</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">node-&gt;next_ = head-&gt;next_;</span><br><span class="line">head-&gt;next_ = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表单个节点删除 用双节点法 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = head-&gt;next_;</span><br><span class="line">Node *q = p; <span class="comment">//q永远跟在p后面 </span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;next_ = p-&gt;next_;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q = p; </span><br><span class="line">p = p-&gt;next_;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = head-&gt;next_;</span><br><span class="line">Node *q = head;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">&#123;</span><br><span class="line">q-&gt;next_ = p-&gt;next_;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">//delete只是释放指针指向的内存，指针本身不改变 </span></span><br><span class="line">p = q-&gt;next_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">q = p;</span><br><span class="line">p = p-&gt;next_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = head-&gt;next_;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;p-&gt;data_&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">p = p-&gt;next_;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node *p = head-&gt;next_;</span><br><span class="line"><span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next_;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//指向链表的头节点 </span></span><br><span class="line">Node *head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Clink c;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">c.<span class="built_in">InsertHead</span>(val);</span><br><span class="line">cout&lt;&lt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">InsertHead</span>(<span class="number">23</span>);</span><br><span class="line">c.<span class="built_in">InsertHead</span>(<span class="number">23</span>);</span><br><span class="line">c.<span class="built_in">InsertTail</span>(<span class="number">23</span>);</span><br><span class="line">c.<span class="built_in">show</span>();</span><br><span class="line">c.<span class="built_in">RemoveAll</span>(<span class="number">23</span>);</span><br><span class="line">c.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>数组：下标访问&#x2F;随机访问多、搜索</li><li>链表：增加、删除多<br>不过还是要看插入哪里，如果插入中间位置都是O(n)</li></ul><p><strong>后续我自己rewrite发现语法出问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">mylink</span>()&#123;</span><br><span class="line"><span class="function">Node <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//head = new Node();</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">mylink</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我一开始写的是没有注释的 <em>Node head()</em> 这样程序无法运行，为什么呢？因为这是一个<strong>函数声明</strong>，返回值为Node的函数声明！<strong>并没有创造出对象！<strong>所以我们需要new一个对象出来！<br>而且不要</strong>空想一个头节点</strong>，题目如果给你链表是:1,2,3,4,5。那就是这样，第一个节点就是头节点。</p><ul><li>单链表逆序 <strong>头插法</strong></li><li>单链表求倒数第k个节点 <strong>双指针，第一个指针先移动k</strong></li><li>合并两个有序的单链表 <strong>双指针比较大小</strong></li><li></li><li></li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出</p><h3 id="栈接口"><a href="#栈接口" class="headerlink" title="栈接口"></a>栈接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 c++stack push,pop, </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SeqStack</span>(<span class="type">int</span> size = <span class="number">10</span>) : <span class="built_in">mtop</span>(<span class="number">0</span>),<span class="built_in">mcap</span>(size)</span><br><span class="line">&#123;</span><br><span class="line">mpStack = <span class="keyword">new</span> <span class="type">int</span>[mcap];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">SeqStack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []mpStack;</span><br><span class="line">mpStack = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mtop==mcap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">expand</span>();</span><br><span class="line">&#125;</span><br><span class="line">mpStack[mtop++] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mtop==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>;</span><br><span class="line">mtop--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (mtop==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> mpStack[mtop<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mtop==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mtop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[mcap*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;mcap;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = mpStack[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []mpStack;</span><br><span class="line">mpStack = p;</span><br><span class="line">mcap = <span class="number">2</span>*mcap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> *mpStack;</span><br><span class="line"><span class="type">int</span> mtop; <span class="comment">//栈顶位置 </span></span><br><span class="line"><span class="type">int</span> mcap; <span class="comment">//栈空间大小 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="function">SeqStack <span class="title">stack</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;stack.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">stack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>环形队列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250413145914558.png"><br>不能用++，留下一个位置来判断是否为空</p><ul><li>入队:(rear+1)%length</li><li>出队（first+1）%length</li><li>满 (rear+1)%length &#x3D;first</li><li>空rear &#x3D; rear</li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul><li>冒泡排序：相邻两两元素比较，值大&#x2F;小的元素往下交换；缺点：数据交换次数太多</li><li>选择排序：每次在剩下的数据选择最大&#x2F;最小的数据和当前元素进行交换；缺点：交换次数仍然多</li><li>插入排序：**如果数据趋于有序，那么插入排序是所有排序算法中效率最高的算法！**插入排序效率&gt;冒泡&amp;&amp;选择，不仅没有交换，而且比较的次数也少。</li><li>希尔排序：插入排序PLUS，从全局先将数据调整为趋于有序。对数据<strong>进行分组插入排序</strong></li><li>快速排序：<strong>选取一个基准数</strong>，把小于基准数的元素放到基准数左边，大于基准数的元素放在右边；<strong>然后对基准数两边的序列进行同样的操作</strong>（递归）</li><li>归并排序: 二路归并</li><li></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;arr.<span class="built_in">size</span>()-i<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j]&gt;arr[j<span class="number">+1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[j],arr[j<span class="number">+1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a: arr)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bubble</span>(arr);</span><br><span class="line"><span class="built_in">show</span>(arr);</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>冒泡排序就是像气泡一样，慢慢往下沉或慢慢往上浮，j循环是数组的大小-i-1;对于函数传参，我们如果定义普通的数组的话，传(int arr[],int n)，数组名就是一个指针。<br>复杂度：<strong>外层循环O(n)，内层循环也是一个O(n)，O(n方)</strong><br>为什么j是size-1-i，因为<strong>a[j]要和a[j+1]来比较，所以有-1</strong>，每一次排序都会排好一个数，所以-i，第一次没排好，第二次排了1个少循环一次。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxIndex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i;j&lt;arr.<span class="built_in">size</span>();j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j]&gt;arr[maxIndex]) maxIndex = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr[i],arr[maxIndex]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存放<strong>最大值&#x2F;最小值的</strong>下标，比较结束后用下标来索引交换。<br>复杂度O(n)<em>O(n)，是一个*<em>不稳定的排序算法</em></em> &#x2F;&#x2F;5 5 3,第一个5和3交换后这个5跑去后面了。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = i<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> val = arr[i];</span><br><span class="line"><span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val&gt;=arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[j<span class="number">+1</span>] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j<span class="number">+1</span>] = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250413173038592.png"><br>为什么i要从1开始？因为之前的序列默认有序了，定义j在外面是为下面能成功访问j。<br>时间复杂度最坏O(n)*O(n)，最好O(n)；空间O(1)。稳定性好，</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>()/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> val = arr[i];</span><br><span class="line"><span class="type">int</span> j = i-gap;</span><br><span class="line"><span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j-=gap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val&gt;=arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[j+gap] = arr[j];</span><br><span class="line">&#125;</span><br><span class="line">arr[j+gap] = val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)*O(n)最坏，最好O(n)，不稳定。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> val = arr[l]; <span class="comment">//最左边的当作基准数</span></span><br><span class="line"><span class="comment">//l == r的位置就是放基准数的位置 </span></span><br><span class="line"><span class="keyword">while</span> (l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp;arr[r] &gt; val)</span><br><span class="line">&#123;</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">arr[l] = arr[r];</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l&lt;r&amp;&amp;arr[l]&lt;val)</span><br><span class="line">&#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">arr[r] = arr[l];</span><br><span class="line">r--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[l] = val;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> pos = <span class="built_in">Partition</span>(arr,begin,end);</span><br><span class="line"><span class="built_in">QuickSort</span>(arr,begin,pos<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(arr,pos<span class="number">+1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(a,<span class="number">0</span>,a.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>函数传参的时候是要传起始位置，而不是具体的a[0]。<br>时间复杂度O(nlogn)，空间复杂度O(logn) 二叉树递归所占用的栈内存<br>是<strong>不稳定</strong>的排序</p><p>快速排序的优化</p><ul><li>排的越来越有序的时候，找一个合适的地方调用插入排序，因为插入排序是效率最高的当趋于有序的时候</li><li>采用<strong>三数取中</strong>法，L，R，Mid（（l+r）&#x2F;），取这三个数值在中间的数作为基准数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[mid]) <span class="built_in">swap</span>(arr[l], arr[mid]);</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[r]) <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[r]) <span class="built_in">swap</span>(arr[mid], arr[r]);</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[mid]); <span class="comment">// 将中位数放到最左边</span></span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">medianOfThree</span>(arr, l, r);</span><br><span class="line">    <span class="comment">// 原先 Partition 的逻辑保持不变</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; val) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[l++] = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; val) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[r--] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = val;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INSERTION_SORT_THRESHOLD = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[mid]) <span class="built_in">swap</span>(arr[l], arr[mid]);</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[r]) <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[r]) <span class="built_in">swap</span>(arr[mid], arr[r]);</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[mid]); <span class="comment">// 中位数放到最左边</span></span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">medianOfThree</span>(arr, l, r);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; val) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[l++] = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; val) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[r--] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = val;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= l &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt;= INSERTION_SORT_THRESHOLD) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">Partition</span>(arr, begin, end);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, begin, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, pos + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HybridSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">InsertionSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含了三数取中 + 插入排序的优化。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414121639433.png"><br>归 ： 递归 要先递，才能归。<br>并 ： 合在一起<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414122146161.png"><br>递归到结束（<strong>每个子树都只有一个元素</strong>）后要进行合并，合并要开辟新的内存空间，直到所有的子树都能合并起来，要一直开辟内存，很耗内存。<br><strong>要递归的时候函数传参需要传起始位置和终止位置，就像快排那样传参</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector &lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[r-l<span class="number">+1</span>];  <span class="comment">//38 62 99     75 81   4-0+1=5</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = l;</span><br><span class="line"><span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i]&lt;=arr[j])</span><br><span class="line">&#123;</span><br><span class="line">p[index++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p[index++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">&#123;</span><br><span class="line">p[index++] = arr[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">p[index++] = arr[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再把合并好的大段有序结果，拷贝回arr[r,l]区间内 </span></span><br><span class="line"><span class="keyword">for</span> (i = l,j = <span class="number">0</span>;i &lt;=r;i++,j++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = p[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin&gt;=end) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//要先进行递，才能进行归</span></span><br><span class="line"><span class="type">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">MergeSort</span>(arr,begin,mid);</span><br><span class="line"><span class="built_in">MergeSort</span>(arr,mid + <span class="number">1</span>,end);</span><br><span class="line"><span class="comment">//再归并，把两个小段有序的序列合并成大段</span></span><br><span class="line"><span class="built_in">Merge</span>(arr,begin,mid,end); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">MergeSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个稳定的算法</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="二叉堆-大根堆-小根堆"><a href="#二叉堆-大根堆-小根堆" class="headerlink" title="二叉堆&amp;大根堆&amp;小根堆"></a>二叉堆&amp;大根堆&amp;小根堆</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414125441474.png"><br><strong>完全二叉树的最后一层叶子节点</strong>靠左排列，用数组存放的数在逻辑上可以被视为完全二叉树，2i+<br>1和2i+2<br>大根堆和小根堆只是基于二叉堆的基础规定了当前节点和两个孩子节点值的大小关系。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414125908109.png"></p><ul><li><p>叶子节点（树枝的末端，没有子节点）找到第一个非叶子节点：(末位元素下标-1)&#x2F;2</p></li><li><p>大根堆：arr[i] &gt; arr[i<em>2+1]&amp;&amp;arr[i] &gt; arr[i</em>2+2]</p></li><li><p>小根堆：arr[i] &lt; arr[i<em>2+1]&amp;&amp;arr[i] &lt; arr[i</em>2+2]<br>操作堆的时候像队列&#x2F;栈一样，只能操作堆顶元素</p></li><li><p>STL里的sort算法用的是什么排序？<br>快速排序 + 插入排序 （32的时候转为插入） + 堆排序（递归深度过深）</p></li><li><p>快速排序的时间复杂度不是稳定的nlogn，如何解决恶化问题<br>1.转插入排序 2.三数取中，选择合适的基准数</p></li><li><p>递归过深会引发什么问题？<br>函数开销变大，导致栈内存溢出，程序挂掉</p></li><li><p>怎么控制递归深度？如果达到递归深度了还没排完序怎么办？<br>转换成非递归的排序方式，如堆排序，好坏都是nlogn。</p></li></ul><h4 id="二叉堆代码"><a href="#二叉堆代码" class="headerlink" title="二叉堆代码"></a>二叉堆代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//using是定义类型别名，这里定义了一个Comp的比较大小函数 </span></span><br><span class="line"><span class="keyword">using</span> Comp = function&lt;<span class="built_in">bool</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;; </span><br><span class="line"><span class="built_in">PriorityQueue</span>(<span class="type">int</span> cap = <span class="number">20</span>,Comp comp = <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) <span class="comment">//默认大根堆 </span></span><br><span class="line">:<span class="built_in">size_</span>(<span class="number">0</span>)</span><br><span class="line">,<span class="built_in">cap_</span>(cap)</span><br><span class="line">,<span class="built_in">comp_</span>(comp)</span><br><span class="line">&#123;</span><br><span class="line">que_ = <span class="keyword">new</span> <span class="type">int</span>[cap];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PriorityQueue</span>(Comp comp) <span class="comment">//小根堆，通过传比较器对象实现 </span></span><br><span class="line">:<span class="built_in">size_</span>(<span class="number">0</span>)</span><br><span class="line">,<span class="built_in">cap_</span>(<span class="number">20</span>)</span><br><span class="line">,<span class="built_in">comp_</span>(comp)</span><br><span class="line">&#123;</span><br><span class="line">que_ = <span class="keyword">new</span> <span class="type">int</span>[cap_];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">PriorityQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []que_;</span><br><span class="line">que_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//入堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size_==cap_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*cap_];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;cap_;i++)</span><br><span class="line">&#123;</span><br><span class="line">p[i] = que_[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []que_;</span><br><span class="line">que_ = p;</span><br><span class="line">cap_ = <span class="number">2</span>*cap_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size_==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有一个元素不用上浮调整。 </span></span><br><span class="line">que_[size_] = val; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//有多个元素，插入位于大小位置的下标 </span></span><br><span class="line"><span class="built_in">ShiftUp</span>(size_,val);</span><br><span class="line">&#125;</span><br><span class="line">size_++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size_ == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;The container is empty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">size_--;</span><br><span class="line"><span class="keyword">if</span> (size_ &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//删除堆顶元素，还有剩余的元素，进行下沉</span></span><br><span class="line"><span class="built_in">ShiftDown</span>(<span class="number">0</span>,que_[size_]); </span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_==<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> que_[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) <span class="comment">//最多计算到根节点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> father = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">comp_</span>(val,que_[father]))</span><br><span class="line">&#123;</span><br><span class="line">que_[i] = que_[father];</span><br><span class="line">i = father;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">que_[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i&lt;size_/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> child = <span class="number">2</span>*i <span class="number">+1</span>;</span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt;size_&amp;&amp;<span class="built_in">comp_</span>(que_[child<span class="number">+1</span>],que_[child]))</span><br><span class="line">&#123;</span><br><span class="line">child = child + <span class="number">1</span>; <span class="comment">//如果右孩子的值大于左孩子，child记录右孩子的下标</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">comp_</span>(que_[child],val))</span><br><span class="line">&#123;</span><br><span class="line">que_[i] = que_[child];</span><br><span class="line">i = child;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">break</span>; <span class="comment">//已经满足了堆的性质，提前出 </span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">que_[i] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> *que_; <span class="comment">//指向动态扩容的数组 </span></span><br><span class="line"><span class="type">int</span> size_; <span class="comment">//元素个数</span></span><br><span class="line"><span class="type">int</span> cap_; <span class="comment">//数组的总空间大小</span></span><br><span class="line">Comp comp_; <span class="comment">//比较器对象 </span></span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//PriorityQueue que; //第一个构造函数 </span></span><br><span class="line"><span class="function">PriorityQueue <span class="title">que</span><span class="params">([](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&lt;b;&#125;)</span></span>;<span class="comment">//第二个构造函数 </span></span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;que.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>快速的查询时要第一时间想到哈希表。</p><ul><li>有序的关联容器：set\map （红黑树实现，O(logn)）</li><li>无序的关联容器：unordered_set\unordered_map （哈希表O(1)）</li></ul><h3 id="通过哈希函数（除留余数法实现）"><a href="#通过哈希函数（除留余数法实现）" class="headerlink" title="通过哈希函数（除留余数法实现）"></a>通过哈希函数（除留余数法实现）</h3><ul><li>如何解决哈希冲突？<br>1.线性探测法 2.链地址法<br>3.设置哈希表的长度为素数，可以尽可能的减少哈希冲突</li><li><pre><code>如果你长度为8，有很多能mod8的数都会被存到同一个位置；如果是素数，则会减少一些。</code></pre></li></ul><p>4.设置哈希表装载因子（已用个数&#x2F;容量）</p><ul><li>一般是0.75，超过了0.75后就要将哈希表<strong>扩容</strong>，扩容会从素数表里面找下一个质数作为新的容量，原来哈希表中的元素需要在新的哈希表中<strong>重新哈希</strong></li></ul><p>查找<br>未发生哈希冲突 O(1) 比如18%7 &#x3D; 4，去看arr[4]有无18；如果发生了哈希冲突，就要往后去遍历，O(n)可能是线性探测.<br>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">STATE_UNUSE, </span><br><span class="line">STATE_DELETE, <span class="comment">//在哈希表中，我们删除元素不用置成0，而是设置状态 </span></span><br><span class="line">STATE_USING,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要用vector，vector会自动扩容，我们自己用指针来 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bucket</span>&#123;</span><br><span class="line"><span class="built_in">Bucket</span>(<span class="type">int</span> key = <span class="number">0</span>,State state = STATE_UNUSE)</span><br><span class="line">:<span class="built_in">key_</span> (key),<span class="built_in">state_</span>(state)&#123;&#125;</span><br><span class="line"><span class="type">int</span> key_; <span class="comment">//存储的数据 </span></span><br><span class="line">State state_; <span class="comment">//桶的当前状态 </span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个类，先去处理成员变量 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HashTable</span>(<span class="type">int</span> size = primes_[<span class="number">0</span>],<span class="type">double</span> LoadFactor = <span class="number">0.75</span>)</span><br><span class="line">:<span class="built_in">useBucketNum_</span>(<span class="number">0</span>)</span><br><span class="line">,<span class="built_in">loadFactor_</span>(LoadFactor)</span><br><span class="line">,<span class="built_in">primeIdx_</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//把用户传入的size调整到最近的比较大的素数上（因为用户可能传入非素数）</span></span><br><span class="line"><span class="keyword">if</span> (size != primes_[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (;primeIdx_&lt;PRIME_SIZE;primeIdx_++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (primes_[primeIdx_]&gt;size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (primeIdx_ == PRIME_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">primeIdx_--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tableSize_ = primes_[primeIdx_];</span><br><span class="line">table_ = <span class="keyword">new</span> Bucket[tableSize_];</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">HashTable</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []table_;</span><br><span class="line">table_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> factor = useBucketNum_*<span class="number">1.0</span> / tableSize_;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;factor:&quot;</span>&lt;&lt;factor&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span> (factor &gt; loadFactor_)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">expand</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> idx = key % tableSize_;</span><br><span class="line"><span class="type">int</span> i = idx;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (table_[i].state_!=STATE_USING)</span><br><span class="line">&#123;</span><br><span class="line">table_[i].state_ = STATE_USING;</span><br><span class="line">table_[i].key_ = key;</span><br><span class="line">useBucketNum_++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">i = (i + <span class="number">1</span>)%tableSize_;</span><br><span class="line">&#125;<span class="keyword">while</span> (i!=idx);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (table_[idx].state_!= STATE_USING)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">table_[idx].state_ = STATE_USING;</span></span><br><span class="line"><span class="comment">table_[idx].key_ = key;</span></span><br><span class="line"><span class="comment">return true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//如果第一个位置是被using的，那就从idx往下找，让数组成环 </span></span><br><span class="line"><span class="comment">for (int i = (idx+1)%tableSize_;i!=idx;i=(i+1)%tableSize_)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if (table_[i].state_!=STATE_USING)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">//代码重复冗余，用dowhile优化，因为一开始就要做一次判断 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> idx = key % tableSize_;</span><br><span class="line"><span class="type">int</span> i = idx;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (table_[i].state_==STATE_USING&amp;&amp;table_[i].key_==key)</span><br><span class="line">&#123;</span><br><span class="line">table_[i].state_ = STATE_DELETE;</span><br><span class="line">useBucketNum_--;</span><br><span class="line">&#125;</span><br><span class="line">i = (i<span class="number">+1</span>)%tableSize_;</span><br><span class="line">&#125;<span class="keyword">while</span> (table_[i].state_!=STATE_UNUSE&amp;&amp;i !=idx ); <span class="comment">//遇到了unuse说明发生冲突后也没往后插了 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> idx = key % tableSize_;</span><br><span class="line"><span class="type">int</span> i = idx;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (table_[i].state_==STATE_USING&amp;&amp;table_[i].key_==key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">i = (i<span class="number">+1</span>)%tableSize_;</span><br><span class="line">&#125;<span class="keyword">while</span> (table_[i].state_!=STATE_UNUSE &amp;&amp; i != idx); <span class="comment">//遇到了unuse说明发生冲突后也没往后插了 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">++primeIdx_;</span><br><span class="line"><span class="keyword">if</span> (primeIdx_ == PRIME_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;HashTable is large enought and it can&#x27;t be expanded&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bucket *newTable = <span class="keyword">new</span> Bucket[primes_[primeIdx_]];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;tableSize_;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (table_[i].state_==STATE_USING) <span class="comment">//旧表中有效的数据重新哈希 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> idx = table_[i].key_ % primes_[primeIdx_];</span><br><span class="line"><span class="type">int</span> k = idx;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (newTable[k].state_!=STATE_USING)</span><br><span class="line">&#123;</span><br><span class="line">newTable[k].state_ = STATE_USING;</span><br><span class="line">newTable[k].key_ = table_[i].key_;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">k = (k<span class="number">+1</span>) % primes_[primeIdx_];</span><br><span class="line">&#125; <span class="keyword">while</span>(k!=idx);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> []table_;</span><br><span class="line">table_ = newTable;</span><br><span class="line">tableSize_ = primes_[primeIdx_];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Bucket *table_; <span class="comment">//指向动态开辟的哈希表</span></span><br><span class="line"><span class="type">int</span> tableSize_; <span class="comment">//哈希表的长度</span></span><br><span class="line"><span class="type">int</span> useBucketNum_; <span class="comment">//已经使用的桶的数量</span></span><br><span class="line"><span class="type">double</span> loadFactor_; <span class="comment">//装载因子</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PRIME_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> primes_[PRIME_SIZE];<span class="comment">//素数表</span></span><br><span class="line"><span class="type">int</span> primeIdx_; <span class="comment">//当前素数的下标  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> HashTable::primes_[PRIME_SIZE] = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">97</span>,<span class="number">251</span>,<span class="number">443</span>,<span class="number">911</span>,<span class="number">1471</span>,<span class="number">42773</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HashTable htable;</span><br><span class="line">htable.<span class="built_in">insert</span>(<span class="number">21</span>);</span><br><span class="line">htable.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">htable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line">htable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">htable.<span class="built_in">insert</span>(<span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;htable.<span class="built_in">find</span>(<span class="number">14</span>)&lt;&lt;endl;</span><br><span class="line">htable.<span class="built_in">erase</span>(<span class="number">14</span>);</span><br><span class="line">cout&lt;&lt;htable.<span class="built_in">find</span>(<span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h3><h4 id="查重"><a href="#查重" class="headerlink" title="查重"></a>查重</h4><p>查重或者统计重复的次数，查询的<strong>效率高</strong>但是<strong>占用内存空间较大</strong>。<br>找<strong>第一个重复出现的数字</strong><br>用unordered_set来查，先遍历数组，然后用find函数去查询是否哈希表里是否存在有这个数（find返回的是迭代器的值，如果没找到就返回哈希表的末尾）如果没有就会insert，有的话就会输出。切记，在map和set这里尽量都用auto，不要用下标访问。<br><strong>找第一个和找所有的其实就是加不加break</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line">unordered_set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val : a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(val);</span><br><span class="line"><span class="keyword">if</span> (it!=s.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> s.<span class="built_in">insert</span>(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找所有重复出现的元素以及重复的次数，用unordered_map，没找到，就把这个数字插入（用emplace方法），找到了，迭代器的second++（值++）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line">unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p : a)</span><br><span class="line">&#123;</span><br><span class="line">m[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> q : m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q.second&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;q.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h4><p>top K问题：大小根堆来过滤，大根堆过滤前top k小的数据；小根堆过滤前top k大的数据<br>用<strong>大根堆</strong>来找前k个最小的元素；用<strong>小根堆</strong>来找前k个最大的元素。<br>64 45 52 80 66 68 0 2 18 75<br>这十个先把前三个数组成一个大根堆，然后到第四个80，80比堆顶元素64大，说明一定比这个堆里的所有元素都大，所以往下继续找，一直到0，0比堆顶元素小，我们就调整，依次这样。<br>最后复杂度为logk * O(n)但是logk是常数级，所以最终我们以O(n)复杂度的找到topK元素。</p><p>快排分割法。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BST树（Binary-Search-Tree-二叉搜索树）"><a href="#BST树（Binary-Search-Tree-二叉搜索树）" class="headerlink" title="BST树（Binary Search Tree 二叉搜索树）"></a>BST树（Binary Search Tree 二叉搜索树）</h3><ul><li>对于二叉树上的每一个节点：<strong>左孩子的值&lt;父节点的值&lt;右孩子的值</strong></li><li>每一层的节点最多的个数2^(L-1)，第三层就是4个，第四层就是8个；</li><li>所有节点的个数N与层数的关系：等比数列求和 &#x3D; 2^L-1 &#x3D; N，2^L &#x3D; N+1，两边取对数L &#x3D; log2N</li></ul><h4 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h4><ul><li>1.没有孩子的节点 父节点地址域为nullptr</li><li>2.有一个孩子 孩子写入父节点地址域</li><li>3.删除的节点有两个孩子 ：找待删除节点的<strong>前驱节点或后继节点</strong>，用前驱&#x2F;后继将要删除的节点值覆盖掉，然后直接删除前驱&#x2F;后继就可以了。<br>前驱：左子树里最大的 后继：右子树里最小的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250418100102229.png"></li></ul><h3 id="二叉树的递归操作"><a href="#二叉树的递归操作" class="headerlink" title="二叉树的递归操作"></a>二叉树的递归操作</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250418111746902.png"><br>左右根</p><h4 id="基于后序遍历，使用递归操作来判断树的层数"><a href="#基于后序遍历，使用递归操作来判断树的层数" class="headerlink" title="基于后序遍历，使用递归操作来判断树的层数"></a>基于后序遍历，使用递归操作来判断树的层数</h4><p>int GetL(Node *node)<br>{<br>if (node!&#x3D;nullptr)<br>{<br>PostOrder(node-&gt;left);<br>PostOrder(node-&gt;right);<br>return left &gt; right ? left + 1: right + 1;<br>}<br>}</p><h4 id="基于后序遍历递归操作求层数，可以用来求节点的个数"><a href="#基于后序遍历递归操作求层数，可以用来求节点的个数" class="headerlink" title="基于后序遍历递归操作求层数，可以用来求节点的个数"></a>基于后序遍历递归操作求层数，可以用来求节点的个数</h4><p>int num(Node *node)<br>{<br>if (node &#x3D;&#x3D; nullptr) return 0;<br>int left &#x3D; num(node-&gt;left);<br>int right &#x3D; num(node-&gt;right);<br>return left + right +1;<br>}</p><h2 id="五大算法"><a href="#五大算法" class="headerlink" title="五大算法"></a>五大算法</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>算法思想：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度搜索解空<br>间树。当搜索到某一节点时，要先判断该节点是否包含问题的解，如果包含就从该节点出发继续深度搜<br>索下去，否则逐层向上回溯。一般在搜索的过程中都会添加相应的剪枝函数，避免无效解的搜索，提高<br>算法效率。<br>解空间：解空间就是所有解的可能取值构成的空间，一个解往往包含了得到这个解的每一步，往往就是<br>对应解空间树中一条从根节点到叶子节点的路径。子集树和排列树都是一种解空间，它们不是真实存在<br>的数据结构，也就是说并不是真的有这样一颗树，只是抽象出的解空间树。<br>其实很像二叉树的遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">func</span>(arr, i + <span class="number">1</span>, length);</span><br><span class="line"><span class="built_in">func</span>(arr, i + <span class="number">1</span>, length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">func</span>(arr, <span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子集树，其实就是递归选路径，需要一个辅助数组子集树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i,<span class="type">int</span> length, <span class="type">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i == length)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[j]==<span class="number">1</span>) cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*x[i] = 1; //选这条路</span></span><br><span class="line"><span class="comment">func(arr, i + 1, length,x);</span></span><br><span class="line"><span class="comment">x[i] = 0; //不选这条路</span></span><br><span class="line"><span class="comment">func(arr, i + 1, length,x);*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">&#123;</span><br><span class="line">x[i] = k;</span><br><span class="line"><span class="built_in">func</span>(arr,i<span class="number">+1</span>,length,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2025/03/30/LeetCode/"/>
      <url>/2025/03/30/LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h3 id="2025-3-30"><a href="#2025-3-30" class="headerlink" title="2025.3.30"></a>2025.3.30</h3><p><a href="https://leetcode.cn/problems/make-the-string-great/submissions/617067145/">栈专题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">makeGood</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">abs</span>(res.<span class="built_in">back</span>() - c) == <span class="number">32</span>) &#123;</span><br><span class="line">            res.<span class="built_in">pop_back</span>(); <span class="comment">// 删除上一个相反大小写的字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果栈空，直接插入；如果栈非空，比较当前插入的字符和栈内的字符ascii码差值是否为32，<strong>32为大小写关系</strong>。</p><p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/description/">左右元素和的差值</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftRightDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + nums[i + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            res[i] = <span class="built_in">abs</span>(left[i] - right[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/non-decreasing-array/description/">非递减数列</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                    nums[i<span class="number">+1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> nums[i] = nums[i<span class="number">+1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关键在于你要去改，通过当前数的左右两边数来判断是要去改这个数大还是改这个数小，改完之后接着往下去比。<br>3 4 2 3，到了4，4大于2，发现num[i-1] &gt; num[i+1] ，如果想要满足题目的非递减，那就要把num[i+1] &#x3D; num[i]，把这个数字改大，现在序列变成了3 4 4 3，到了下一个i，4&gt;3，这时候cnt++，就跳出循环了。<br>1 4 2 3，到了4，发现要把num[i]改小，所以num[i] &#x3D; num[i+1]。</p><h3 id="2025-3-31"><a href="#2025-3-31" class="headerlink" title="2025.3.31"></a>2025.3.31</h3><p><a href="https://leetcode.cn/problems/reverse-bits/">颠倒二进制串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(n&amp;<span class="number">1</span>);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>|stk[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用了位运算，第一个for循环让这整个字符串和1与（1写成二进制是000…001，所以只会剩下最后一位），然后把最后一位插入stk里；第二个for循环先让res左移一位(<strong>左移相当于后面补0，0补再多的0还是0</strong>)，不然会最后多一个0，因为初始化的时候我们已经给了一个0给他了，然后再和数组进行或运算。</p><p><a href="https://leetcode.cn/problems/power-of-two/description/">2的幂</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>今天运气真的好，又遇到了一道<strong>位运算</strong>，而且这个设计的真的很巧妙，以后遇到二进制&#x2F;幂要想到<strong>位运算</strong>。 比如8和7，8是1000，7是0111，只要他是2的幂，就一定和他的差与为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入两个整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = a &amp; b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个数 (&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;) 的二进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二个数 (&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;) 的二进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;两个数相与的结果: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(result) &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用这个程序来看看二进制出来的结果。</p><p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">汉明距离</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>) cnt++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>已经初步掌握位运算了，还是挺开心。</p><p><a href="https://leetcode.cn/problems/ransom-note/description/">赎金信</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            a[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            a[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (a[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实就是字符统计，统计看看资源够不够，但是这一题我一开始犯了一个错误，我定义的是<strong>char</strong>类型的数组，这有一个很严重的问题，char存储只能-127 ~ 128，如果同一个数多了，比如128，那再遇到下一个这个字母数组的值马上变成-127，问题就在这！<br>然后是要用<strong>字母-‘a’</strong>，因为a的ASCII码值为97，z的码值为122，差最多就是25，所以创一个26大小的就可以了。</p><p><a href="https://leetcode.cn/problems/hamming-distance/description/">汉明距离</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> xorR = x^y;</span><br><span class="line">        <span class="keyword">while</span> (xorR&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += xorR&amp;<span class="number">1</span>;</span><br><span class="line">            xorR&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是使用异或，不同位异或结果是1，然后统计1的个数就可以了。<br><a href="https://leetcode.cn/problems/n-th-tribonacci-number/description/">第N个泰波那契数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="type">int</span> temp = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是斐波那契额递归的优化版，用递归太耗费时间了，我们在n大于3的时候用for循环，找到规律f(n) &#x3D; f(n-3)+f(n-2)+f(n-1)，最后输出f(n)</p><h3 id="2025-4-1"><a href="#2025-4-1" class="headerlink" title="2025.4.1"></a>2025.4.1</h3><p><a href="https://leetcode.cn/problems/valid-mountain-array/description/">有效地山脉数组</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (size&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span>&lt;size &amp;&amp; arr[i]&lt;arr[i<span class="number">+1</span>]) i++;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span> || i == size<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span>&lt;size &amp;&amp; arr[i]&gt;arr[i<span class="number">+1</span>]) i++;</span><br><span class="line">            <span class="keyword">return</span> i == size<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ul><li>先从头开始往上爬，找峰顶</li><li>再从峰顶往下走；</li><li>最后判断是否正好走到结尾。</li></ul><p><a href="https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/description/">元素计数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">num</span> (nums);</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = num[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> min = num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> cnnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i&lt;nums.<span class="built_in">size</span>() ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]!=max &amp;&amp; num[i]!= min) cnnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是去找非最大和非最小的元素。<br><a href="https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/description/">数字小镇中的捣蛋鬼</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSneakyNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            count[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(a.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表，键值对的问题。<br><strong>特别注意</strong>：unordered_map不能通过下标去访问，而是通过<strong>键</strong>去访问数据的<br><a href="https://leetcode.cn/problems/happy-number/">快乐数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getValue</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum)!=s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">insert</span>(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>find返回的是<strong>迭代器</strong>的值，迭代器可以理解为一个指向该元素的<strong>指针</strong>，当迭代器返回的值是a.end()代表<strong>没有找到这个元素</strong>，所以我们在判断条件中使用<strong>s.find(num)<strong>得到的是一个迭代器的值，而不是布尔值，如果它不等于s.end()，那就说明已经存在了。 <em>s.end()指向的是最后一个元素的下一个位置</em><br>当我们进入</strong>无限循环</strong>的时候去想想<strong>哈希表</strong>的思路，哈希表可以快速查找。</p><p><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            res =a^res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>①任何数和自己异或就是0，最后剩下的那个数就是只出现过一次。<br>②用map，出现就值+1，去遍历值为1的。<br><a href="https://leetcode.cn/problems/majority-element-ii/">多数元素Ⅱ</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> times = nums.<span class="built_in">size</span>() / <span class="number">3</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : nums) &#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; times) &#123;</span><br><span class="line">                a.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表使用的已经比较熟练了，现在问题在于对map的取键值对语法总是忘记，以后就规范用auto，auto自动推导为迭代器，然后用.访问符就可以访问键&#x2F;值了。</p><h3 id="2025-4-2"><a href="#2025-4-2" class="headerlink" title="2025.4.2"></a>2025.4.2</h3><p><a href="https://leetcode.cn/problems/isomorphic-strings/description/">同构字符串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,<span class="type">char</span>&gt; ms,mt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> a = s[i],b = t[i];</span><br><span class="line">            <span class="keyword">if</span> (ms.<span class="built_in">count</span>(a)&amp;&amp;ms[a]!=b || mt.<span class="built_in">count</span>(b)&amp;&amp;mt[b]!=a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ms[a] = b;</span><br><span class="line">            mt[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哈希表的运用，双射，如果我在a中找到了这个字符，并且我的映射不等于b中的字符，就return false<br><a href="https://leetcode.cn/problems/word-pattern/description/">单词规律</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector &lt;string&gt; <span class="built_in">Split</span>(string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span>(iss&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            words.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,string&gt; m;</span><br><span class="line">        unordered_map &lt;string,<span class="type">char</span>&gt; m1;</span><br><span class="line">        vector&lt;string&gt; cc = <span class="built_in">Split</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;pattern.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.<span class="built_in">size</span>()!=cc.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> a = pattern[i];</span><br><span class="line">            string b = cc[i];</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(a)&amp;&amp;m[a]!=b || m<span class="number">1.</span><span class="built_in">count</span>(b)&amp;&amp;m1[b]!=a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[a] = b;</span><br><span class="line">            m1[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>istringstream 是 C++ 标准库 <sstream> 中的类，用于从字符串中像从流（例如 cin）中一样提取数据。它常用于字符串的“切割”或格式化读取。</sstream></p><ul><li>iss &gt;&gt; word 会跳过空格，自动提取下一个以空格分隔的单词。</li><li>也可以提取数字等，比如：int x; iss &gt;&gt; x;</li><li>适合用来解析以空格、换行等分隔的字符串数据。<br>要保证他是双向映射的，所以需要两个哈希表来维护。</li></ul><h3 id="2025-4-9"><a href="#2025-4-9" class="headerlink" title="2025.4.9"></a>2025.4.9</h3><p><a href="https://leetcode.cn/problems/unique-paths/description/">不同路径</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line">        <span class="comment">//vector &lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,1));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span> (i==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> dp[i][j] = dp[i][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以先从一维的动态规划数组理解，斐波那契数列1 1 2 3 5 8……dp[0] &#x3D; 1，dp[1] &#x3D; 1,从2开始往后的就是dp[i] &#x3D; dp[i-1]+dp[i-2]<br>现在是二维的图，就要去分成小的子问题，用子问题倒推回最难的问题，画一个表格就一目了然了。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250409174221016.png"><br>看这张图，只能向右或者向下移动，那我们把机器人旁边的格子设为终点，机器人有几条路可以到终点呢？只有一条，机器人斜对角也就是dp[i-1][j-1] &#x3D; dp[i][j-1] + dp[i-1][j]两种方案合起来。</p><h3 id="2025-4-10"><a href="#2025-4-10" class="headerlink" title="2025.4.10"></a>2025.4.10</h3><p><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用<strong>快慢指针法</strong>，先判断当前这个数字是不是想要的值，如果不是就让它往后滚动。</p><p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">反转字符串中的元音字母</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvowel</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">        <span class="keyword">return</span> (c==<span class="string">&#x27;a&#x27;</span> || c==<span class="string">&#x27;e&#x27;</span> || c==<span class="string">&#x27;i&#x27;</span> || c==<span class="string">&#x27;o&#x27;</span> || c==<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left &amp;&amp; !<span class="built_in">isvowel</span>(s[left])) left++;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left &amp;&amp; !<span class="built_in">isvowel</span>(s[right])) right--;</span><br><span class="line">            <span class="keyword">if</span> (right&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用双指针来实现，两边都去找元音，都找到了就交换。</p><h3 id="2025-4-11"><a href="#2025-4-11" class="headerlink" title="2025.4.11"></a>2025.4.11</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">反转链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ListNode *temp = cur-&gt;next;</span><br><span class="line">    cur-&gt;next = p;</span><br><span class="line">    p = cur;</span><br><span class="line">    cur = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用<strong>头插法</strong>，不要自己空想一个头出来！！！！！现在全世界没人比我更懂链表！</p><h3 id="2025-4-12"><a href="#2025-4-12" class="headerlink" title="2025.4.12"></a>2025.4.12</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">移除链表元素</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        ListNode *q = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        q = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">                ListNode *cur = p-&gt;next;</span><br><span class="line">                q-&gt;next = cur;  <span class="comment">// 这里更新了q指向的节点，跳过p</span></span><br><span class="line">                <span class="keyword">delete</span> p;       <span class="comment">// 删除p节点</span></span><br><span class="line">                p = cur;        <span class="comment">// p继续前进</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;  <span class="comment">// 返回新头节点</span></span><br><span class="line">        <span class="keyword">delete</span> dummy;  <span class="comment">// 删除虚拟头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在应该彻底搞懂链表到底是什么了，其实不是链表的知识不懂，是<strong>函数传参</strong>出现了问题，这个函数传进来的<strong>是一个head节点，它指向链表的头部</strong>，而不是传一个链表进来，函数前几行定义了一个虚拟的头节点，让前后两个指针往后遍历。最后返回的时候不能return q，因为q节点已经遍历完链表了啊。</p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">删除链表倒数的第N个节点</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        ListNode *q = dummy;</span><br><span class="line">        <span class="type">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *toDelete = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = toDelete-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelete;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在已经把函数传参的问题解决了，以后要多画图，像今天蓝桥杯画图就解决出来了，然后是找到倒数第N个节点，我们先虚构出一个头节点，让一个指针先走N步，然后两个指针一起往后挪动，如果前面的指针下一个是空，那说明我们后面出发的指针下一位置就是要删除节点了，我们就采用删除节点的方法，创建一个新指针指向要被删除的节点，再把链表连接起来。</p><h3 id="2025-4-13"><a href="#2025-4-13" class="headerlink" title="2025.4.13"></a>2025.4.13</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *newlink = dummy;</span><br><span class="line">        ListNode *p = list1;</span><br><span class="line">        ListNode *q = list2;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &gt;= q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                newlink = newlink-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;val &gt;= p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                newlink = newlink-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newlink-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newlink-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *res = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>今天对链表的掌握程度更上一层楼了，记住要画图进行需求分析，这样不容易乱，还有在堆内存的释放。</p><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">逆波兰表达式求值</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left+right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left - right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left*right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left/right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;</span><br><span class="line">                (a[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;/&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> right = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> left = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> val = <span class="built_in">cal</span>(left,right,a[<span class="number">0</span>]);</span><br><span class="line">                    s.<span class="built_in">push</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(a));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>逆波兰表达式也就是后缀求值，遇到数字就入栈，遇到符号就从栈里面取出两个数字进行运算。先pop出来的值作为等号右边的值，后pop出来的是等号左边的值。</p><p><a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a><br>希尔排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> gap = nums.<span class="built_in">size</span>()/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = gap;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> val = nums[i];</span><br><span class="line">                <span class="type">int</span> j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> ( ; j&gt;=<span class="number">0</span> ; j-=gap)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val &gt;= nums[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums[j+gap] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + gap] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后面慢慢更其它的。</p><h3 id="2025-4-14"><a href="#2025-4-14" class="headerlink" title="2025.4.14"></a>2025.4.14</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">反转字符串中的单词</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (ss&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        string sres;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                sres += res[i]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sres +=res[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用istringstream读取原字符串，然后将分割出来的单词插入进数组，反向遍历。<br><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">删除字符串中的所有相邻重复项</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;<span class="type">char</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">            res.<span class="built_in">push</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (res.<span class="built_in">top</span>()==s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(!res.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans += res.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>栈的应用，很简单。<br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">相交链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt2++;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 &gt;= cnt2)</span><br><span class="line">        &#123;</span><br><span class="line">            p = headA;</span><br><span class="line">            q = headB;</span><br><span class="line">            <span class="type">int</span> dif = cnt1 - cnt2;</span><br><span class="line">            <span class="keyword">while</span> (dif &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt2 &gt; cnt1)</span><br><span class="line">        &#123;</span><br><span class="line">            p = headA;</span><br><span class="line">            q = headB;</span><br><span class="line">            <span class="type">int</span> dif1 = cnt2 - cnt1;</span><br><span class="line">            <span class="keyword">while</span> (dif1 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                dif1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相交链表很有意思，在它们<strong>没有相交之前</strong>，如果第一个链表比第二个链表长，那就让长链表的指针先往下走这些差值，然后开始进行比较。<br><a href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">1.</span><span class="built_in">begin</span>(),num<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">2.</span><span class="built_in">begin</span>(),num<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxsize = <span class="built_in">max</span>(num<span class="number">1.</span><span class="built_in">size</span>(),num<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">res</span>(maxsize<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxsize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = i &lt; num<span class="number">1.</span><span class="built_in">size</span>() ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = i &lt; num<span class="number">2.</span><span class="built_in">size</span>() ? num2[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            res[i] += a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxsize<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]&gt;=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i<span class="number">+1</span>] += (res[i])/<span class="number">10</span>;</span><br><span class="line">                res[i]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string resS;</span><br><span class="line">        <span class="type">int</span> j = res.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;res[j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            resS += <span class="built_in">to_string</span>(res[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是在问你，如果超出了long long范围的加法，你怎么办？<br>用两个字符串来倒序相加，加进结果数组，如果这个数字大于等于10表明要进位，那就&#x2F;&#x3D;10，然后留下进位后的数，<strong>最后找前导0，找第一个非0元素，没找到就一直–</strong></p><h3 id="2025-4-15"><a href="#2025-4-15" class="headerlink" title="2025.4.15"></a>2025.4.15</h3><p><a href="https://leetcode.cn/problems/sort-list/description/">排序链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        ListNode *q = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *dummy = q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            dummy-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num);</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>排序用快排，先将链表中的所有数字取出来放到vector里，然后sort排序，最后使用for (int)遍历，不要用i来遍历，因为vector会自动扩容</p><h3 id="2025-4-16"><a href="#2025-4-16" class="headerlink" title="2025.4.16"></a>2025.4.16</h3><p><a href="https://leetcode.cn/problems/unique-number-of-occurrences/">独一无二的出现次数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b:m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.first!=b.first &amp;&amp; a.second==b.second)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用哈希表存储每一个数字出现的次数，然后两重循环遍历个数。<br><a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">第一个出现两次的字母</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (it==m.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">emplace</span>(a,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路：去遍历哈希表里是否有过这个字母（数字），如果没有，就把它添加进去，如果有，就说明是我们刚刚添加过的，它就是第二次出现的！<br><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中第k个最大元素</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;q.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用优先队列来实现，默认的优先队列是一个大顶堆，我们用大根堆来找前k个最小的数，如果想要设置为小根堆，需要priority_queue&lt;int,vector<int>,greater<int>&gt;，这是去找前k个最大的数；最后我们return q.top()即可得到第k个最大&#x2F;最小的数</int></int></p><h3 id="2025-4-18"><a href="#2025-4-18" class="headerlink" title="2025.4.18"></a>2025.4.18</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">树的前序、中序、后续遍历</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode *node,vector&lt;<span class="type">int</span>&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InOrder</span>(node-&gt;left,ans);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="built_in">InOrder</span>(node-&gt;right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">InOrder</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也是终于进入到树了，采用递归的思想去解决问题。</p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node,<span class="type">int</span> level,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (level == ans.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    ans[level].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;left,level<span class="number">+1</span>,ans);</span><br><span class="line">    <span class="built_in">dfs</span>(node-&gt;right,level<span class="number">+1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里使用的是vector&lt;vector<int>&gt;,使用ans.size()返回的是这个二维数组的（行）层数，一开始行数为0，就创建一行，接下来递归调用，在当前level层里push node的数值。</int></p><p><a href="https://leetcode.cn/problems/subsets/description/">子集</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Res</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt; &amp;nums,vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">Res</span>(i<span class="number">+1</span>,nums,path);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="built_in">Res</span>(i<span class="number">+1</span>,nums,path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">Res</span>(<span class="number">0</span>,nums,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>今天开始学习回溯算法，回溯其实就是一直递归，递归到了子集树的叶子节点就处理这个子集，如果没有递归到这个子集，就处理<strong>选择</strong>或者<strong>不选择</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>论文笔记</title>
      <link href="/2025/03/28/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/03/28/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="COFFEE"><a href="#COFFEE" class="headerlink" title="COFFEE"></a>COFFEE</h1><p>c:cross-layer optimization for fast and efficient executions of the SK algorithm on HPC systems with clusters of compute nodes<br>在有计算节点集群的HPC系统上快速高效执行SK算法。<br><strong>算法中：行、列都可以重新缩放</strong>，<strong>列缩放相较行缩放极其缓慢</strong>。<br>在多节点上的性能比单节点提升最高7.5倍，平均2倍；与天河一号的MPI Allreduce算法比，最高2.9，平均1.6.<br>SK算法：a simple but very useful iterative method to approach the double stochastic matrix of Sinkhorn’s theorem by alternately rescaling all rows and all columns of the given matrix.<br>对矩阵进行缩放列。</p><p>现存的SK算法大多用去搞强化学习了（应用层），或者去加速收敛，很少有研究从计算机系统架构的角度考虑改进算法，特别是高性能计算（HPC）系统。HPC有他自己独特的计算、存储以及交流能力，看看是否能发挥全部潜力。SK算法在四个代表性应用的时间占比都超过一半（BALS的卷积也这样）所以就去优化。</p><p><strong>这篇论文用MPI，通过多核、多节点集群加速SK算法。</strong><br>先分析经典算法在天河1上。<br>列缩放的时间远超行缩放，原因是<strong>通过列缩放进行的内存访问是高度非连续的，这导致了较高的缓存未命中率。</strong><br>解决方法：<strong>探险重新设计列缩放以及信息阻塞</strong>去减少缓存未命中；设计微核并且重新设计指令去<strong>增加并行性</strong></p><p>优化思想：通用矩阵乘法、分层<br>分层的思想在MPI Allreduce算法（MPI_Allreduce 是 MPI（消息传递接口）中的一个函数，用于在所有进程之间<strong>进行归约操作并广播结果。</strong>）的相关优化中非常常见。</p><p>选择SALaR（？）作为基准去研究。发现：实现Allreduce可以与SK算法的其他任务进行overlap（重叠）进一部提高性能   </p><h2 id="本篇文章的主要contribution"><a href="#本篇文章的主要contribution" class="headerlink" title="本篇文章的主要contribution"></a>本篇文章的主要contribution</h2><ul><li>我们分析了 SK 算法在 HPC 集群上的执行行为，并观察到两个主要的性能挑战。首先是其列重新缩放表现出高度非连续的内存访问模式，这导致非常高的缓存未命中率，从而大大降低了整体性能。第二，即使采用 Foster 的方法设计，列重新缩放也会严重限制并行性</li><li>我们提出了 COFFEE，这是一种新颖的方法，它实现了多级优化设计，以优化 HPC 系统中大规模 SK 算法的处理（第 IV 节）。我们通过增强 MPI Allreduce 来提高并行效率，采用有效的领导者-工作者机制，尽可能重叠节点间(intra-node)通信、节点内通信和节点内计算</li><li>我们在天河一号超级计算机上评估了 COFFEE 的原型实现，证明了其与 SOTA 解决方案相比具有显著的性能优势（第六节）。我们的实验结果表明，COFFEE 分别在单节点和多节点环境中带来了高达 7.5 倍和 2.9 倍的性能提升。</li></ul><h2 id="SK算法"><a href="#SK算法" class="headerlink" title="SK算法"></a>SK算法</h2><p>双随机矩阵,sk算法就是在行列都归一化后，每行元素相加都为1，每列元素相加也都为1<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328202355119.png"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sinkhorn</span>(<span class="params">A, max_iter=<span class="number">1000</span>, tol=<span class="number">1e-6</span></span>):</span><br><span class="line">    A = np.array(A, dtype=np.float64)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        A_prev = A.copy()</span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 行归一化</span></span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 列归一化</span></span><br><span class="line">        <span class="keyword">if</span> np.allclose(A, A_prev, atol=tol):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">A = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">3</span>, <span class="number">4</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>]])</span><br><span class="line">B = sinkhorn(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Row sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Col sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328203003067.png"></p><p>选SK算法而不是和其他算法有两重原因：</p><ul><li>现在主流的线性代数库（如 BLAS、NumPy、PyTorch 等）在进行矩阵乘法时，底层通常使用的是最基础的“三重循环”实现方式，而不是像 Strassen 或 Coppersmith-Winograd 这样的快速乘法算法。就像基本的矩阵乘法实现一样，最原始的 Sinkhorn-Knopp（SK）算法也<strong>更容易从计算机系统架构的角度进行优化</strong>。</li><li>现有的 SK 算法研究主要集中于通过<strong>减少矩阵缩放迭代次数</strong>来加快收敛速度​​，但我们的目标是<strong>减少每次迭代的时间</strong>。</li></ul><p>我们不再去限制每一行&#x2F;每一列的和接近1，而是去最后计算的时候让行&#x2F;列和为1，在计算结果之前不需要让它接近1。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328205256791.png"></p><p>Intel团队用Python。为了在超算上运行，我们选C实现，是他们SOTApython的重写，有循环展开和数据并行优化，并且性能不逊于他们。</p><p>串行处理行列缩放,明显看到列用了十几倍的时间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328212937491.png"></p><h2 id="介绍典型的并行算法"><a href="#介绍典型的并行算法" class="headerlink" title="介绍典型的并行算法"></a>介绍典型的并行算法</h2><p>关键点：如何分割数据和任务让交流<strong>少一些</strong>，让计算任务更<strong>稳定</strong>。<br>处理方法：把矩阵按行划分成多个子矩阵，每个处理器只负责其中一些行，这样在<strong>行归一化</strong>的时候每个处理器只需要处理自己的行，不需要通信；最后让通信发生在<strong>列归一化</strong>阶段，这部分可以统一优化。这样目的是<strong>把本地能算的留在本地，只在必要时跨节点通信</strong>。<br>算法执行被拆成四步：</p><ul><li>每个进程独立地对自己那一块行子矩阵进行行归一化（和算法1的第1–10行一样），不需要通信；</li><li>每个进程计算自己那部分子矩阵的列和；</li><li>调用 MPI_Allreduce 汇总所有进程的列和，得到全矩阵每列的总和；</li><li>每个进程根据上一步得到的列缩放因子，独立地对自己那块子矩阵做列归一化。<br>这样做能最大限度减少通信，仅在列缩放因子计算这一步使用 MPI，有利于并行效率。</li></ul><h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p>在计算并行效率的时候，列缩放时处理器数为16的效率也骤降？<br>原因：<strong>行缩放</strong>的时候不需要进行通信，所有的处理器被平衡地加载；但到<strong>列缩放</strong>的时候处理器在等数据。<br><em>The reason is that the row rescaling is communication free and all the processors are load balanced. While for the column rescaling, the Allreduce used to find the column sum performs a lot of inter-node and intra-node communication, so that some processors are in the process of waiting for data</em> </p><h2 id="Motivation-of-COFFEE"><a href="#Motivation-of-COFFEE" class="headerlink" title="Motivation of COFFEE"></a>Motivation of COFFEE</h2><p>我们看到了在并行处理行缩放时候节点内的通信花费了太多时间，大大降低效率；因此我们想利用节点的不同通信特点，然后提升效率。</p><p>算法设计-微核设计-MPI优化</p><h2 id="CPU-ORIENTED-OPTIMIZATION"><a href="#CPU-ORIENTED-OPTIMIZATION" class="headerlink" title="CPU-ORIENTED OPTIMIZATION"></a>CPU-ORIENTED OPTIMIZATION</h2><p>列重排算法设计（Algorithm1和2的对比）</p><h2 id="Micro-kernel-redesign"><a href="#Micro-kernel-redesign" class="headerlink" title="Micro-kernel redesign"></a>Micro-kernel redesign</h2><p>采用SIMD：SIMD（Single Instruction, Multiple Data，单指令多数据流）是一种并行计算技术，它让一个指令同时处理多个数据。常用于图像处理、音频处理、科学计算等场景，加速处理速度，提升性能。<br>采用AVX2指令集：AVX2（Advanced Vector Extensions 2）是Intel推出的SIMD指令集扩展，属于x86架构的一部分。它在AVX的基础上增强了整数运算能力，支持256位宽的YMM寄存器，可以并行处理更多数据，广泛用于图像处理、机器学习等高性能计算中。<br>修改汇编指令</p><h2 id="MPI-optimization"><a href="#MPI-optimization" class="headerlink" title="MPI optimization"></a>MPI optimization</h2><h3 id="节点内Reduce算法优化"><a href="#节点内Reduce算法优化" class="headerlink" title="节点内Reduce算法优化"></a>节点内Reduce算法优化</h3><p>二叉树效率低是因为每个处理器开销不同，尤其在根节点，其他处理器都空闲（idle），<strong>加载不均</strong>。<br>为了解决这种严重的负载不均衡问题，我们重新设计了SK算法的Reduce实现，将本地和数组分成几部分。在节点内Reduce之后，每个worker保留本地最终和的一部分并以非阻塞方式将其发送给leader。我们的节点内Reduce实现基于MPI标准原语MPI_Send和MPI_Recv，与MPICH库中Reduce的实现一致。我们没有使用打包技术，因为要传递的数据几乎是连续的，打包带来的额外开销超过了使用它带来的性能提升。</p><h3 id="节点间AllReduce算法优化"><a href="#节点间AllReduce算法优化" class="headerlink" title="节点间AllReduce算法优化"></a>节点间AllReduce算法优化</h3><p>我们使用最流行的 Ring 算法实现 Allreduce，以生成列重新缩放的全局最终总和。Ring Allreduce 的一个缺点是它没有考虑节点的层次结构。一般来说，节点之间的带宽远低于节点内的带宽。因此，最近提出了分层 Ring Allreduce。<br>图 7 显示了我们基于分层环的优化。<br>主要思想是重叠节点内 Reduce 和节点间 Allreduce 的时间。我们将本地和数组分成几个数据块。如前所述，对数据块进行 allreduce 有三个连续步骤。首先，工作者对本地和的块执行节点内 Reduce，并将本地最终总和发送给领导者（图 7 中时间 1 的红色箭头）。接下来，领导者对全局最终总和执行节点间 Allreduce（图 7 中时间 2 的红色箭头）。最后，领导者将全局最终总和广播给其工作者（图 7 中时间 3 的红色箭头）。发现不同数据块的顺序步骤可以重叠。例如，图 7 中的时间 2 表示第 i 个数据块的节点间 Allreduce（红色箭头）和第 (i + 1) 个数据块的节点内 Reduce（黑色箭头）可以同时处理。因此，我们在为 SK 算法实现 Allreduce 时将管道的思想结合到分层环中。</p><h3 id="重叠通信和计算优化"><a href="#重叠通信和计算优化" class="headerlink" title="重叠通信和计算优化"></a>重叠通信和计算优化</h3><p>当领导者执行 Allreduce 时，工作者必须停滞。我们利用这段停滞时间让工作者修改节点内的矩阵。在我们对 SK 算法的优化 Allreduce 设计中，矩阵修改的计算被添加到流水线中。<br><strong>同时完成 Allreduce 的通信任务和修改子矩阵的计算任务</strong></p><h2 id="experiment-evaluation"><a href="#experiment-evaluation" class="headerlink" title="experiment evaluation"></a>experiment evaluation</h2><h3 id="Experimental-Setup"><a href="#Experimental-Setup" class="headerlink" title="Experimental Setup"></a>Experimental Setup</h3><p>为了评估 COFFEE 的有效性，我们将其两个版本进行比较，即面向 CPU 的优化（第 IV 节），表示为 COFFEE-CPU，以及面向 MPI 的优化（第 V 节），表示为 COFFEE-MPI，与 SK 算法的两个现有实现进行比较，一个使用 Ring Allreduce 算法（MPICH-Ring），另一个在 MPICH 环境中使用 SALaR（MPICH-SALaR）<br>高密度矩阵（非零元素占 95%）、中等密度矩阵（非零元素占 50%）、稀疏矩阵（非零元素占 5%）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250330172903583.png"><br>只去算非零矩阵。</p><h3 id="CPU-Oriented-Optimization"><a href="#CPU-Oriented-Optimization" class="headerlink" title="CPU-Oriented Optimization"></a>CPU-Oriented Optimization</h3><p>在AMD平台上使用GCC编译器运行的SK算法通过我们的优化获得了最大的改进。在ARM平台上使用Clang编译器，SK算法的典型实现的性能在所有平台上都是最好的，但我们的优化在M &#x3D; N &#x3D; 16,000时仍实现了3.3倍的加速比。</p><h3 id="MPI-Oriented-Optimization"><a href="#MPI-Oriented-Optimization" class="headerlink" title="MPI-Oriented Optimization"></a>MPI-Oriented Optimization</h3><h2 id="conclusion-and-further-work"><a href="#conclusion-and-further-work" class="headerlink" title="conclusion and further work"></a>conclusion and further work</h2><p>SK算法在机器学习等领域的重要性日益凸显。本文提出并实现了一种针对SK算法实现的计算和通信的跨层优化设计，称为COFFEE。与大多数现有的通过减少缩放迭代次数来加快收敛速度​​的工作不同，COFFEE着重于通过缩短每次缩放迭代来加快收敛速度​​。我们对SK算法实现中影响性能的问题进行了深入研究。发现列缩放会导致较高的缓存未命中率和较低的并行效率。我们使用列缩放重新设计、数据分块和微内核设计等跨层优化来加速列缩放。我们还根据SK算法的特点优化了MPI Reduce和Allreduce，以提高并行效率。最后，我们在天河一号超级计算机上验证了COFFEE 的有效性。未来我们计划进一步探索和利用行缩放和列缩放之间的相关性。此外，我们计划结合GPU，充分利用异构并行计算架构，进一步提高 COFFEE 的性能。最后，我们计划研究 COFFEE 在 SK 算法稀疏矩阵上的性能，其中数据不是以数组格式存储的。</p><h1 id="HSMU-SpGEMM"><a href="#HSMU-SpGEMM" class="headerlink" title="HSMU-SpGEMM"></a>HSMU-SpGEMM</h1><p>High Shared Memory Utilization for Parallel Sparse General Matrix-Matrix Multiplication on Modern GPUs<br>在现代 GPU 上实现并行稀疏通用矩阵-矩阵乘法的高共享内存利用率(utilization)</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统的基于哈希的方法无法在减少哈希冲突和有效利用快速共享内存之间取得平衡，这严重损害了在 GPU 上执行 SpGEMM 的性能。设计了一种<strong>累加器</strong>，四个通用库在三种架构上面跑，**HSMU有显著的加速优势。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Gustavson算法在GPU上用于实现快速并行稀疏矩阵乘法时有两个流程：<strong>符号阶段(symbolic stage)<strong>以及</strong>数值阶段(numeric stage)</strong> </p><ul><li>符号阶段的主要任务是去确定矩阵C中非零元素的数量(NNZ)，以便在数值计算的时候<strong>预先分配内存</strong></li><li>数值阶段在已分配的内存上<strong>进行实际的乘法和累加</strong>，是整个SpGEMM<strong>最耗时的部分</strong><br>高效的累加器设计对数值阶段的性能至关重要。<br>单纯<strong>增加</strong>哈希表的容量会降低GPU共享内存的利用率。<br>主流SpGEMM库的不足</li><li>Nsparse 虽利用最大 NNZ 设置哈希表长度以提高共享内存利用率，但哈希冲突严重，性能下降</li><li>spECK 通过分配 1.5× 空间减少冲突但造成约 34% 内存浪费</li><li>OpSparse 建议设为 2× 最大 NNZ，性能好但共享内存利用率仅达 50%<br><strong>HSMU-SpGEMM 通过为每个累加器内核维护一个按列排序的数组（长度为分配行的最大 NNZ）来避免哈希冲突，并针对小规模与大规模矩阵设计不同的符号阶段，从而在优化 GPU 共享内存利用率下的同时保持低冲突率，实现高性能 SpGEMM。</strong></li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Gustavson 算法具有天然的并行性，因为它可以独立计算矩阵 C 的每一行。在数值阶段，矩阵 A 中每个非零元素 𝑎𝑖𝑗会与矩阵 B 中对应行𝑏𝑗∗的非零元素相乘，生成大量中间结果，这些结果的列索引与 B 中元素的列索引一致。最终，通过累加器将这些中间结果累加到矩阵 C 的相应位置。累加器的具体设计将在下一小节介绍。<br>分为两种累加器：<strong>稠密型</strong>和<strong>稀疏型</strong></p><ul><li><p>稠密累加器使用稠密数组存储中间结果，通常由三个向量组成：一个存储实际数值，一个用于标记列索引是否插入，另一个记录列索引。这种方法在处理稠密行时效率高，但对稀疏行内存需求大、性能较差。</p></li><li><p>稀疏累加器则按累加方式分为三类：基于合并、ESC 和哈希的累加器。</p></li><li><p>基于合并的稀疏累加器在 RMerge和 bhSPARSE等库中实现。这些累加器执行多次迭代，每次迭代将一个 NZ(Non-zero) 元素垂直合并到最终的稀疏向量中。由于在合并过程中使用了大小相同的临时数组，因此基于合并的稀疏累加器对于密度变化较大的矩阵表现出<strong>较低的内存利用率</strong>。</p></li><li><p>ESC 方法在处理生成大量中间产品的矩阵时存在不足。由于存储和分类大量中间产品会产生大量的空间开销和时间成本，因此效率低下。</p></li></ul><h2 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h2><p>除了寄存器文件之外，共享内存是 GPU 上最快的内存类型。共享内存的主要优点是它<strong>允许多个线程共享数据</strong>，这使得共享内存成为高效并行计算的关键 GPU 组件。共享内存可供单个线程块内的所有线程访问，并且可以将其视为可编程缓存或暂存器，在其中放置经常访问的数据。但是，GPU 上的共享内存容量有限。所以高性能共享内存是非常重要的对于现代GPU。</p><h1 id="MOTIVATION-OF-THE-WORK"><a href="#MOTIVATION-OF-THE-WORK" class="headerlink" title="MOTIVATION  OF THE WORK"></a>MOTIVATION  OF THE WORK</h1><h2 id="Principles-of-Hash-based-Accumulators"><a href="#Principles-of-Hash-based-Accumulators" class="headerlink" title="Principles of Hash-based Accumulators"></a>Principles of Hash-based Accumulators</h2><p>现有的哈希累加器要去平衡<strong>共享内存利用率</strong>和<strong>哈希碰撞率</strong></p><h2 id="Philosophy-of-HSMU-SpGEMM-Accumulator-Design"><a href="#Philosophy-of-HSMU-SpGEMM-Accumulator-Design" class="headerlink" title="Philosophy of HSMU-SpGEMM Accumulator Design"></a>Philosophy of HSMU-SpGEMM Accumulator Design</h2><ul><li>引入一个预排序列索引数组（sorted column indices array）表示 C 的非零列。使用 findInSorted(colIp, sortedColArray) 函数来定位每个中间乘积，直接查找中间乘积该落在哪个已知列上。<strong>完全消除哈希冲突，查找位置准确，无需哈希函数或冲突处理。</strong></li></ul><h1 id="HSMU-SPGEMM"><a href="#HSMU-SPGEMM" class="headerlink" title="HSMU-SPGEMM"></a>HSMU-SPGEMM</h1><h2 id="HSMU-SpGEMM-Accumulator-Design"><a href="#HSMU-SpGEMM-Accumulator-Design" class="headerlink" title="HSMU-SpGEMM Accumulator Design"></a>HSMU-SpGEMM Accumulator Design</h2><p>采用<strong>二分查找</strong>而不是哈希，<strong>可以低开销，高效率，并且很稳定</strong>。<br>有以下好处</p><ul><li>哈希法相对于二分查找法的最大优势在于，在哈希表中添加或删除项目的成本要低得多。然而，在 HSMU-SpGEMM 中，排序数组是在符号阶段预先确定的，因此我们的新累加器不需要在数字阶段更改排序数组。因此，二分查找法中维护排序结构的缺点不存在；</li><li>哈希表的一个缺点是，当发生碰撞时，它会影响其他哈希位置，并可能导致链式碰撞，导致哈希性能低下。而对于二分查找，其性能稳定，最坏情况为O（logN）。在这种情况下，二分查找优于哈希查找方法；</li><li>二分查找更适合于范围查询等复杂操作。在这种情况下，每个线程通过不断更新变量pos逐渐缩小共享col数组上的搜索范围，从而在一定程度上减少查找次数；尽管如此，对于密集和大数据，二分查找的最坏时间复杂度为O(logN)，而哈希表的理想时间为O(1)。时间复杂度的增加可能会在某些情况下降低我们的累加器设计的搜索性能。</li></ul><h2 id="Generate-the-Sorted-Ccol-Array"><a href="#Generate-the-Sorted-Ccol-Array" class="headerlink" title="Generate the Sorted Ccol Array"></a>Generate the Sorted Ccol Array</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250408135942607.png"><br>先生成maskB，对于每一行B，非零元素位置标记为1，其他为0。<br><strong>不太懂</strong>生成maskC的原理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LearningHPC</title>
      <link href="/2025/03/28/LearningHPC/"/>
      <url>/2025/03/28/LearningHPC/</url>
      
        <content type="html"><![CDATA[<h2 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants\0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br></pre></td></tr></table></figure><p>这样就可以实现图片的打开。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172122965.png"><br>因为在python里面\t或者是\n是转义字符，<strong>直接加r表示这就是原始语义</strong>。</p><p>如果要读取一个文件夹里的许多图片，需要用到os库，然后使用列表的形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dir_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants&quot;</span></span><br><span class="line">img_path_list = os.listdir(dir_path)</span><br></pre></td></tr></table></figure><p>最后达到右边的效果<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172705602.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Network</title>
      <link href="/2025/03/19/Network/"/>
      <url>/2025/03/19/Network/</url>
      
        <content type="html"><![CDATA[<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><p>The following content is about the basic knowledge of computer network.</p><h2 id="Breif-introduction"><a href="#Breif-introduction" class="headerlink" title="Breif introduction"></a>Breif introduction</h2><p>Such as smartphone, tv, safe system, car and so on.All of this are called <strong>host</strong> or <strong>end system</strong>. The end system is linked by <strong>communication link</strong>(通信链路) and <strong>packet switch</strong>(分组交换机).<br>Different communication links such as <strong>电缆、光纤、无线电频谱</strong> can spread the data with different speed. The transmission rate are measured by <strong>bit&#x2F;s or bps</strong>.These message packet(信息包) are called <strong>packet</strong>(分组).<br><em>The packet seems like truck, all of the truck trans the goods to the destination by highspeed road. The communication links like the road, the packet like the truck, and the packet switch like the fork in the road, and the end system like the building.</em><br>The end system connect the Internet by <strong>ISP</strong>(Internet Service Provider).<br>The end system, packet switch and the other part of Internet are <strong>following a series of protocol</strong>(协议). <strong>These protocols control the internet message’s receive and send</strong>. Such as TCP(Transmission Control protocol，传输控制协议) and IP(Internet protocol,网际协议) are <strong>the most important protocols in the internet</strong>.IP protocol defines the rules of sending and receiving message winin router and end system.The main protocol of Internet is called <strong>TCP&#x2F;IP</strong>.<br><strong>A socket interface</strong>(套接字接口) refers to a programming interface that allows communication between different computer systems over a network. For example, you want to write a letter for your friend, you can’t just write the letter and throw it out of the window and think he&#x2F;she can receive it. You need to put the letter into the envelop and write the full name, address, and postcode of your friend. Close the envelop and post a stamp and throw it into the post office. So all of these are the socket interface of postface, you need to obey it so that you can send your letter.</p><h2 id="What-is-protocol"><a href="#What-is-protocol" class="headerlink" title="What is protocol?"></a>What is protocol?</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319181124581.png"><br>Let’s begin at the human protocol. If you want to  say hi to the other, you need to first say ‘hi’ and wait for his response. If he gives your certain response, you can continue say what your want. But if he does’t want to response you, you can’t continue your work.<br>Now look at the picture, you tap the web’s url. You computer send a connection request message to the Web server and wait for the respond. The Web server receives that and return a connection response message. Then the computer sends a GET message, declaring what it wants to fetch from the Web server.<br>So the protocol defines the message’s format and order between two or more than two communication entity, and sending or receiving a message or something else.</p><h2 id="The-media"><a href="#The-media" class="headerlink" title="The media"></a>The media</h2><p>A bit from a series of connection link and router can arrive at the other end system. Each <strong>send-receive couple</strong> send the electromagnetic and pulse through a physical media. Such as 双绞铜线，同轴电缆，多模光纤缆. The physical media has two types: the guided media and the unguided media. For the first one, The waves go along with the solid media like 光缆，双绞铜线或同轴电缆.For the other, the waves spread through air or outter space. Such as WLAN or digital satellite channels.</p><h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185139123.png"></p><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185234778.png"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185333613.png"></p><h3 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a>陆地无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185413035.png"></p><h3 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185439185.png"></p><h2 id="The-kernel-of-network"><a href="#The-kernel-of-network" class="headerlink" title="The kernel of network"></a>The kernel of network</h2><p>In various network application, the end system(also called host) exchanges messgae to each other. The messgae can implement a control function or contain the data. For sending a message to the destination host, the source end system cuts the long message into the little data brick. This operation called packet. Every packet can be transmited by connection link or packet switch between the source and destination. The time of transmiting is the length of bits(R) dividing the rate of connection link(R). So the time is (L&#x2F;R).</p><h3 id="packet-exchange"><a href="#packet-exchange" class="headerlink" title="packet exchange"></a>packet exchange</h3><p><strong>store and forward transmission</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191400491.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191419708.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191428022.png"><br><strong>The queuing delay and packet loss</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191821692.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191916889.png"><br><strong>The forwarding table and routing protocol</strong><br>The router gets the packet from a connection link linked to it, but how does it know where to trans the packet to the destination?<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319192733925.png"></p><h2 id="The-Internet-of-Internet"><a href="#The-Internet-of-Internet" class="headerlink" title="The Internet of Internet"></a>The Internet of Internet</h2><p>Lots of ISPs connect with each other, the low-level ISP connect to the high ISP. <strong>Peer to Peer(对等，两个运营商传输和接收尽量相同的bits，不让对方赚钱)</strong><br>IXP(Internet Exchange Point) is a meeting point, the peer ISP does’nt pay the extra fees.<br><strong>多宿(别吊死在一棵树上)</strong>:low-level ISP seeks for higher ISP to connect to make sure its capacity of connection. It can avoid the trouble caused by one of the ISP, it can use the other ISP.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319195757272.png"></p><h2 id="Time-Delay"><a href="#Time-Delay" class="headerlink" title="Time Delay"></a>Time Delay</h2><p>We have four types of time delay.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201045033.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201115287.png"><br><em>dtotal &#x3D; dproc + dqueue + dtrans + dprop</em></p><h2 id="Five-protocols"><a href="#Five-protocols" class="headerlink" title="Five protocols"></a>Five protocols</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319203624856.png"><br>我说张三你是帅哥，张三的身体是主机，耳朵是端口，我选择只传输给张三一个人，然后选择走哪条路（连接层就是链路层），如果他在泰国人就可以飞机过去，在国内就火车过去，电信号就通过电缆过去，最后物理层传输。</p><h1 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h1><p>There are two types of appliication architectures, one is <strong>client-server architecture</strong>, and the other is P2P.</p><h2 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h2><p>A forever-opening host is called <em>server</em>. It serves lots of other client hosts’ request. When the server receives the request for a objection form a client, it sends the objection back as the response. When we are in the client-server architecture, the client can’t communicate with the other client. Just like the two webserver can’t communicate with each other. The sever has a solid, well-known ip, and is forever-opening. So client can always send packets to the ip to communicate with it. In this system, the famous application includes the Web, FTP, Telnet and E-mail. In general, a single sever host can’t content all of the requests. So <strong>data center</strong> which has lots of hosts is used to create strong virtual server.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320113426164.png"></p><h2 id="Process-Communication"><a href="#Process-Communication" class="headerlink" title="Process Communication"></a>Process Communication</h2><p>In operating system, actually communicaition is a process instead of application. The processes in two different end system send message to communicate through computer network. The sending message process generates and sends the message to the net. The receiving process receives the message, and maybe send the message back to response. </p><h3 id="The-client-and-sever-process"><a href="#The-client-and-sever-process" class="headerlink" title="The client and sever process"></a>The client and sever process</h3><p>The web applications consist of couple of process. In Web application, a client webserver process exchanges the message with the Web server process. For each group of communication process, <strong>a process is called client, and the other is called server</strong>.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320114830448.png"></p><h3 id="The-process’s-interface-of-computer-network"><a href="#The-process’s-interface-of-computer-network" class="headerlink" title="The process’s interface of computer network"></a>The process’s interface of computer network</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115300248.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115304351.png"></p><h3 id="Process-Find-Address"><a href="#Process-Find-Address" class="headerlink" title="Process Find Address"></a>Process Find Address</h3><p>If we want wo send a letter to the destination, the destination needs to have an address. A host’s process sends packet to another host’s process. We need to define two label: ①The address of host;②The destination host’s receiving process’s identifier.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115840795.png"></p><h2 id="Four-factors-of-transmission-serve"><a href="#Four-factors-of-transmission-serve" class="headerlink" title="Four factors of transmission serve"></a>Four factors of transmission serve</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120312829.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120317239.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120323470.png"></p><h2 id="Transmission-Layer-Protocol"><a href="#Transmission-Layer-Protocol" class="headerlink" title="Transmission Layer Protocol"></a>Transmission Layer Protocol</h2><p>TCP &#x2F; UDP<br>TCP和UDP之间的区别与联系：就像打电话和写信，你打电话能知道他是谁，打给谁，挂断之后即时有反馈，而写信在你寄出去的一瞬间你不能确保信是否会寄到他那里，以及什么时候才能寄到，信的内容是否完整（丢包）。UDP就是用于可以容忍一点点丢包，比如实时竞技游戏，视频通话。</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>A：是B吗？我要跟你通信，听得到我说话吗？<br>B：可以通信，你听得到我说话吗？<br>A：我也听得到。</p><p><em>其实二次握手就可以建立链接，三次握手是为了互相确认对方的序列号，四次挥手是因为服务端有未发送完的数据。所以需要服务端连续发两次。同时客户端最后的等待也是为了确保服务端收到ASK请求fin<del>ask</del>fin~ask,如果过了等待时间则认为服务端已经关闭（没有关闭的话会有ASK）</em></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>C：我困了，先不聊了吧<br>S：还有几件事，说完我们就睡觉……<br>……（说完之后）<br>S：好了，说完了，我挂线了<br>C：好，你挂吧<br>S挂断电话<br>C说完之后就直接睡觉了，不知道电话挂没挂断，在几分钟后听到手机没有声音传来了，即使不用睁眼也知道S挂断了</p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http(HyperText Transfer Protocol)<br>HTTP（超文本传输协议）是互联网上用来传递信息的一种规则。可以把它想象成一种通讯方式，它定义了如何发送和接收网页内容，比如文本、图片和视频等。想象一下，当你在网上浏览器里输入一个网址或点击一个链接时，你的浏览器就通过HTTP向网站的服务器发送一个请求，就像是在说：“嘿，我想看这个网页。”服务器收到这个请求后，如果网页可用，它就用同样的HTTP规则回应，发送网页的内容回来。简单来说，HTTP像是你和网站之间的对话规则，确保双方都能理解对方发送的消息。这就是你能够浏览网页和观看在线视频的原因之一。若想<strong>高效识别用户</strong>，引入了cookies，cookies就像门禁卡，我新建了一个房子，刚开始来的给一张卡刷进来，后面来的时候就拿着这张卡，网页就可以识别到你这个人做了什么。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320132409503.png"></p><h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>链路层协议的任何设备均成为<strong>节点</strong>，节点包括主机、路由器、交换机、和WIFI接入点。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320135508535.png"><br>数据链路层有三个重要的问题：封装成帧、差错检测、可靠传输。</p><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320140209418.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统</title>
      <link href="/2025/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h2><h3 id="80386通用寄存器"><a href="#80386通用寄存器" class="headerlink" title="80386通用寄存器"></a>80386通用寄存器</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312130401047.png"></p><ul><li>%ax :accumulate 累加寄存器</li><li>%bx :base 基址寄存器</li><li>%cx :count 计数寄存器</li><li>%dx :divide 放除法的商和余数</li><li>%eax : extend 扩展 表示32位的寄存器<br>%eax表示32位寄存器，%ax表示低16位，在低16位的寄存器中：%ah表示高八位，%al表示第八位</li></ul><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="1005-s-立即数寻址"><a href="#1005-s-立即数寻址" class="headerlink" title="1005.s 立即数寻址"></a>1005.s 立即数寻址</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312134223502.png"><br>movl $8,%eax; </p><ul><li>$是立即数，表示8</li><li>movl是移动的意思，将8赋值给%eax；<br>最终的运行结果如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312140455507.png"></li></ul><hr><h4 id="1006-s-寄存器寻址"><a href="#1006-s-寄存器寻址" class="headerlink" title="1006.s 寄存器寻址"></a>1006.s 寄存器寻址</h4><ul><li>movl 用于传送<strong>32</strong>位的长子值</li><li>movw 用于传送<strong>16</strong>位的子值</li><li>movb 用于传送<strong>8</strong>位的子值<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312141244989.png"><br><strong>不能把movw的w改为l，因为%bx是16位的寄存器，如果改为l试图把32位的传给16位是错误的</strong>。可以写mov &#x2F; movw<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312174829067.png"><br>命令为 movw $0x5678,%dx ; 意思是传16个字节(w)的数据到寄存器dx里，结果如我们所愿，如果用%dh&#x2F;%dl便会报错，因为%dh&#x2F;%dl是8位的寄存器;同样，也不能movw $0x5678,%edx，因为edx是32位的，所以只能写32位的地址。如下图，所以要用对应的寄存器和对应位数的mov指令或只写mov去传递数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312175249233.png"></li></ul><h4 id="1007-s-绝对寻址（直接寻址）"><a href="#1007-s-绝对寻址（直接寻址）" class="headerlink" title="1007.s 绝对寻址（直接寻址）"></a>1007.s 绝对寻址（直接寻址）</h4><p>movl 0x08048054,%exc，直接把这个内存地址赋给%exc。可以使用x&#x2F;4bx 08048054来查看以8054起的四个地址内容。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190744306.png" alt="查看内存内容"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190225523.png"><br>内存之中<strong>既可以存放数据，也可以存放指令</strong>。如图，b9是指令，从后往前看08、04、80、55就是数据。</p><h4 id="1008-s-间接寻址"><a href="#1008-s-间接寻址" class="headerlink" title="1008.s 间接寻址"></a>1008.s 间接寻址</h4><p>movl (%ebx),%eax 和寄存器寻址的区别在于第一个寄存器套上了括号，表示不是把寄存器%ebx的值赋给%eax，而是寄存器存放的数据的地址存放的内容赋给%eax。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191539026.png"><br>第一步，立即数寻址，把立即数08048054放到%ecx<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191713316.png"><br>第二步，查看08048054内存中存放的数据是什么，并将其传入<strong>16位</strong>的%ax中，得到结果0x8056，为什么是8056？因为56是低位，80是高位</p><h4 id="1009-s-变址寻址"><a href="#1009-s-变址寻址" class="headerlink" title="1009.s 变址寻址"></a>1009.s 变址寻址</h4><p>movl (%ebx,%edx),%eax 在1008的基础上，把括号内两个寄存器的值加起来，用这个内存地址去找里面的数据，然后把数据传给%eax。</p><h4 id="1010-s-比例变址寻址"><a href="#1010-s-比例变址寻址" class="headerlink" title="1010.s 比例变址寻址"></a>1010.s 比例变址寻址</h4><p>movl (%ebx,%ecx,0x2),%eax<br>%ebx为基址，%ecx与第三个参数(第三个参数只能为1，2，4，8，左移运算符)<strong>相乘</strong>并与基址相加，最后赋值给%eax。</p><h4 id="1012-s-获取变量在内存的地址"><a href="#1012-s-获取变量在内存的地址" class="headerlink" title="1012.s 获取变量在内存的地址"></a>1012.s 获取变量在内存的地址</h4><p>leal 5(%edx, %edx, 2), %eax   &#x2F;&#x2F;假设%edx的值为x, 这行代码会将%eax的值设置为”3x+5″.</p><h4 id="1013-s-栈操作指令"><a href="#1013-s-栈操作指令" class="headerlink" title="1013.s 栈操作指令"></a>1013.s 栈操作指令</h4><p>栈：先进后出<br>栈顶指针：保存在%esp寄存器中<br>压栈push出栈pop<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325154443719.png"><br>栈是往低处生长的。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155048996.png"><br>e0-4 &#x3D;dc 栈顶指针往前偏移了<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155207739.png"><br>压栈后栈顶现在存放的是88888888</p><h4 id="1014-s-跳转指令"><a href="#1014-s-跳转指令" class="headerlink" title="1014.s 跳转指令"></a>1014.s 跳转指令</h4><p>直接跳转指令</p><ul><li>jmp lable</li><li>jmp 0x0804909a</li><li>jmp *%eax</li><li>*lable<br>条件跳转指令<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325161023037.png"></li></ul><h2 id="数的表示与处理"><a href="#数的表示与处理" class="headerlink" title="数的表示与处理"></a>数的表示与处理</h2><h3 id="整数表达"><a href="#整数表达" class="headerlink" title="整数表达"></a>整数表达</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172553621.png"><br>无符号整数就是大于等于0的数，4为无符号整数的取值范围为0-15。</p><h4 id="补码形式"><a href="#补码形式" class="headerlink" title="补码形式"></a>补码形式</h4><p>最高位的权重是负数<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172840669.png"><br>具体例子如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172941441.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173019514.png"><br>对于相同的数，映射关系不同，得到的数也不同，下图是有符号数和无符号数的例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173154420.png"></p><h4 id="无符号数与有符号数的转换"><a href="#无符号数与有符号数的转换" class="headerlink" title="无符号数与有符号数的转换"></a>无符号数与有符号数的转换</h4><p>他们的二进制表示都相同，但如果是有符号数的话，第一位会乘负权重；如果是无符号数就是正常。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173537847.png"></p><h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>无符号数加法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325175049195.png"></p><h2 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h2><h3 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h3><p>求一个负数的补码：比如-25</p><ul><li>先转换成原码 10011001 （<strong>有符号数</strong>最高位为标志位，代表-128（八位的话））</li><li>负数的反码等于<strong>除标志位各个位置取反</strong> 11100110</li><li>最后得到补码，补码就是在反码的基础上+1 11100111 转成16进制为E7H。</li></ul><h3 id="指令寄存器"><a href="#指令寄存器" class="headerlink" title="指令寄存器"></a>指令寄存器</h3><p>直接寻址的无条件转移指令功能是将指令中的地址码送入<strong>PC</strong>，<strong>PC决定下一条指令执行的地址。</strong></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="定点数的表示方法"><a href="#定点数的表示方法" class="headerlink" title="定点数的表示方法"></a>定点数的表示方法</h4><ul><li>定点小数 ：小数点在符号位和数值位（<strong>决定正负数之间</strong>）比如0.875（10），转换成二进制-&gt;0.111(B)，补够8位0（小数点隐含在这个位置）01110000；如果是-0.875就是11110000，符号位还是带权。</li><li>定点整数 ：小数点在最低位后，比如32(10)-&gt;100000(B)，补够8位，00100000，因为是正数，所以符号位为0；如果是-32，就10100000，这是原码，负数在计算机中以<strong>补码的形式存放</strong>，所以我们将其除符号位的所有位置反转得到<strong>反码11011111</strong>，再在反码的基础上+1得到补码11100000.</li></ul><h4 id="浮点数法的表示方法"><a href="#浮点数法的表示方法" class="headerlink" title="浮点数法的表示方法"></a>浮点数法的表示方法</h4><p>浮点数分为符号位、阶码、尾数三个部分<br>类似于科学计数法，比如112.5(10)来表示为1.125<em>10²<br>先将112.5转成二进制数，1110000.1(B) &#x3D; 可以表示为1.1100001</em>2^6，不能写为6，要写成110，这个指数就叫做<strong>阶码</strong>。1100001就叫做<strong>尾数</strong>（小数点后的数）<br>阶码要加127，6+127 &#x3D; 133再转成二进制<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250415204713980.png"><br>第二个例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250415204903548.png"><br>[ 符号位 | 阶码8位 | 尾数23位 ]<br>在浮点数编码表示中，(<strong>基数</strong>)在机器数中不出现，是隐含的。</p><p>下列叙述中概念正确地是( D )</p><p>A 定点补码运算时,其符号位不参加运算 &#x2F;&#x2F;都参与，否则加法无法处理正负数<br>B 浮点运算中,尾数部分只进行乘法和除法运算 &#x2F;&#x2F;位数部分可以进行<strong>加减乘除</strong><br>C 浮点数的正负由阶码的正负符号决定  &#x2F;&#x2F;由*<strong>符号位</strong>决定<br>D 在定点小数一位除法中为了避免溢出被除数的绝对值一定要小于除<br>数的绝对值</p><ul><li>当尾数用<strong>补码</strong>表示的时候，数符（符号位）和<strong>尾数第一位</strong>相反，则代表这个数<strong>规格化</strong></li></ul><p>假设初始值：%dh&#x3D;CD，%eax&#x3D;98765432,则执行 movzbl %dh ,%eax<br>这样一条指令后，%eax 的值为( D )<br>A %eax&#x3D; 987654CD<br>B %eax&#x3D; CD765432<br>C %eax&#x3D; FFFFFFCD<br>D %eax&#x3D; 000000CD<br>movzbl 指令的<strong>目标寄存器</strong>是 32 位的 %eax，而这条指令的设计就是：把源操作数（一个 8 位数）零扩展成 32 位，然后整个写入目标寄存器（%eax）中，覆盖原内容。</p><p>假设初始值：%dh&#x3D;CD，%eax&#x3D;98765432,则执行 movsbl %dh ,%eax<br>这样一条指令后，%eax 的值为( C )<br>A %eax&#x3D; 987654CD<br>B %eax&#x3D; CD765432<br>C %eax&#x3D; FFFFFFCD<br>D %eax&#x3D; 000000CD<br>movsbl %dh, %eax 是一条有符号扩展指令，会将 %dh 中的 8 位值 CD（即二进制 11001101，表示负数）扩展为 32 位，扩展时高位补符号位（即补 1），得到 FFFFFFCD，并覆盖写入整个 %eax，所以最终 %eax &#x3D; FFFFFFCD。</p><p>假设在 C 程序中有 int *a , int n ,如果值 a 在寄存器%ecx 中，n 在%edx<br>中，下面哪个指令计算的是 a[n] ？（ C ）<br>A ret (%ecx,%edx,4)<br>B leal (%ecx,%edx,4),%eax ret<br>C mov (%ecx,%edx,4),%eax ret<br>D mov (%ecx,%edx,1),%eax ret </p><p>int a[i] &#x3D; a + sizeof(int)<em>n，其中int的大小为4，<strong>mov是读取内存中的值，访问内存</strong>，而leal是*<em>计算地址</em></em>，结果存寄存器，不访问内存。<br>leal(%ecx,%edx,4),%eax : 计算地址ecx + 4<em>edx并存入eax中。<br>mov(%ecx,%edx,4),%eax ：计算地址并从*<em>这个地址中读取内容</em></em></p><p>并不是任何十进制小数都可用二进制表示 ，比如0.1（10）标识出来的就是一个无限不循环小数</p><p>下列指令不会改变条件码的值的是(D)<br>A testl %eax,%eax<br>B addl %eax,%eax<br>C cmpl %esi,%dsi<br>D jge .L2<br>test是按位与，add加，cmp比较，都会改变条件码，jg条件跳转。</p><p>下列汇编指令中正确的是（ A ）<br>A movl $0x4050,%eax<br>B movl(%eax),4(%esp)<br>C movl %eax,$0x123<br>D movb $0xF,%ebx<br>我们上课所学的汇编是将左边的传给右边，A将0x4050这个地址传给eax保存，B读取了eax所存放的地址，但是mov指令是要传递给寄存器的，所以应该是movl (%eax),%ebx</p><p>将一个 4 位数值-5 截断到 3 位数的结果为<br>先转为补码，-5的原码为1101，反码为1010，补码为1011，截断成三位数（<strong>舍弃最高位</strong>）称为011，变为3</p><p>将一个<strong>双字节</strong>的内容压入（32位），栈帧-4；</p><p>EAX是一个32位的寄存器，AX用来表示低16位，AH用来表示低16位的高8位，AL用来表示低16位的低8位。</p><p>算数右移（SAR）规则：<strong>保留符号位（最高位）右移其它位，末位丢弃</strong><br>原数： 11001110<br>SAR1： 11100111</p><p>对整数运算z&#x3D;x+y,设置条件码OF的表达式为D (x &lt; 0 &#x3D;&#x3D; y &lt; 0) &amp;&amp; (z &lt; 0 !&#x3D; x &lt; 0)  </p><ul><li>正溢出：x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; z &lt; 0（正溢出）</li><li>负溢出：x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; z &gt;&#x3D; 0（负溢出）</li></ul><p>在补码的加法中发生了负溢出的是<br>C x+y &#x3D; x+y-2^w<br>若 w 位补码中两个负数相加，结果却变成正数 ⇒ 发生负溢出，此时实际数学值超出了补码能表示的负数范围。当加法结果超出这个范围，补码会 回绕（wrap around），造成：负溢出 ⇒ 减去 2^w，正溢出 ⇒ 加上 2^w。</p><p>对整数运算z&#x3D;x+y,设置条件码CF的表达式为：（unsigned）z  &lt; （unsigned）x<br>CF:无符号加减法的进位（无符号溢出）<br>OF:溢出（有符号溢出）<br>SF:运算结果的正负<br>ZF:零标志位</p><p>假设AL&#x3D;5H，要使得AL&#x3D;0FAH，应执行的命令是( )。<br>5H &#x3D; 0000 0101 (二进制)<br>0000 0101  (原始值 AL &#x3D; 0x05)<br>取反后：  1111 1010  (AL &#x3D; 0xFA)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法（一）</title>
      <link href="/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><p>介绍常用的算法</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有三个关键量，right、left、middle；<code>middle = (right - left)&gt;&gt;1</code>，其中<code>&gt;&gt;</code>为右移运算符，将right - left结果的二进制位向右移一位，&gt;&gt;n右移n位，举个例子</p><ul><li>8 - 4 &#x3D; 4，4的二进制位为0100，右移一位变为0010，代表十进制2。</li><li>7 - 2 &#x3D; 5，5的二进制位为0101，右移一位变为0010，代表十进制2。<br>可以看出，右移运算符的作用是<code>将两数相减并向下取整得到结果</code><br>为什么要用右移运算符而不用&#x2F;2？</li><li>右移运算 &gt;&gt; 通常比除法 &#x2F; 更快，因为位运算是底层硬件直接支持的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left)&gt;&gt;<span class="number">1</span>); <span class="comment">//left每一次加上新的中间值</span></span><br><span class="line"><span class="keyword">if</span> (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&lt;target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</strong><br><strong>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</strong><br>采用二分法，注意停止条件，当left&gt;right就停止了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (right&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> p = <span class="number">1.0</span>*middle*middle;</span><br><span class="line">            <span class="keyword">if</span> (p==x) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span> (p&lt;x)&#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311182900217.png"></p><h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><p>滑动窗口类似于双指针，用于去求最短子序列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311202740831.gif"><br>j是终止位置，很像毛毛虫往前拱，吃到了，然后尾巴再上来。<br>LeetCode 209</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum&gt;=target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                x = x &gt; subLength ? subLength : x;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == INT32_MAX? <span class="number">0</span> : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>滑动窗口例题2<br>The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:</p><p>maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4});<br>&#x2F;&#x2F;should be 6: {4, -1, 2, 1}<br>Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</p><p>Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist&#x2F;subarray.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSequence</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, maxSum = <span class="number">0</span>;  <span class="comment">// 初始化最大和为 0（符合题目要求）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; arr.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">        sum += arr[right];  <span class="comment">// 扩展窗口</span></span><br><span class="line">        </span><br><span class="line">        maxSum = std::<span class="built_in">max</span>(maxSum, sum);  <span class="comment">// 更新最大子数组和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前窗口的和变成负数，移动左指针</span></span><br><span class="line">        <span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的一步在while(sum&lt;0),会把之前为负数的窗口给舍弃掉，1 + -3 &#x3D; -2，-2 -1 &#x3D; -3，left左移动一位，-3 -（-3） &#x3D; 0，left左移一位，所以left变成了3；从3又继续开始遍历。</p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>说实话贪心算法并没有固定的套路。<br><strong>所以唯一的难点就是如何通过局部最优，推出整体最优。</strong><br>LeetCode455<a href="https://leetcode.cn/problems/assign-cookies/">分饼干</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g.<span class="built_in">size</span>()==<span class="number">0</span>||s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span> (s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span> (g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;g.<span class="built_in">size</span>()&amp;&amp;j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]&lt;=s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++Practise</title>
      <link href="/2025/03/10/C-Practise/"/>
      <url>/2025/03/10/C-Practise/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="auto：在C-中，auto可以自动推导类型。"><a href="#auto：在C-中，auto可以自动推导类型。" class="headerlink" title="auto：在C++中，auto可以自动推导类型。"></a>auto：在C++中，auto可以自动推导类型。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//有两种方式可以遍历STL容器</span></span><br><span class="line">- <span class="keyword">for</span> (std::vector::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">- <span class="keyword">for</span> (<span class="keyword">auto</span> vtest : v)</span><br></pre></td></tr></table></figure><p>&amp;为引用，加&amp;与否取决于是否要修改原值或避免拷贝</p><ul><li>需要修改并输出修改后的值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v1:v)</span><br><span class="line">&#123;</span><br><span class="line">v1 = v1<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v1:v)</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;v1&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>建议都加std::</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(n,c)</span>  <span class="comment">//可以生成一个包含n个c的字符串。</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::string a.<span class="built_in">find</span>() <span class="comment">//可以找一个你想要东西的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">abbrevName</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[<span class="number">0</span>]);</span><br><span class="line">  s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[name.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)<span class="number">+1</span>]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><p>释放动态的指针，如果释放一个值，就是delete p;如果释放的是一个数组，就是delete []p;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 new 分配一个单个整数</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单个int: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 用 delete 释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 new[] 分配一个整数数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 相当于 int arr[5];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组内容: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 用 delete[] 释放数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="STL——set"><a href="#STL——set" class="headerlink" title="STL——set"></a>STL——set</h3><p>set 有insert，erase，count，find,size等用法，通常用于查找的时候不用find（因为要返回迭代器的值），而是用count，set底层是红黑树，可以实现自动除重，比如insert(6)两次，只会有一个，所以count()的值只会是0和1；用于判断是否存储在里面。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312112552261.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.<span class="built_in">insert</span>();</span><br><span class="line">set.<span class="built_in">erase</span>();</span><br><span class="line">set.<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure><p>unordered_set和set大体上一样，但是是用哈希表实现的，所以里面是无序的，但是查找很快,O(1)级，set的查找是O(logN);</p><p>set插入vector的元素很方便，使用迭代器，同时通过assign分配新值给nums替换旧值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; <span class="built_in">s</span> (nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">nums.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> nums.<span class="built_in">size</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ns = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n!=ns) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>判断前后两次的size是否相同，不同则有重复插入。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一个映射，由Key-&gt;Value，内部是用pair实现。<br>常见的用法有</p><ul><li>m[] &#x3D; ;</li><li>m.erase();</li><li>m.count(); &#x2F;&#x2F;用于查找有没有值，return1&#x2F;0;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312120338656.png"><br>可以看到map也像set一样会自动排序，且后来者会覆盖，count返回的是0和1。</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外层循环a.size()-1次，内层循环a.size()-i-1次;加引用和不加引用的区别在于：<strong>通过引用传递，函数内部对向量的修改会直接反映在原始向量上，这正是冒泡排序需要的效果，即直接在原数组上排序。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[j]&gt;a[j<span class="number">+1</span>])&#123;</span><br><span class="line"><span class="type">int</span> temp = a[j<span class="number">+1</span>];</span><br><span class="line">a[j<span class="number">+1</span>] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一种<strong>数据类型</strong>，在32为系统性size &#x3D; 4，64 &#x3D; 8.指针存放的是内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p>意思是p指针现在存储的是a的地址，可以使用解引用号<em>来访问*<em>p存储的这个地址的值</em></em>。</p><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>const为常量，加在指针前就称之为常量指针 const int *p</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;a;</span><br><span class="line">*p = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p><strong>这是一个非法的操作</strong>，常量指针可以<strong>改变指向的地址</strong>，但<strong>不能改变指向地址的值</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure><p>这是一个合法的操作，现在p指向的就是b的地址。</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure><p>指针常量和常量指针作用刚好相反，要这样理解：<strong>const后面跟着谁谁就无法改变</strong>，在指针常量中，int *const p，const后面跟着的是地址，所以地址就不能改；在常量指针中，const int *p，const后面跟的是int值，所以值不可以改。<br>所以当const int *const p两个都不可以改。快速记忆：遇到英文翻译中文，const int *p,const是常量，后面是指针，所以常量指针;int *const p,先遇到指针，再遇到常量，所以叫指针常量。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用就是取别名，本质是指针，让b的地址和a的地址相同，但记住在这里引用类似于常量指针，不允许再更改成其他的地址了，但可以改值。<strong>引用必须初始化</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure><h3 id="引用不要返回局部变量"><a href="#引用不要返回局部变量" class="headerlink" title="引用不要返回局部变量"></a>引用不要返回局部变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次的时候可以正常输出10，但第二次就不行了，因为局部变量存放在栈区，会被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static关键字让他是静态变量，存放在<strong>全局区</strong>，全局区上的数据在程序结束后释放。</p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类有<strong>属性</strong>和<strong>行为</strong>，比如一个学生类，属性就是学生的名字&#x2F;学生的学号，行为就是打印出名字和学号，也可以用行为来给学生的属性赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">string m_name;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;m_num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员私有化之后可以实现只读&#x2F;只写&#x2F;可读可写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_age = <span class="number">18</span>;</span><br><span class="line">string m_name;</span><br><span class="line">string m_lover;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age&gt;<span class="number">150</span>||age&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">student s;</span><br><span class="line">s.<span class="built_in">set_age</span>(<span class="number">160</span>);</span><br><span class="line">s.<span class="built_in">get_age</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>圆类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setm_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getm_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setm_y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getm_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_x;</span><br><span class="line"><span class="type">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setm_r</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_r = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getm_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setm_center</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_center = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">point <span class="title">getm_center</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_r;</span><br><span class="line">point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Relation</span><span class="params">(circle &amp;c,point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dx = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_x</span>()-p.<span class="built_in">getm_x</span>();</span><br><span class="line"><span class="type">int</span> dy = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_y</span>()-p.<span class="built_in">getm_y</span>();</span><br><span class="line">cout&lt;&lt;dx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dy;</span><br><span class="line"><span class="type">int</span> rdistance = c.<span class="built_in">getm_r</span>()*c.<span class="built_in">getm_r</span>();</span><br><span class="line"><span class="type">int</span> distance = dx*dx+dy*dy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (distance==rdistance)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;在圆上&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(distance&gt;rdistance)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;在圆外&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;在圆内&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">point p;</span><br><span class="line">circle c;</span><br><span class="line">c.<span class="built_in">setm_r</span>(<span class="number">10</span>);</span><br><span class="line">point center;</span><br><span class="line">center.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">center.<span class="built_in">setm_y</span>(<span class="number">0</span>);</span><br><span class="line">c.<span class="built_in">setm_center</span>(center); </span><br><span class="line"></span><br><span class="line">p.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">p.<span class="built_in">setm_y</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Relation</span>(c,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>没有返回值，不用写void，函数名与类名相同，构造函数可以有参数，可以发生重载，创建对象的时候会自动调用，而且只调用一次。<br>析构函数前加一个~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;构造&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;析构&quot;</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">person p;</span><br><span class="line">person p1;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以省略冗余的代码，继承父类。<br>继承语法： class 子类 : 继承方式 父类<br>class cpp : public header<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183703034.png">;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183742270.png">;<br>子类可以缩小权限范围，但不能扩大权限范围。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321191947414.png"></p><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>类初始化在构造函数后面打一个冒号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这一行代码等价于下面这一行代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xx, <span class="type">int</span> yy)</span><br><span class="line">        &#123;</span><br><span class="line">            x = xx;</span><br><span class="line">            y = yy;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Constructor of Point&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是区别不同<br>上面两段代码对应于初始化类成员的两种方式：(1)使用初始化列表；(2)在构造函数体内进行赋值操作。<br>但严格来说，上面两段代码只是能实现相同的功能(初始化Point类的对象)，它们的本质并不相同，下面来说明原因。<br>构造函数的执行分为两个阶段：<br>(1)执行初始化列表：初始化类中的数据成员；<br>(2)执行构造函数体：一般是对类中的数据成员进行赋值操作。<br>初始化与赋值是不同的，所以上面两段代码只是功能上相同，但本质并不相同，前一个是初始化，后一个是赋值。</p><h2 id="STL–deque"><a href="#STL–deque" class="headerlink" title="STL–deque"></a>STL–deque</h2><p>deque（double ended queue）双端队列 好处：<strong>两端都开口</strong>，想要在头部插入元素很方便。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402104311358.png"></p><h3 id="有四种拷贝构造"><a href="#有四种拷贝构造" class="headerlink" title="有四种拷贝构造"></a>有四种拷贝构造</h3><ul><li>deque<T>deqT <strong>默认构造</strong></T></li><li>deque<T>d1(d); <strong>拷贝构造</strong></T></li><li>deque<T>d2(d.begin(),d.end()) 把[begin,end)区间的元素给d2</T></li><li>deque<T>d3(10,100) &#x2F;&#x2F;10个100 将n个elem拷贝给自身</T></li></ul><h3 id="有三种赋值"><a href="#有三种赋值" class="headerlink" title="有三种赋值"></a>有三种赋值</h3><ul><li>deque<int> d &#x3D; d1 等号赋值</int></li><li>deque<int> d3; d3.assign(d1.begin(),d1.end()) </int></li><li>d3.assign(10,100) 给10个100<br>和vector一样。</li></ul><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>函数原型：<br>deque.empty(); &#x2F;&#x2F;判断容器是否为空<br>deque.size(); &#x2F;&#x2F;返回容器中元素的个数<br>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。<br>deque.resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>两端插入操作：<br>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据<br>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据<br>pop_back(); &#x2F;&#x2F;删除容器最后一个数据<br>pop_front(); &#x2F;&#x2F;删除容器第一个数据<br>指定位置操作：<br>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。<br>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。<br>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg，end)区间的数据，无返回值。<br>clear();&#x2F;&#x2F;清空容器的所有数据<br>erase(beg,end); &#x2F;&#x2F;删除[beg，end)区间的数据，返回下一个数据的位置。<br>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>sort(d.begin(),d.end())</p><h2 id="STL–queue"><a href="#STL–queue" class="headerlink" title="STL–queue"></a>STL–queue</h2><p>先进先出，很像尾插法。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402113216514.png"><br><strong>不允许遍历！只能访问队头队尾！</strong><br>入队：q.push() 出队：q.pop()<br>基本操作<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402113412632.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_int_int&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_double_double&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* //strcmp会逐个比较</span></span><br><span class="line"><span class="comment">const char* a = &quot;apple&quot;;</span></span><br><span class="line"><span class="comment">const char* b = &quot;apricot&quot;;</span></span><br><span class="line"><span class="comment">strcmp(a, b); // 比较 &#x27;a&#x27; vs &#x27;a&#x27; → &#x27;p&#x27; vs &#x27;p&#x27; → &#x27;p&#x27; vs &#x27;r&#x27; → 返回负数（&#x27;p&#x27; &lt; &#x27;r&#x27;）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* a = <span class="string">&quot;hello&quot;</span>; <span class="comment">//在内存中是&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;，a是一个指针，指向&#x27;h&#x27;的地址。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b)</span> <span class="comment">//const char* a 是一个指针，指向一个字符串的起始地址，字符串本质上是以 \0 结尾的 char 数组。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;compare_char*_char*&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.0</span>, <span class="number">20.0</span>);</span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Thread2</title>
      <link href="/2025/03/09/Thread2/"/>
      <url>/2025/03/09/Thread2/</url>
      
        <content type="html"><![CDATA[<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><h2 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h2><p>当多线程去共享同一个数据的时候，会造成争夺</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码发现，a的值没有如我们预期所认为是20000，而是随机的数字。这是因为线程在读取同一个数据的时候发生了争夺。<br>解决办法：当一个线程拿了数据，其他线程禁止拿，也就是互斥锁：线程访问共享资源前，先<strong>加锁</strong>（lock），用完后<strong>解锁</strong>（unlock）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>(); <span class="comment">//在这个线程即将访问数据的时候上锁</span></span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//在访问完成后解锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多线程安全：如果多线程程序每一次的运行结果和单线程运行的结果是一样的，那么你的线程就是安全的。</strong></p><h2 id="互斥量死锁"><a href="#互斥量死锁" class="headerlink" title="互斥量死锁"></a>互斥量死锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">m<span class="number">1.l</span>ock();</span><br><span class="line">m<span class="number">2.l</span>ock();</span><br><span class="line">m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">m<span class="number">2.l</span>ock();</span><br><span class="line">m<span class="number">1.l</span>ock();</span><br><span class="line">m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;over&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方法，当某个线程获取到了m1，那就让他获取m2，按照这样的规则，所有的线程都得先有m1才有m2，那其他线程拿不到m1自然也拿不到m2，所以调换func_2的m1、m2顺序即可。</p><h2 id="lock-guard与unique-lock"><a href="#lock-guard与unique-lock" class="headerlink" title="lock_guard与unique_lock"></a>lock_guard与unique_lock</h2><p>std::lock_guard是C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p><ul><li>当构造函数被调用时，该互斥量会被<code>自动锁定</code></li><li>当析构函数被调用时，该互斥量会被<code>自动解锁</code></li><li>std::lock_guard对象不能复制或移动，因此它<code>只能在局部作用域中使用</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">std::lock_guard&lt;std::mutex&gt;<span class="built_in">lg</span>(mtx);</span><br><span class="line">shared_data++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock_guard<mutex>lg(mtx)的作用就相当于mtx.lock() 且 mtx.unlock().<br>有五个用法：</mutex></p><h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="手动解锁"><a href="#手动解锁" class="headerlink" title="手动解锁"></a>手动解锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 提前解锁</span></span><br><span class="line">    <span class="comment">// 此处不再受互斥锁保护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="延迟加锁"><a href="#延迟加锁" class="headerlink" title="延迟加锁"></a>延迟加锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;  <span class="comment">// 不自动加锁</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();  <span class="comment">// 需要时再手动加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="尝试加锁"><a href="#尝试加锁" class="headerlink" title="尝试加锁"></a>尝试加锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;  <span class="comment">// 判断是否加锁成功</span></span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 锁未获取成功，执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁转移"><a href="#互斥锁转移" class="headerlink" title="互斥锁转移"></a>互斥锁转移</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx)</span></span>;  <span class="comment">// 获取锁</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock2 = std::<span class="built_in">move</span>(lock1);  <span class="comment">// lock1 转移给 lock2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311104759163.png" alt="生产者与消费者"><br>生产者与消费者模型可以这样比喻：生产者是小鸡，任务队列是鸡蛋篮子，消费者是饲养员。有源源不断的任务从生产者发出，由消费者解除，也类似于银行排队系统。<br>当任务队列为<strong>空</strong>的时候，消费者无法去取任务，因此会进入<strong>等待</strong>的状态。那此时老板会下发任务，如何让消费者知道有任务？需要<strong>通知</strong>，让消费者知道我该往里面取任务了。<br>condition_variable有两种</p><ul><li>notify_one 唤醒消费者中的<em>一个线程</em>来干活</li><li>notify-all 唤醒消费者中的<em>所有线程</em>来干活<br><strong>区别在于：通知只发一次，但是对象不同，唤醒一条线程和所有线程的区别</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt;g_queue;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">g_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">g_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait函数g_cv.wait(lock, predicate)的作用：</p><ul><li>当前线程进入等待状态，直到 predicate 返回 true，也就是说第二个判断条件是true就往下执行</li><li>lock 是一个 std::unique_lock<a href="std::mutex">std::mutex</a>，用于保护临界区资源。</li><li>predicate 是一个 Lambda 表达式，返回 true 时线程继续执行，否则会一直等待。<br>两个代码是等价的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!g_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 条件不满足，释放 lock 并进入等待状态</span></span><br><span class="line">    g_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条件满足，继续执行后续代码</span></span><br></pre></td></tr></table></figure><ul><li>当 g_queue 为空时，线程会阻塞（等待）。</li><li>当 g_queue 非空时，线程继续执行，不会进入等待状态。</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>除了可以用互斥锁来维护共享变量外，还可以通过原子操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">std::atomic &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">a += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在初始化的时候，不允许使用<code>std::atomic&lt;int&gt; a = 0</code>，因为原子操作不允许拷贝复制，应该用默认的构造函数<code>std::atomic&lt;int&gt; a(0)或std::atomic&lt;int&gt; a&#123;0&#125;</code><br>把共享的数据设置为原子变量，更好地维护线程安全，还可以提升运行速度。</p><p>小班演示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_queue;  <span class="comment">//容器要包含类型</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">g_cv.<span class="built_in">notify_one</span>();  <span class="comment">//每次加任务的时候通知一下</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">&#125;);</span><br><span class="line">flag++;</span><br><span class="line"><span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">g_queue.<span class="built_in">pop</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Comsumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(Comsumer)</span></span>;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-11跨平台线程池"><a href="#C-11跨平台线程池" class="headerlink" title="C++11跨平台线程池"></a>C++11跨平台线程池</h1>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread</title>
      <link href="/2025/03/09/Thread/"/>
      <url>/2025/03/09/Thread/</url>
      
        <content type="html"><![CDATA[<h1 id="C-11多线程编程"><a href="#C-11多线程编程" class="headerlink" title="C++11多线程编程"></a>C++11多线程编程</h1><hr><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul><li>进程就是正在运行的程序</li><li>线程就是进程中的进程</li><li>多线程可以提高效率。</li><li>线程的多少取决于CPU的<strong>核数</strong><br>如下图，如果是串行的话就必须顺序执行，但如果并行的话你就可以在同一时间内干多个事情。但同时要注意你的“<strong>核数</strong>”，你不能同时刷抖音和听音乐，因为你没有四个耳朵，亦或者说你的手机同一时间内只能处理一个应用播放声音。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread1.png" alt="图片"></li></ul><h1 id="C-11-Thread"><a href="#C-11-Thread" class="headerlink" title="C++11 Thread"></a>C++11 Thread</h1><ul><li>准备工具 Visual Studio</li><li>线程库 thread</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="使用thread创建一个线程"><a href="#使用thread创建一个线程" class="headerlink" title="使用thread创建一个线程"></a>使用thread创建一个线程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HelloWorld&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行调试后，会得到下面结果：<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread2.png" alt="图片"><br>我们发现报错了，为什么会这样呢？</p><hr><p>可以理解为main里是<strong>主线程</strong>，一开始我们便创建了一个<strong>子线程</strong>，并让其执行PrintHelloWorld的函数。当<strong>子线程</strong>没有执行完毕的时候，主线程已执行完毕。<strong>主线程不会等待子线程执行完毕</strong>，可能子线程才执行到Hello，主程序已经return 0了，所以出现报错；<strong>所以说主线程和子线程是并发运行的！</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;HelloworldMain&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>当我们再次加入一行代码时发现，先输出的是<strong>主线程</strong>的HelloworldMain,接下来才是<strong>子线程</strong>的Helloworld。从这里我们可以看出：<strong>创建线程是需要时间的</strong>。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread3.png" alt="图片"></p><h2 id="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"><a href="#如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？" class="headerlink" title="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"></a>如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？</h2><h3 id="函数thread-join"><a href="#函数thread-join" class="headerlink" title="函数thread.join()"></a><strong>函数thread.join()</strong></h3><p>在 C++ 中，std::thread::join() 的作用是 等待<strong>子线程执行完毕</strong>，然后<strong>主线程才继续执行</strong>。如果没有 join()，主线程可能会在子线程执行完成之前就结束，导致未定义行为程序报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworldMain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当我们添加了thread1.join()之后，相当于告诉主线程：“大哥你先等我弄完你再往下走，别丢下我！” （<strong>演示注释掉thread1.join()的情况</strong>）<br>join的作用是：<strong>确保子线程完成</strong>，执行顺序可控，但是会<strong>阻塞</strong>主线程，直到子线程完成。<br>阻塞示例 （joinable()用于判断线程是否可以使用join函数，返回的是一个bool值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">std::cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(print)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (thread<span class="number">1.</span><span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;over&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数thread-detach"><a href="#函数thread-detach" class="headerlink" title="函数thread.detach()"></a><strong>函数thread.detach()</strong></h3><p>让子线程“脱离”主线程，主线程不再管理它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>你可以干你的事情，我也可以干我的事情，不管你了。像请客吃饭，请客的人把单买了之后说我先走一步，你们随意。对比上面的阻塞，我们发现detach是<strong>并发</strong>的。</p>]]></content>
      
      
      <categories>
          
          <category> c++多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章！</title>
      <link href="/2025/03/08/FirstBlog/"/>
      <url>/2025/03/08/FirstBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><ul><li><strong>运算器</strong>进行信息处理；</li><li><strong>寄存器</strong>进行信息存储；</li><li><strong>控制器</strong>协调各种器件进行工作；</li><li><strong>内部总线</strong>实现CPU内各个器件之间的联系。</li></ul><div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"1.png","alt":"img","title":""}]</div>  </div><h2 id="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"><a href="#8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？" class="headerlink" title="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"></a>8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？</h2><p>把16位寄存器分成<strong>AH</strong>和<strong>AL</strong>两个独立的8位寄存器使用；<br>同样，32位或64位的寄存器也可以分，从而实现兼容性。<br>比如AX中现在存储0101010110101010，可以分为AH<strong>01010101</strong>和AL<strong>10101010</strong>来存储</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="汇编指令-控制CPU完成的操作"><a href="#汇编指令-控制CPU完成的操作" class="headerlink" title="汇编指令                控制CPU完成的操作"></a>汇编指令                控制CPU完成的操作</h3><ul><li>mov ax,18                  将18送入AX</li><li>mov ah,78                  将78送入AH</li><li>add ax,8                   将AX中的值和8相加并把值存入AX</li><li>mov ax,bx                  将BX中的值赋值给AX</li><li>add ax,bx                  将AX和BX中的内容相加并把值存于AX<br><strong>注意：汇编指令不区分大小写，MOV也行</strong></li></ul><div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"2.png","alt":"img","title":""}]</div>  </div><p>在进行低八位运算的时候，比如最后一行85+93，结果等于158，但发生了溢出，只能显示58，1舍弃而不是进位到高位。</p><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在存储空间中都有唯一的位置。8086CPU有20位地址总线，可传送20位地址，寻址能力为1MB（2的20次方）。8086是<strong>16位</strong>的CPU，16位地址表示的是地址总线的宽度，即CPU可以直接访问的地址范围。如果地址总线是16位，那么可表示的地址数量为2的十六次方&#x3D;65536个字节（即 64KB）。这意味着 CPU 最多只能寻址 64KB 的内存空间。<br>使用地址加法器将两个16位地址合成一个20位的物理地址。一个叫做<strong>段地址</strong>，另一个叫做<strong>偏移地址</strong>。<br><strong>段地址✖16 + 偏移地址 &#x3D; 物理地址，也称之为左移四位（二进制中），在十六进制里左移1位即可。</strong><br>最后得到的20位物理地址被地址总线传送到存储器里。<br>描述存储单元的方法（物理地址为21F60H，段地址为2000H，则偏移地址为1F60H）</p><ul><li>数据存放在内存2000：1F60单元中</li><li>数据存放在内存的2000段中的1F60H中</li></ul><div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">    <div class="gallery-items">[{"url":"3.png","alt":"img","title":""}]</div>  </div>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
