<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章！</title>
    <url>/2025/03/08/FirstBlog/</url>
    <content><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><ul>
<li><strong>运算器</strong>进行信息处理；</li>
<li><strong>寄存器</strong>进行信息存储；</li>
<li><strong>控制器</strong>协调各种器件进行工作；</li>
<li><strong>内部总线</strong>实现CPU内各个器件之间的联系。</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"1.png","alt":"img","title":""}]</div>
  </div>
<h2 id="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"><a href="#8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？" class="headerlink" title="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"></a>8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？</h2><p>把16位寄存器分成<strong>AH</strong>和<strong>AL</strong>两个独立的8位寄存器使用；<br>同样，32位或64位的寄存器也可以分，从而实现兼容性。<br>比如AX中现在存储0101010110101010，可以分为AH<strong>01010101</strong>和AL<strong>10101010</strong>来存储</p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="汇编指令-控制CPU完成的操作"><a href="#汇编指令-控制CPU完成的操作" class="headerlink" title="汇编指令                控制CPU完成的操作"></a>汇编指令                控制CPU完成的操作</h3><ul>
<li>mov ax,18                  将18送入AX</li>
<li>mov ah,78                  将78送入AH</li>
<li>add ax,8                   将AX中的值和8相加并把值存入AX</li>
<li>mov ax,bx                  将BX中的值赋值给AX</li>
<li>add ax,bx                  将AX和BX中的内容相加并把值存于AX<br><strong>注意：汇编指令不区分大小写，MOV也行</strong></li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"2.png","alt":"img","title":""}]</div>
  </div>
<p>在进行低八位运算的时候，比如最后一行85+93，结果等于158，但发生了溢出，只能显示58，1舍弃而不是进位到高位。</p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在存储空间中都有唯一的位置。8086CPU有20位地址总线，可传送20位地址，寻址能力为1MB（2的20次方）。8086是<strong>16位</strong>的CPU，16位地址表示的是地址总线的宽度，即CPU可以直接访问的地址范围。如果地址总线是16位，那么可表示的地址数量为2的十六次方&#x3D;65536个字节（即 64KB）。这意味着 CPU 最多只能寻址 64KB 的内存空间。<br>使用地址加法器将两个16位地址合成一个20位的物理地址。一个叫做<strong>段地址</strong>，另一个叫做<strong>偏移地址</strong>。<br><strong>段地址✖16 + 偏移地址 &#x3D; 物理地址，也称之为左移四位（二进制中），在十六进制里左移1位即可。</strong><br>最后得到的20位物理地址被地址总线传送到存储器里。<br>描述存储单元的方法（物理地址为21F60H，段地址为2000H，则偏移地址为1F60H）</p>
<ul>
<li>数据存放在内存2000：1F60单元中</li>
<li>数据存放在内存的2000段中的1F60H中</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"3.png","alt":"img","title":""}]</div>
  </div>]]></content>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2025/03/09/Thread/</url>
    <content><![CDATA[<h1 id="C-11多线程编程"><a href="#C-11多线程编程" class="headerlink" title="C++11多线程编程"></a>C++11多线程编程</h1><hr>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程就是正在运行的程序</li>
<li>线程就是进程中的进程</li>
<li>多线程可以提高效率。</li>
<li>线程的多少取决于CPU的<strong>核数</strong><br>如下图，如果是串行的话就必须顺序执行，但如果并行的话你就可以在同一时间内干多个事情。但同时要注意你的“<strong>核数</strong>”，你不能同时刷抖音和听音乐，因为你没有四个耳朵，亦或者说你的手机同一时间内只能处理一个应用播放声音。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread1.png" alt="图片"></li>
</ul>
<h1 id="C-11-Thread"><a href="#C-11-Thread" class="headerlink" title="C++11 Thread"></a>C++11 Thread</h1><ul>
<li>准备工具 Visual Studio</li>
<li>线程库 thread</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用thread创建一个线程"><a href="#使用thread创建一个线程" class="headerlink" title="使用thread创建一个线程"></a>使用thread创建一个线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HelloWorld&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行调试后，会得到下面结果：<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread2.png" alt="图片"><br>我们发现报错了，为什么会这样呢？</p>
<hr>
<p>可以理解为main里是<strong>主线程</strong>，一开始我们便创建了一个<strong>子线程</strong>，并让其执行PrintHelloWorld的函数。当<strong>子线程</strong>没有执行完毕的时候，主线程已执行完毕。<strong>主线程不会等待子线程执行完毕</strong>，可能子线程才执行到Hello，主程序已经return 0了，所以出现报错；<strong>所以说主线程和子线程是并发运行的！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;HelloworldMain&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
<p>当我们再次加入一行代码时发现，先输出的是<strong>主线程</strong>的HelloworldMain,接下来才是<strong>子线程</strong>的Helloworld。从这里我们可以看出：<strong>创建线程是需要时间的</strong>。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread3.png" alt="图片"></p>
<h2 id="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"><a href="#如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？" class="headerlink" title="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"></a>如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？</h2><h3 id="函数thread-join"><a href="#函数thread-join" class="headerlink" title="函数thread.join()"></a><strong>函数thread.join()</strong></h3><p>在 C++ 中，std::thread::join() 的作用是 等待<strong>子线程执行完毕</strong>，然后<strong>主线程才继续执行</strong>。如果没有 join()，主线程可能会在子线程执行完成之前就结束，导致未定义行为程序报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworldMain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当我们添加了thread1.join()之后，相当于告诉主线程：“大哥你先等我弄完你再往下走，别丢下我！” （<strong>演示注释掉thread1.join()的情况</strong>）<br>join的作用是：<strong>确保子线程完成</strong>，执行顺序可控，但是会<strong>阻塞</strong>主线程，直到子线程完成。<br>阻塞示例 （joinable()用于判断线程是否可以使用join函数，返回的是一个bool值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread1</span><span class="params">(print)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (thread<span class="number">1.</span><span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数thread-detach"><a href="#函数thread-detach" class="headerlink" title="函数thread.detach()"></a><strong>函数thread.detach()</strong></h3><p>让子线程“脱离”主线程，主线程不再管理它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>你可以干你的事情，我也可以干我的事情，不管你了。像请客吃饭，请客的人把单买了之后说我先走一步，你们随意。对比上面的阻塞，我们发现detach是<strong>并发</strong>的。</p>
]]></content>
      <categories>
        <category>c++多线程</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread2</title>
    <url>/2025/03/09/Thread2/</url>
    <content><![CDATA[<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><h2 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h2><p>当多线程去共享同一个数据的时候，会造成争夺</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码发现，a的值没有如我们预期所认为是20000，而是随机的数字。这是因为线程在读取同一个数据的时候发生了争夺。<br>解决办法：当一个线程拿了数据，其他线程禁止拿，也就是互斥锁：线程访问共享资源前，先<strong>加锁</strong>（lock），用完后<strong>解锁</strong>（unlock）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>(); <span class="comment">//在这个线程即将访问数据的时候上锁</span></span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//在访问完成后解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多线程安全：如果多线程程序每一次的运行结果和单线程运行的结果是一样的，那么你的线程就是安全的。</strong></p>
<h2 id="互斥量死锁"><a href="#互斥量死锁" class="headerlink" title="互斥量死锁"></a>互斥量死锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法，当某个线程获取到了m1，那就让他获取m2，按照这样的规则，所有的线程都得先有m1才有m2，那其他线程拿不到m1自然也拿不到m2，所以调换func_2的m1、m2顺序即可。</p>
<h2 id="lock-guard与unique-lock"><a href="#lock-guard与unique-lock" class="headerlink" title="lock_guard与unique_lock"></a>lock_guard与unique_lock</h2><p>std::lock_guard是C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p>
<ul>
<li>当构造函数被调用时，该互斥量会被<code>自动锁定</code></li>
<li>当析构函数被调用时，该互斥量会被<code>自动解锁</code></li>
<li>std::lock_guard对象不能复制或移动，因此它<code>只能在局部作用域中使用</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lg</span>(mtx);</span><br><span class="line">		shared_data++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock_guard<mutex>lg(mtx)的作用就相当于mtx.lock() 且 mtx.unlock().<br>有五个用法：</mutex></p>
<h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="手动解锁"><a href="#手动解锁" class="headerlink" title="手动解锁"></a>手动解锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 提前解锁</span></span><br><span class="line">    <span class="comment">// 此处不再受互斥锁保护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="延迟加锁"><a href="#延迟加锁" class="headerlink" title="延迟加锁"></a>延迟加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;  <span class="comment">// 不自动加锁</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();  <span class="comment">// 需要时再手动加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="尝试加锁"><a href="#尝试加锁" class="headerlink" title="尝试加锁"></a>尝试加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;  <span class="comment">// 判断是否加锁成功</span></span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 锁未获取成功，执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁转移"><a href="#互斥锁转移" class="headerlink" title="互斥锁转移"></a>互斥锁转移</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx)</span></span>;  <span class="comment">// 获取锁</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock2 = std::<span class="built_in">move</span>(lock1);  <span class="comment">// lock1 转移给 lock2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311104759163.png" alt="生产者与消费者"><br>生产者与消费者模型可以这样比喻：生产者是小鸡，任务队列是鸡蛋篮子，消费者是饲养员。有源源不断的任务从生产者发出，由消费者解除，也类似于银行排队系统。<br>当任务队列为<strong>空</strong>的时候，消费者无法去取任务，因此会进入<strong>等待</strong>的状态。那此时老板会下发任务，如何让消费者知道有任务？需要<strong>通知</strong>，让消费者知道我该往里面取任务了。<br>condition_variable有两种</p>
<ul>
<li>notify_one 唤醒消费者中的<em>一个线程</em>来干活</li>
<li>notify-all 唤醒消费者中的<em>所有线程</em>来干活<br><strong>区别在于：通知只发一次，但是对象不同，唤醒一条线程和所有线程的区别</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt;g_queue;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait函数g_cv.wait(lock, predicate)的作用：</p>
<ul>
<li>当前线程进入等待状态，直到 predicate 返回 true，也就是说第二个判断条件是true就往下执行</li>
<li>lock 是一个 std::unique_lock<a href="std::mutex">std::mutex</a>，用于保护临界区资源。</li>
<li>predicate 是一个 Lambda 表达式，返回 true 时线程继续执行，否则会一直等待。<br>两个代码是等价的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!g_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 条件不满足，释放 lock 并进入等待状态</span></span><br><span class="line">    g_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条件满足，继续执行后续代码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 g_queue 为空时，线程会阻塞（等待）。</li>
<li>当 g_queue 非空时，线程继续执行，不会进入等待状态。</li>
</ul>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>除了可以用互斥锁来维护共享变量外，还可以通过原子操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">std::atomic &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在初始化的时候，不允许使用<code>std::atomic&lt;int&gt; a = 0</code>，因为原子操作不允许拷贝复制，应该用默认的构造函数<code>std::atomic&lt;int&gt; a(0)或std::atomic&lt;int&gt; a&#123;0&#125;</code><br>把共享的数据设置为原子变量，更好地维护线程安全，还可以提升运行速度。</p>
<p>小班演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_queue;  <span class="comment">//容器要包含类型</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();  <span class="comment">//每次加任务的时候通知一下</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		flag++;</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Comsumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Comsumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11跨平台线程池"><a href="#C-11跨平台线程池" class="headerlink" title="C++11跨平台线程池"></a>C++11跨平台线程池</h1>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Practise</title>
    <url>/2025/03/10/C-Practise/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="auto：在C-中，auto可以自动推导类型。"><a href="#auto：在C-中，auto可以自动推导类型。" class="headerlink" title="auto：在C++中，auto可以自动推导类型。"></a>auto：在C++中，auto可以自动推导类型。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//有两种方式可以遍历STL容器</span></span><br><span class="line">- <span class="keyword">for</span> (std::vector::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">- <span class="keyword">for</span> (<span class="keyword">auto</span> vtest : v)</span><br></pre></td></tr></table></figure>
<p>&amp;为引用，加&amp;与否取决于是否要修改原值或避免拷贝</p>
<ul>
<li>需要修改并输出修改后的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 = v1<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;v1&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>建议都加std::</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(n,c)</span>  <span class="comment">//可以生成一个包含n个c的字符串。</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string a.<span class="built_in">find</span>() <span class="comment">//可以找一个你想要东西的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">abbrevName</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[<span class="number">0</span>]);</span><br><span class="line">  s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[name.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)<span class="number">+1</span>]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h3><p>释放动态的指针，如果释放一个值，就是delete p;如果释放的是一个数组，就是delete []p;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 new 分配一个单个整数</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;单个int: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 用 delete 释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 new[] 分配一个整数数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 相当于 int arr[5];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        arr[i] = i * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;数组内容: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">// 用 delete[] 释放数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="STL——set"><a href="#STL——set" class="headerlink" title="STL——set"></a>STL——set</h3><p>set 有insert，erase，count，find,size等用法，通常用于查找的时候不用find（因为要返回迭代器的值），而是用count，set底层是红黑树，可以实现自动除重，比如insert(6)两次，只会有一个，所以count()的值只会是0和1；用于判断是否存储在里面。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312112552261.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">insert</span>();</span><br><span class="line">set.<span class="built_in">erase</span>();</span><br><span class="line">set.<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure>
<p>unordered_set和set大体上一样，但是是用哈希表实现的，所以里面是无序的，但是查找很快,O(1)级，set的查找是O(logN);</p>
<p>set插入vector的元素很方便，使用迭代器，同时通过assign分配新值给nums替换旧值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; <span class="built_in">s</span> (nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">		nums.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">return</span> nums.<span class="built_in">size</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ns = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n!=ns) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>判断前后两次的size是否相同，不同则有重复插入。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一个映射，由Key-&gt;Value，内部是用pair实现。<br>常见的用法有</p>
<ul>
<li>m[] &#x3D; ;</li>
<li>m.erase();</li>
<li>m.count(); &#x2F;&#x2F;用于查找有没有值，return1&#x2F;0;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312120338656.png"><br>可以看到map也像set一样会自动排序，且后来者会覆盖，count返回的是0和1。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外层循环a.size()-1次，内层循环a.size()-i-1次;加引用和不加引用的区别在于：<strong>通过引用传递，函数内部对向量的修改会直接反映在原始向量上，这正是冒泡排序需要的效果，即直接在原数组上排序。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;a[j<span class="number">+1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[j<span class="number">+1</span>];</span><br><span class="line">				a[j<span class="number">+1</span>] = a[j];</span><br><span class="line">				a[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一种<strong>数据类型</strong>，在32为系统性size &#x3D; 4，64 &#x3D; 8.指针存放的是内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>意思是p指针现在存储的是a的地址，可以使用解引用号<em>来访问*<em>p存储的这个地址的值</em></em>。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>const为常量，加在指针前就称之为常量指针 const int *p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;a;</span><br><span class="line">*p = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p><strong>这是一个非法的操作</strong>，常量指针可以<strong>改变指向的地址</strong>，但<strong>不能改变指向地址的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>
<p>这是一个合法的操作，现在p指向的就是b的地址。</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>指针常量和常量指针作用刚好相反，要这样理解：<strong>const后面跟着谁谁就无法改变</strong>，在指针常量中，int *const p，const后面跟着的是地址，所以地址就不能改；在常量指针中，const int *p，const后面跟的是int值，所以值不可以改。<br>所以当const int *const p两个都不可以改。快速记忆：遇到英文翻译中文，const int *p,const是常量，后面是指针，所以常量指针;int *const p,先遇到指针，再遇到常量，所以叫指针常量。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用就是取别名，本质是指针，让b的地址和a的地址相同，但记住在这里引用类似于常量指针，不允许再更改成其他的地址了，但可以改值。<strong>引用必须初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>
<h3 id="引用不要返回局部变量"><a href="#引用不要返回局部变量" class="headerlink" title="引用不要返回局部变量"></a>引用不要返回局部变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次的时候可以正常输出10，但第二次就不行了，因为局部变量存放在栈区，会被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static关键字让他是静态变量，存放在<strong>全局区</strong>，全局区上的数据在程序结束后释放。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类有<strong>属性</strong>和<strong>行为</strong>，比如一个学生类，属性就是学生的名字&#x2F;学生的学号，行为就是打印出名字和学号，也可以用行为来给学生的属性赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_num;</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;m_num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员私有化之后可以实现只读&#x2F;只写&#x2F;可读可写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_age = <span class="number">18</span>;</span><br><span class="line">		string m_name;</span><br><span class="line">		string m_lover;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (age&gt;<span class="number">150</span>||age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m_age = age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student s;</span><br><span class="line">	s.<span class="built_in">set_age</span>(<span class="number">160</span>);</span><br><span class="line">	s.<span class="built_in">get_age</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_x = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_y = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_y;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_x;</span><br><span class="line">		<span class="type">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_r</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_r = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_center</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_center = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">point <span class="title">getm_center</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_center;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_r;</span><br><span class="line">		point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Relation</span><span class="params">(circle &amp;c,point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dx = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_x</span>()-p.<span class="built_in">getm_x</span>();</span><br><span class="line">	<span class="type">int</span> dy = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_y</span>()-p.<span class="built_in">getm_y</span>();</span><br><span class="line">	cout&lt;&lt;dx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dy;</span><br><span class="line">	<span class="type">int</span> rdistance = c.<span class="built_in">getm_r</span>()*c.<span class="built_in">getm_r</span>();</span><br><span class="line">	<span class="type">int</span> distance = dx*dx+dy*dy;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (distance==rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆上&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(distance&gt;rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆外&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;在圆内&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	point p;</span><br><span class="line">	circle c;</span><br><span class="line">	c.<span class="built_in">setm_r</span>(<span class="number">10</span>);</span><br><span class="line">	point center;</span><br><span class="line">	center.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	center.<span class="built_in">setm_y</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">setm_center</span>(center); </span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	p.<span class="built_in">setm_y</span>(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Relation</span>(c,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>没有返回值，不用写void，函数名与类名相同，构造函数可以有参数，可以发生重载，创建对象的时候会自动调用，而且只调用一次。<br>析构函数前加一个~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;构造&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;析构&quot;</span>;</span><br><span class="line">	 &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	person p1;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以省略冗余的代码，继承父类。<br>继承语法： class 子类 : 继承方式 父类<br>class cpp : public header<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183703034.png">;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183742270.png">;<br>子类可以缩小权限范围，但不能扩大权限范围。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321191947414.png"></p>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>类初始化在构造函数后面打一个冒号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这一行代码等价于下面这一行代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Point</span>(<span class="type">int</span> xx, <span class="type">int</span> yy)</span><br><span class="line">        &#123;</span><br><span class="line">            x = xx;</span><br><span class="line">            y = yy;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Constructor of Point&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是区别不同<br>上面两段代码对应于初始化类成员的两种方式：(1)使用初始化列表；(2)在构造函数体内进行赋值操作。<br>但严格来说，上面两段代码只是能实现相同的功能(初始化Point类的对象)，它们的本质并不相同，下面来说明原因。<br>构造函数的执行分为两个阶段：<br>(1)执行初始化列表：初始化类中的数据成员；<br>(2)执行构造函数体：一般是对类中的数据成员进行赋值操作。<br>初始化与赋值是不同的，所以上面两段代码只是功能上相同，但本质并不相同，前一个是初始化，后一个是赋值。</p>
<h2 id="STL–deque"><a href="#STL–deque" class="headerlink" title="STL–deque"></a>STL–deque</h2><p>deque（double ended queue）双端队列 好处：<strong>两端都开口</strong>，想要在头部插入元素很方便。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402104311358.png"></p>
<h3 id="有四种拷贝构造"><a href="#有四种拷贝构造" class="headerlink" title="有四种拷贝构造"></a>有四种拷贝构造</h3><ul>
<li>deque<T>deqT <strong>默认构造</strong></T></li>
<li>deque<T>d1(d); <strong>拷贝构造</strong></T></li>
<li>deque<T>d2(d.begin(),d.end()) 把[begin,end)区间的元素给d2</T></li>
<li>deque<T>d3(10,100) &#x2F;&#x2F;10个100 将n个elem拷贝给自身</T></li>
</ul>
<h3 id="有三种赋值"><a href="#有三种赋值" class="headerlink" title="有三种赋值"></a>有三种赋值</h3><ul>
<li>deque<int> d &#x3D; d1 等号赋值</int></li>
<li>deque<int> d3; d3.assign(d1.begin(),d1.end()) </int></li>
<li>d3.assign(10,100) 给10个100<br>和vector一样。</li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>函数原型：<br>deque.empty(); &#x2F;&#x2F;判断容器是否为空<br>deque.size(); &#x2F;&#x2F;返回容器中元素的个数<br>deque.resize(num); &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。<br>deque.resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>两端插入操作：<br>push_back(elem); &#x2F;&#x2F;在容器尾部添加一个数据<br>push_front(elem); &#x2F;&#x2F;在容器头部插入一个数据<br>pop_back(); &#x2F;&#x2F;删除容器最后一个数据<br>pop_front(); &#x2F;&#x2F;删除容器第一个数据<br>指定位置操作：<br>insert(pos,elem); &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。<br>insert(pos,n,elem); &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。<br>insert(pos,beg,end); &#x2F;&#x2F;在pos位置插入[beg，end)区间的数据，无返回值。<br>clear();&#x2F;&#x2F;清空容器的所有数据<br>erase(beg,end); &#x2F;&#x2F;删除[beg，end)区间的数据，返回下一个数据的位置。<br>erase(pos); &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>sort(d.begin(),d.end())</p>
<h2 id="STL–queue"><a href="#STL–queue" class="headerlink" title="STL–queue"></a>STL–queue</h2><p>先进先出，很像尾插法。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402113216514.png"><br><strong>不允许遍历！只能访问队头队尾！</strong><br>入队：q.push() 出队：q.pop()<br>基本操作<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250402113412632.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;compare_int_int&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;compare_double_double&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* //strcmp会逐个比较</span></span><br><span class="line"><span class="comment">const char* a = &quot;apple&quot;;</span></span><br><span class="line"><span class="comment">const char* b = &quot;apricot&quot;;</span></span><br><span class="line"><span class="comment">strcmp(a, b); // 比较 &#x27;a&#x27; vs &#x27;a&#x27; → &#x27;p&#x27; vs &#x27;p&#x27; → &#x27;p&#x27; vs &#x27;r&#x27; → 返回负数（&#x27;p&#x27; &lt; &#x27;r&#x27;）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* a = <span class="string">&quot;hello&quot;</span>; <span class="comment">//在内存中是&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;，a是一个指针，指向&#x27;h&#x27;的地址。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b)</span> <span class="comment">//const char* a 是一个指针，指向一个字符串的起始地址，字符串本质上是以 \0 结尾的 char 数组。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;compare_char*_char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">compare</span>(<span class="number">10.0</span>, <span class="number">20.0</span>);</span><br><span class="line">	<span class="built_in">compare</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>算法（一）</title>
    <url>/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><p>介绍常用的算法</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有三个关键量，right、left、middle；<code>middle = (right - left)&gt;&gt;1</code>，其中<code>&gt;&gt;</code>为右移运算符，将right - left结果的二进制位向右移一位，&gt;&gt;n右移n位，举个例子</p>
<ul>
<li>8 - 4 &#x3D; 4，4的二进制位为0100，右移一位变为0010，代表十进制2。</li>
<li>7 - 2 &#x3D; 5，5的二进制位为0101，右移一位变为0010，代表十进制2。<br>可以看出，右移运算符的作用是<code>将两数相减并向下取整得到结果</code><br>为什么要用右移运算符而不用&#x2F;2？</li>
<li>右移运算 &gt;&gt; 通常比除法 &#x2F; 更快，因为位运算是底层硬件直接支持的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left)&gt;&gt;<span class="number">1</span>); <span class="comment">//left每一次加上新的中间值</span></span><br><span class="line">			<span class="keyword">if</span> (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&lt;target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</strong><br><strong>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</strong><br>采用二分法，注意停止条件，当left&gt;right就停止了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (right&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> p = <span class="number">1.0</span>*middle*middle;</span><br><span class="line">            <span class="keyword">if</span> (p==x) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span> (p&lt;x)&#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311182900217.png"></p>
<h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><p>滑动窗口类似于双指针，用于去求最短子序列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311202740831.gif"><br>j是终止位置，很像毛毛虫往前拱，吃到了，然后尾巴再上来。<br>LeetCode 209</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum&gt;=target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                x = x &gt; subLength ? subLength : x;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == INT32_MAX? <span class="number">0</span> : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口例题2<br>The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:</p>
<p>maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4});<br>&#x2F;&#x2F;should be 6: {4, -1, 2, 1}<br>Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</p>
<p>Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist&#x2F;subarray.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSequence</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, maxSum = <span class="number">0</span>;  <span class="comment">// 初始化最大和为 0（符合题目要求）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; arr.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">        sum += arr[right];  <span class="comment">// 扩展窗口</span></span><br><span class="line">        </span><br><span class="line">        maxSum = std::<span class="built_in">max</span>(maxSum, sum);  <span class="comment">// 更新最大子数组和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前窗口的和变成负数，移动左指针</span></span><br><span class="line">        <span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的一步在while(sum&lt;0),会把之前为负数的窗口给舍弃掉，1 + -3 &#x3D; -2，-2 -1 &#x3D; -3，left左移动一位，-3 -（-3） &#x3D; 0，left左移一位，所以left变成了3；从3又继续开始遍历。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>说实话贪心算法并没有固定的套路。<br><strong>所以唯一的难点就是如何通过局部最优，推出整体最优。</strong><br>LeetCode455<a href="https://leetcode.cn/problems/assign-cookies/">分饼干</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g.<span class="built_in">size</span>()==<span class="number">0</span>||s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span> (s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span> (g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;g.<span class="built_in">size</span>()&amp;&amp;j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]&lt;=s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>计算机系统</title>
    <url>/2025/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h2><h3 id="80386通用寄存器"><a href="#80386通用寄存器" class="headerlink" title="80386通用寄存器"></a>80386通用寄存器</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312130401047.png"></p>
<ul>
<li>%ax :accumulate 累加寄存器</li>
<li>%bx :base 基址寄存器</li>
<li>%cx :count 计数寄存器</li>
<li>%dx :divide 放除法的商和余数</li>
<li>%eax : extend 扩展 表示32位的寄存器<br>%eax表示32位寄存器，%ax表示低16位，在低16位的寄存器中：%ah表示高八位，%al表示第八位</li>
</ul>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="1005-s-立即数寻址"><a href="#1005-s-立即数寻址" class="headerlink" title="1005.s 立即数寻址"></a>1005.s 立即数寻址</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312134223502.png"><br>movl $8,%eax; </p>
<ul>
<li>$是立即数，表示8</li>
<li>movl是移动的意思，将8赋值给%eax；<br>最终的运行结果如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312140455507.png"></li>
</ul>
<hr>
<h4 id="1006-s-寄存器寻址"><a href="#1006-s-寄存器寻址" class="headerlink" title="1006.s 寄存器寻址"></a>1006.s 寄存器寻址</h4><ul>
<li>movl 用于传送<strong>32</strong>位的长子值</li>
<li>movw 用于传送<strong>16</strong>位的子值</li>
<li>movb 用于传送<strong>8</strong>位的子值<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312141244989.png"><br><strong>不能把movw的w改为l，因为%bx是16位的寄存器，如果改为l试图把32位的传给16位是错误的</strong>。可以写mov &#x2F; movw<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312174829067.png"><br>命令为 movw $0x5678,%dx ; 意思是传16个字节(w)的数据到寄存器dx里，结果如我们所愿，如果用%dh&#x2F;%dl便会报错，因为%dh&#x2F;%dl是8位的寄存器;同样，也不能movw $0x5678,%edx，因为edx是32位的，所以只能写32位的地址。如下图，所以要用对应的寄存器和对应位数的mov指令或只写mov去传递数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312175249233.png"></li>
</ul>
<h4 id="1007-s-绝对寻址（直接寻址）"><a href="#1007-s-绝对寻址（直接寻址）" class="headerlink" title="1007.s 绝对寻址（直接寻址）"></a>1007.s 绝对寻址（直接寻址）</h4><p>movl 0x08048054,%exc，直接把这个内存地址赋给%exc。可以使用x&#x2F;4bx 08048054来查看以8054起的四个地址内容。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190744306.png" alt="查看内存内容"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190225523.png"><br>内存之中<strong>既可以存放数据，也可以存放指令</strong>。如图，b9是指令，从后往前看08、04、80、55就是数据。</p>
<h4 id="1008-s-间接寻址"><a href="#1008-s-间接寻址" class="headerlink" title="1008.s 间接寻址"></a>1008.s 间接寻址</h4><p>movl (%ebx),%eax 和寄存器寻址的区别在于第一个寄存器套上了括号，表示不是把寄存器%ebx的值赋给%eax，而是寄存器存放的数据的地址存放的内容赋给%eax。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191539026.png"><br>第一步，立即数寻址，把立即数08048054放到%ecx<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191713316.png"><br>第二步，查看08048054内存中存放的数据是什么，并将其传入<strong>16位</strong>的%ax中，得到结果0x8056，为什么是8056？因为56是低位，80是高位</p>
<h4 id="1009-s-变址寻址"><a href="#1009-s-变址寻址" class="headerlink" title="1009.s 变址寻址"></a>1009.s 变址寻址</h4><p>movl (%ebx,%edx),%eax 在1008的基础上，把括号内两个寄存器的值加起来，用这个内存地址去找里面的数据，然后把数据传给%eax。</p>
<h4 id="1010-s-比例变址寻址"><a href="#1010-s-比例变址寻址" class="headerlink" title="1010.s 比例变址寻址"></a>1010.s 比例变址寻址</h4><p>movl (%ebx,%ecx,0x2),%eax<br>%ebx为基址，%ecx与第三个参数(第三个参数只能为1，2，4，8，左移运算符)<strong>相乘</strong>并与基址相加，最后赋值给%eax。</p>
<h4 id="1012-s-获取变量在内存的地址"><a href="#1012-s-获取变量在内存的地址" class="headerlink" title="1012.s 获取变量在内存的地址"></a>1012.s 获取变量在内存的地址</h4><p>leal 5(%edx, %edx, 2), %eax   &#x2F;&#x2F;假设%edx的值为x, 这行代码会将%eax的值设置为”3x+5″.</p>
<h4 id="1013-s-栈操作指令"><a href="#1013-s-栈操作指令" class="headerlink" title="1013.s 栈操作指令"></a>1013.s 栈操作指令</h4><p>栈：先进后出<br>栈顶指针：保存在%esp寄存器中<br>压栈push出栈pop<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325154443719.png"><br>栈是往低处生长的。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155048996.png"><br>e0-4 &#x3D;dc 栈顶指针往前偏移了<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325155207739.png"><br>压栈后栈顶现在存放的是88888888</p>
<h4 id="1014-s-跳转指令"><a href="#1014-s-跳转指令" class="headerlink" title="1014.s 跳转指令"></a>1014.s 跳转指令</h4><p>直接跳转指令</p>
<ul>
<li>jmp lable</li>
<li>jmp 0x0804909a</li>
<li>jmp *%eax</li>
<li>*lable<br>条件跳转指令<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325161023037.png"></li>
</ul>
<h2 id="数的表示与处理"><a href="#数的表示与处理" class="headerlink" title="数的表示与处理"></a>数的表示与处理</h2><h3 id="整数表达"><a href="#整数表达" class="headerlink" title="整数表达"></a>整数表达</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172553621.png"><br>无符号整数就是大于等于0的数，4为无符号整数的取值范围为0-15。</p>
<h4 id="补码形式"><a href="#补码形式" class="headerlink" title="补码形式"></a>补码形式</h4><p>最高位的权重是负数<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172840669.png"><br>具体例子如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325172941441.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173019514.png"><br>对于相同的数，映射关系不同，得到的数也不同，下图是有符号数和无符号数的例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173154420.png"></p>
<h4 id="无符号数与有符号数的转换"><a href="#无符号数与有符号数的转换" class="headerlink" title="无符号数与有符号数的转换"></a>无符号数与有符号数的转换</h4><p>他们的二进制表示都相同，但如果是有符号数的话，第一位会乘负权重；如果是无符号数就是正常。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325173537847.png"></p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><p>无符号数加法<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250325175049195.png"></p>
<h2 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h2><h3 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h3><p>求一个负数的补码：比如-25</p>
<ul>
<li>先转换成原码 10011001 （<strong>有符号数</strong>最高位为标志位，代表-128（八位的话））</li>
<li>负数的反码等于<strong>除标志位各个位置取反</strong> 11100110</li>
<li>最后得到补码，补码就是在反码的基础上+1 11100111 转成16进制为E7H。</li>
</ul>
<h3 id="指令寄存器"><a href="#指令寄存器" class="headerlink" title="指令寄存器"></a>指令寄存器</h3><p>直接寻址的无条件转移指令功能是将指令中的地址码送入<strong>PC</strong>，<strong>PC决定下一条指令执行的地址。</strong></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="定点数的表示方法"><a href="#定点数的表示方法" class="headerlink" title="定点数的表示方法"></a>定点数的表示方法</h4><ul>
<li>定点小数 ：小数点在符号位和数值位（<strong>决定正负数之间</strong>）比如0.875（10），转换成二进制-&gt;0.111(B)，补够8位0（小数点隐含在这个位置）01110000；如果是-0.875就是11110000，符号位还是带权。</li>
<li>定点整数 ：小数点在最低位后，比如32(10)-&gt;100000(B)，补够8位，00100000，因为是正数，所以符号位为0；如果是-32，就10100000，这是原码，负数在计算机中以<strong>补码的形式存放</strong>，所以我们将其除符号位的所有位置反转得到<strong>反码11011111</strong>，再在反码的基础上+1得到补码11100000.</li>
</ul>
<h4 id="浮点数法的表示方法"><a href="#浮点数法的表示方法" class="headerlink" title="浮点数法的表示方法"></a>浮点数法的表示方法</h4><p>浮点数分为符号位、阶码、尾数三个部分<br>类似于科学计数法，比如112.5(10)来表示为1.125<em>10²<br>先将112.5转成二进制数，1110000.1(B) &#x3D; 可以表示为1.1100001</em>2^6，不能写为6，要写成110，这个指数就叫做<strong>阶码</strong>。1100001就叫做<strong>尾数</strong>（小数点后的数）<br>阶码要加127，6+127 &#x3D; 133再转成二进制<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250415204713980.png"><br>第二个例子<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250415204903548.png"><br>[ 符号位 | 阶码8位 | 尾数23位 ]<br>在浮点数编码表示中，(<strong>基数</strong>)在机器数中不出现，是隐含的。</p>
<p>下列叙述中概念正确地是( D )</p>
<p>A 定点补码运算时,其符号位不参加运算 &#x2F;&#x2F;都参与，否则加法无法处理正负数<br>B 浮点运算中,尾数部分只进行乘法和除法运算 &#x2F;&#x2F;位数部分可以进行<strong>加减乘除</strong><br>C 浮点数的正负由阶码的正负符号决定  &#x2F;&#x2F;由*<strong>符号位</strong>决定<br>D 在定点小数一位除法中为了避免溢出被除数的绝对值一定要小于除<br>数的绝对值</p>
<ul>
<li>当尾数用<strong>补码</strong>表示的时候，数符（符号位）和<strong>尾数第一位</strong>相反，则代表这个数<strong>规格化</strong></li>
</ul>
<p>假设初始值：%dh&#x3D;CD，%eax&#x3D;98765432,则执行 movzbl %dh ,%eax<br>这样一条指令后，%eax 的值为( D )<br>A %eax&#x3D; 987654CD<br>B %eax&#x3D; CD765432<br>C %eax&#x3D; FFFFFFCD<br>D %eax&#x3D; 000000CD<br>movzbl 指令的<strong>目标寄存器</strong>是 32 位的 %eax，而这条指令的设计就是：把源操作数（一个 8 位数）零扩展成 32 位，然后整个写入目标寄存器（%eax）中，覆盖原内容。</p>
<p>假设初始值：%dh&#x3D;CD，%eax&#x3D;98765432,则执行 movsbl %dh ,%eax<br>这样一条指令后，%eax 的值为( C )<br>A %eax&#x3D; 987654CD<br>B %eax&#x3D; CD765432<br>C %eax&#x3D; FFFFFFCD<br>D %eax&#x3D; 000000CD<br>movsbl %dh, %eax 是一条有符号扩展指令，会将 %dh 中的 8 位值 CD（即二进制 11001101，表示负数）扩展为 32 位，扩展时高位补符号位（即补 1），得到 FFFFFFCD，并覆盖写入整个 %eax，所以最终 %eax &#x3D; FFFFFFCD。</p>
<p>假设在 C 程序中有 int *a , int n ,如果值 a 在寄存器%ecx 中，n 在%edx<br>中，下面哪个指令计算的是 a[n] ？（ C ）<br>A ret (%ecx,%edx,4)<br>B leal (%ecx,%edx,4),%eax ret<br>C mov (%ecx,%edx,4),%eax ret<br>D mov (%ecx,%edx,1),%eax ret </p>
<p>int a[i] &#x3D; a + sizeof(int)<em>n，其中int的大小为4，<strong>mov是读取内存中的值，访问内存</strong>，而leal是*<em>计算地址</em></em>，结果存寄存器，不访问内存。<br>leal(%ecx,%edx,4),%eax : 计算地址ecx + 4<em>edx并存入eax中。<br>mov(%ecx,%edx,4),%eax ：计算地址并从*<em>这个地址中读取内容</em></em></p>
<p>并不是任何十进制小数都可用二进制表示 ，比如0.1（10）标识出来的就是一个无限不循环小数</p>
<p>下列指令不会改变条件码的值的是(D)<br>A testl %eax,%eax<br>B addl %eax,%eax<br>C cmpl %esi,%dsi<br>D jge .L2<br>test是按位与，add加，cmp比较，都会改变条件码，jg条件跳转。</p>
<p>下列汇编指令中正确的是（ A ）<br>A movl $0x4050,%eax<br>B movl(%eax),4(%esp)<br>C movl %eax,$0x123<br>D movb $0xF,%ebx<br>我们上课所学的汇编是将左边的传给右边，A将0x4050这个地址传给eax保存，B读取了eax所存放的地址，但是mov指令是要传递给寄存器的，所以应该是movl (%eax),%ebx</p>
<p>将一个 4 位数值-5 截断到 3 位数的结果为<br>先转为补码，-5的原码为1101，反码为1010，补码为1011，截断成三位数（<strong>舍弃最高位</strong>）称为011，变为3</p>
<p>将一个<strong>双字节</strong>的内容压入（32位），栈帧-4；</p>
<p>EAX是一个32位的寄存器，AX用来表示低16位，AH用来表示低16位的高8位，AL用来表示低16位的低8位。</p>
<p>算数右移（SAR）规则：<strong>保留符号位（最高位）右移其它位，末位丢弃</strong><br>原数： 11001110<br>SAR1： 11100111</p>
<p>对整数运算z&#x3D;x+y,设置条件码OF的表达式为D (x &lt; 0 &#x3D;&#x3D; y &lt; 0) &amp;&amp; (z &lt; 0 !&#x3D; x &lt; 0)  </p>
<ul>
<li>正溢出：x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; z &lt; 0（正溢出）</li>
<li>负溢出：x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; z &gt;&#x3D; 0（负溢出）</li>
</ul>
<p>在补码的加法中发生了负溢出的是<br>C x+y &#x3D; x+y-2^w<br>若 w 位补码中两个负数相加，结果却变成正数 ⇒ 发生负溢出，此时实际数学值超出了补码能表示的负数范围。当加法结果超出这个范围，补码会 回绕（wrap around），造成：负溢出 ⇒ 减去 2^w，正溢出 ⇒ 加上 2^w。</p>
<p>对整数运算z&#x3D;x+y,设置条件码CF的表达式为：（unsigned）z  &lt; （unsigned）x<br>CF:无符号加减法的进位（无符号溢出）<br>OF:溢出（有符号溢出）<br>SF:运算结果的正负<br>ZF:零标志位</p>
<p>假设AL&#x3D;5H，要使得AL&#x3D;0FAH，应执行的命令是( )。<br>5H &#x3D; 0000 0101 (二进制)<br>0000 0101  (原始值 AL &#x3D; 0x05)<br>取反后：  1111 1010  (AL &#x3D; 0xFA)</p>
]]></content>
  </entry>
  <entry>
    <title>Network</title>
    <url>/2025/03/19/Network/</url>
    <content><![CDATA[<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><p>The following content is about the basic knowledge of computer network.</p>
<h2 id="Breif-introduction"><a href="#Breif-introduction" class="headerlink" title="Breif introduction"></a>Breif introduction</h2><p>Such as smartphone, tv, safe system, car and so on.All of this are called <strong>host</strong> or <strong>end system</strong>. The end system is linked by <strong>communication link</strong>(通信链路) and <strong>packet switch</strong>(分组交换机).<br>Different communication links such as <strong>电缆、光纤、无线电频谱</strong> can spread the data with different speed. The transmission rate are measured by <strong>bit&#x2F;s or bps</strong>.These message packet(信息包) are called <strong>packet</strong>(分组).<br><em>The packet seems like truck, all of the truck trans the goods to the destination by highspeed road. The communication links like the road, the packet like the truck, and the packet switch like the fork in the road, and the end system like the building.</em><br>The end system connect the Internet by <strong>ISP</strong>(Internet Service Provider).<br>The end system, packet switch and the other part of Internet are <strong>following a series of protocol</strong>(协议). <strong>These protocols control the internet message’s receive and send</strong>. Such as TCP(Transmission Control protocol，传输控制协议) and IP(Internet protocol,网际协议) are <strong>the most important protocols in the internet</strong>.IP protocol defines the rules of sending and receiving message winin router and end system.The main protocol of Internet is called <strong>TCP&#x2F;IP</strong>.<br><strong>A socket interface</strong>(套接字接口) refers to a programming interface that allows communication between different computer systems over a network. For example, you want to write a letter for your friend, you can’t just write the letter and throw it out of the window and think he&#x2F;she can receive it. You need to put the letter into the envelop and write the full name, address, and postcode of your friend. Close the envelop and post a stamp and throw it into the post office. So all of these are the socket interface of postface, you need to obey it so that you can send your letter.</p>
<h2 id="What-is-protocol"><a href="#What-is-protocol" class="headerlink" title="What is protocol?"></a>What is protocol?</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319181124581.png"><br>Let’s begin at the human protocol. If you want to  say hi to the other, you need to first say ‘hi’ and wait for his response. If he gives your certain response, you can continue say what your want. But if he does’t want to response you, you can’t continue your work.<br>Now look at the picture, you tap the web’s url. You computer send a connection request message to the Web server and wait for the respond. The Web server receives that and return a connection response message. Then the computer sends a GET message, declaring what it wants to fetch from the Web server.<br>So the protocol defines the message’s format and order between two or more than two communication entity, and sending or receiving a message or something else.</p>
<h2 id="The-media"><a href="#The-media" class="headerlink" title="The media"></a>The media</h2><p>A bit from a series of connection link and router can arrive at the other end system. Each <strong>send-receive couple</strong> send the electromagnetic and pulse through a physical media. Such as 双绞铜线，同轴电缆，多模光纤缆. The physical media has two types: the guided media and the unguided media. For the first one, The waves go along with the solid media like 光缆，双绞铜线或同轴电缆.For the other, the waves spread through air or outter space. Such as WLAN or digital satellite channels.</p>
<h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185139123.png"></p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185234778.png"></p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185333613.png"></p>
<h3 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a>陆地无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185413035.png"></p>
<h3 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185439185.png"></p>
<h2 id="The-kernel-of-network"><a href="#The-kernel-of-network" class="headerlink" title="The kernel of network"></a>The kernel of network</h2><p>In various network application, the end system(also called host) exchanges messgae to each other. The messgae can implement a control function or contain the data. For sending a message to the destination host, the source end system cuts the long message into the little data brick. This operation called packet. Every packet can be transmited by connection link or packet switch between the source and destination. The time of transmiting is the length of bits(R) dividing the rate of connection link(R). So the time is (L&#x2F;R).</p>
<h3 id="packet-exchange"><a href="#packet-exchange" class="headerlink" title="packet exchange"></a>packet exchange</h3><p><strong>store and forward transmission</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191400491.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191419708.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191428022.png"><br><strong>The queuing delay and packet loss</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191821692.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191916889.png"><br><strong>The forwarding table and routing protocol</strong><br>The router gets the packet from a connection link linked to it, but how does it know where to trans the packet to the destination?<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319192733925.png"></p>
<h2 id="The-Internet-of-Internet"><a href="#The-Internet-of-Internet" class="headerlink" title="The Internet of Internet"></a>The Internet of Internet</h2><p>Lots of ISPs connect with each other, the low-level ISP connect to the high ISP. <strong>Peer to Peer(对等，两个运营商传输和接收尽量相同的bits，不让对方赚钱)</strong><br>IXP(Internet Exchange Point) is a meeting point, the peer ISP does’nt pay the extra fees.<br><strong>多宿(别吊死在一棵树上)</strong>:low-level ISP seeks for higher ISP to connect to make sure its capacity of connection. It can avoid the trouble caused by one of the ISP, it can use the other ISP.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319195757272.png"></p>
<h2 id="Time-Delay"><a href="#Time-Delay" class="headerlink" title="Time Delay"></a>Time Delay</h2><p>We have four types of time delay.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201045033.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201115287.png"><br><em>dtotal &#x3D; dproc + dqueue + dtrans + dprop</em></p>
<h2 id="Five-protocols"><a href="#Five-protocols" class="headerlink" title="Five protocols"></a>Five protocols</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319203624856.png"><br>我说张三你是帅哥，张三的身体是主机，耳朵是端口，我选择只传输给张三一个人，然后选择走哪条路（连接层就是链路层），如果他在泰国人就可以飞机过去，在国内就火车过去，电信号就通过电缆过去，最后物理层传输。</p>
<h1 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h1><p>There are two types of appliication architectures, one is <strong>client-server architecture</strong>, and the other is P2P.</p>
<h2 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h2><p>A forever-opening host is called <em>server</em>. It serves lots of other client hosts’ request. When the server receives the request for a objection form a client, it sends the objection back as the response. When we are in the client-server architecture, the client can’t communicate with the other client. Just like the two webserver can’t communicate with each other. The sever has a solid, well-known ip, and is forever-opening. So client can always send packets to the ip to communicate with it. In this system, the famous application includes the Web, FTP, Telnet and E-mail. In general, a single sever host can’t content all of the requests. So <strong>data center</strong> which has lots of hosts is used to create strong virtual server.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320113426164.png"></p>
<h2 id="Process-Communication"><a href="#Process-Communication" class="headerlink" title="Process Communication"></a>Process Communication</h2><p>In operating system, actually communicaition is a process instead of application. The processes in two different end system send message to communicate through computer network. The sending message process generates and sends the message to the net. The receiving process receives the message, and maybe send the message back to response. </p>
<h3 id="The-client-and-sever-process"><a href="#The-client-and-sever-process" class="headerlink" title="The client and sever process"></a>The client and sever process</h3><p>The web applications consist of couple of process. In Web application, a client webserver process exchanges the message with the Web server process. For each group of communication process, <strong>a process is called client, and the other is called server</strong>.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320114830448.png"></p>
<h3 id="The-process’s-interface-of-computer-network"><a href="#The-process’s-interface-of-computer-network" class="headerlink" title="The process’s interface of computer network"></a>The process’s interface of computer network</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115300248.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115304351.png"></p>
<h3 id="Process-Find-Address"><a href="#Process-Find-Address" class="headerlink" title="Process Find Address"></a>Process Find Address</h3><p>If we want wo send a letter to the destination, the destination needs to have an address. A host’s process sends packet to another host’s process. We need to define two label: ①The address of host;②The destination host’s receiving process’s identifier.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115840795.png"></p>
<h2 id="Four-factors-of-transmission-serve"><a href="#Four-factors-of-transmission-serve" class="headerlink" title="Four factors of transmission serve"></a>Four factors of transmission serve</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120312829.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120317239.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120323470.png"></p>
<h2 id="Transmission-Layer-Protocol"><a href="#Transmission-Layer-Protocol" class="headerlink" title="Transmission Layer Protocol"></a>Transmission Layer Protocol</h2><p>TCP &#x2F; UDP<br>TCP和UDP之间的区别与联系：就像打电话和写信，你打电话能知道他是谁，打给谁，挂断之后即时有反馈，而写信在你寄出去的一瞬间你不能确保信是否会寄到他那里，以及什么时候才能寄到，信的内容是否完整（丢包）。UDP就是用于可以容忍一点点丢包，比如实时竞技游戏，视频通话。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>A：是B吗？我要跟你通信，听得到我说话吗？<br>B：可以通信，你听得到我说话吗？<br>A：我也听得到。</p>
<p><em>其实二次握手就可以建立链接，三次握手是为了互相确认对方的序列号，四次挥手是因为服务端有未发送完的数据。所以需要服务端连续发两次。同时客户端最后的等待也是为了确保服务端收到ASK请求fin<del>ask</del>fin~ask,如果过了等待时间则认为服务端已经关闭（没有关闭的话会有ASK）</em></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>C：我困了，先不聊了吧<br>S：还有几件事，说完我们就睡觉……<br>……（说完之后）<br>S：好了，说完了，我挂线了<br>C：好，你挂吧<br>S挂断电话<br>C说完之后就直接睡觉了，不知道电话挂没挂断，在几分钟后听到手机没有声音传来了，即使不用睁眼也知道S挂断了</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http(HyperText Transfer Protocol)<br>HTTP（超文本传输协议）是互联网上用来传递信息的一种规则。可以把它想象成一种通讯方式，它定义了如何发送和接收网页内容，比如文本、图片和视频等。想象一下，当你在网上浏览器里输入一个网址或点击一个链接时，你的浏览器就通过HTTP向网站的服务器发送一个请求，就像是在说：“嘿，我想看这个网页。”服务器收到这个请求后，如果网页可用，它就用同样的HTTP规则回应，发送网页的内容回来。简单来说，HTTP像是你和网站之间的对话规则，确保双方都能理解对方发送的消息。这就是你能够浏览网页和观看在线视频的原因之一。若想<strong>高效识别用户</strong>，引入了cookies，cookies就像门禁卡，我新建了一个房子，刚开始来的给一张卡刷进来，后面来的时候就拿着这张卡，网页就可以识别到你这个人做了什么。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320132409503.png"></p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>链路层协议的任何设备均成为<strong>节点</strong>，节点包括主机、路由器、交换机、和WIFI接入点。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320135508535.png"><br>数据链路层有三个重要的问题：封装成帧、差错检测、可靠传输。</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320140209418.png"></p>
]]></content>
  </entry>
  <entry>
    <title>论文笔记</title>
    <url>/2025/03/28/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="COFFEE"><a href="#COFFEE" class="headerlink" title="COFFEE"></a>COFFEE</h1><p>c:cross-layer optimization for fast and efficient executions of the SK algorithm on HPC systems with clusters of compute nodes<br>在有计算节点集群的HPC系统上快速高效执行SK算法。<br><strong>算法中：行、列都可以重新缩放</strong>，<strong>列缩放相较行缩放极其缓慢</strong>。<br>在多节点上的性能比单节点提升最高7.5倍，平均2倍；与天河一号的MPI Allreduce算法比，最高2.9，平均1.6.<br>SK算法：a simple but very useful iterative method to approach the double stochastic matrix of Sinkhorn’s theorem by alternately rescaling all rows and all columns of the given matrix.<br>对矩阵进行缩放列。</p>
<p>现存的SK算法大多用去搞强化学习了（应用层），或者去加速收敛，很少有研究从计算机系统架构的角度考虑改进算法，特别是高性能计算（HPC）系统。HPC有他自己独特的计算、存储以及交流能力，看看是否能发挥全部潜力。SK算法在四个代表性应用的时间占比都超过一半（BALS的卷积也这样）所以就去优化。</p>
<p><strong>这篇论文用MPI，通过多核、多节点集群加速SK算法。</strong><br>先分析经典算法在天河1上。<br>列缩放的时间远超行缩放，原因是<strong>通过列缩放进行的内存访问是高度非连续的，这导致了较高的缓存未命中率。</strong><br>解决方法：<strong>探险重新设计列缩放以及信息阻塞</strong>去减少缓存未命中；设计微核并且重新设计指令去<strong>增加并行性</strong></p>
<p>优化思想：通用矩阵乘法、分层<br>分层的思想在MPI Allreduce算法（MPI_Allreduce 是 MPI（消息传递接口）中的一个函数，用于在所有进程之间<strong>进行归约操作并广播结果。</strong>）的相关优化中非常常见。</p>
<p>选择SALaR（？）作为基准去研究。发现：实现Allreduce可以与SK算法的其他任务进行overlap（重叠）进一部提高性能   </p>
<h2 id="本篇文章的主要contribution"><a href="#本篇文章的主要contribution" class="headerlink" title="本篇文章的主要contribution"></a>本篇文章的主要contribution</h2><ul>
<li>我们分析了 SK 算法在 HPC 集群上的执行行为，并观察到两个主要的性能挑战。首先是其列重新缩放表现出高度非连续的内存访问模式，这导致非常高的缓存未命中率，从而大大降低了整体性能。第二，即使采用 Foster 的方法设计，列重新缩放也会严重限制并行性</li>
<li>我们提出了 COFFEE，这是一种新颖的方法，它实现了多级优化设计，以优化 HPC 系统中大规模 SK 算法的处理（第 IV 节）。我们通过增强 MPI Allreduce 来提高并行效率，采用有效的领导者-工作者机制，尽可能重叠节点间(intra-node)通信、节点内通信和节点内计算</li>
<li>我们在天河一号超级计算机上评估了 COFFEE 的原型实现，证明了其与 SOTA 解决方案相比具有显著的性能优势（第六节）。我们的实验结果表明，COFFEE 分别在单节点和多节点环境中带来了高达 7.5 倍和 2.9 倍的性能提升。</li>
</ul>
<h2 id="SK算法"><a href="#SK算法" class="headerlink" title="SK算法"></a>SK算法</h2><p>双随机矩阵,sk算法就是在行列都归一化后，每行元素相加都为1，每列元素相加也都为1<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328202355119.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sinkhorn</span>(<span class="params">A, max_iter=<span class="number">1000</span>, tol=<span class="number">1e-6</span></span>):</span><br><span class="line">    A = np.array(A, dtype=np.float64)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">        A_prev = A.copy()</span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 行归一化</span></span><br><span class="line">        A /= A.<span class="built_in">sum</span>(axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)  <span class="comment"># 列归一化</span></span><br><span class="line">        <span class="keyword">if</span> np.allclose(A, A_prev, atol=tol):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">A = np.array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">3</span>, <span class="number">4</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>]])</span><br><span class="line">B = sinkhorn(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Row sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Col sums:&quot;</span>, B.<span class="built_in">sum</span>(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328203003067.png"></p>
<p>选SK算法而不是和其他算法有两重原因：</p>
<ul>
<li>现在主流的线性代数库（如 BLAS、NumPy、PyTorch 等）在进行矩阵乘法时，底层通常使用的是最基础的“三重循环”实现方式，而不是像 Strassen 或 Coppersmith-Winograd 这样的快速乘法算法。就像基本的矩阵乘法实现一样，最原始的 Sinkhorn-Knopp（SK）算法也<strong>更容易从计算机系统架构的角度进行优化</strong>。</li>
<li>现有的 SK 算法研究主要集中于通过<strong>减少矩阵缩放迭代次数</strong>来加快收敛速度​​，但我们的目标是<strong>减少每次迭代的时间</strong>。</li>
</ul>
<p>我们不再去限制每一行&#x2F;每一列的和接近1，而是去最后计算的时候让行&#x2F;列和为1，在计算结果之前不需要让它接近1。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328205256791.png"></p>
<p>Intel团队用Python。为了在超算上运行，我们选C实现，是他们SOTApython的重写，有循环展开和数据并行优化，并且性能不逊于他们。</p>
<p>串行处理行列缩放,明显看到列用了十几倍的时间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328212937491.png"></p>
<h2 id="介绍典型的并行算法"><a href="#介绍典型的并行算法" class="headerlink" title="介绍典型的并行算法"></a>介绍典型的并行算法</h2><p>关键点：如何分割数据和任务让交流<strong>少一些</strong>，让计算任务更<strong>稳定</strong>。<br>处理方法：把矩阵按行划分成多个子矩阵，每个处理器只负责其中一些行，这样在<strong>行归一化</strong>的时候每个处理器只需要处理自己的行，不需要通信；最后让通信发生在<strong>列归一化</strong>阶段，这部分可以统一优化。这样目的是<strong>把本地能算的留在本地，只在必要时跨节点通信</strong>。<br>算法执行被拆成四步：</p>
<ul>
<li>每个进程独立地对自己那一块行子矩阵进行行归一化（和算法1的第1–10行一样），不需要通信；</li>
<li>每个进程计算自己那部分子矩阵的列和；</li>
<li>调用 MPI_Allreduce 汇总所有进程的列和，得到全矩阵每列的总和；</li>
<li>每个进程根据上一步得到的列缩放因子，独立地对自己那块子矩阵做列归一化。<br>这样做能最大限度减少通信，仅在列缩放因子计算这一步使用 MPI，有利于并行效率。</li>
</ul>
<h2 id="图片示例"><a href="#图片示例" class="headerlink" title="图片示例"></a>图片示例</h2><p>在计算并行效率的时候，列缩放时处理器数为16的效率也骤降？<br>原因：<strong>行缩放</strong>的时候不需要进行通信，所有的处理器被平衡地加载；但到<strong>列缩放</strong>的时候处理器在等数据。<br><em>The reason is that the row rescaling is communication free and all the processors are load balanced. While for the column rescaling, the Allreduce used to find the column sum performs a lot of inter-node and intra-node communication, so that some processors are in the process of waiting for data</em> </p>
<h2 id="Motivation-of-COFFEE"><a href="#Motivation-of-COFFEE" class="headerlink" title="Motivation of COFFEE"></a>Motivation of COFFEE</h2><p>我们看到了在并行处理行缩放时候节点内的通信花费了太多时间，大大降低效率；因此我们想利用节点的不同通信特点，然后提升效率。</p>
<p>算法设计-微核设计-MPI优化</p>
<h2 id="CPU-ORIENTED-OPTIMIZATION"><a href="#CPU-ORIENTED-OPTIMIZATION" class="headerlink" title="CPU-ORIENTED OPTIMIZATION"></a>CPU-ORIENTED OPTIMIZATION</h2><p>列重排算法设计（Algorithm1和2的对比）</p>
<h2 id="Micro-kernel-redesign"><a href="#Micro-kernel-redesign" class="headerlink" title="Micro-kernel redesign"></a>Micro-kernel redesign</h2><p>采用SIMD：SIMD（Single Instruction, Multiple Data，单指令多数据流）是一种并行计算技术，它让一个指令同时处理多个数据。常用于图像处理、音频处理、科学计算等场景，加速处理速度，提升性能。<br>采用AVX2指令集：AVX2（Advanced Vector Extensions 2）是Intel推出的SIMD指令集扩展，属于x86架构的一部分。它在AVX的基础上增强了整数运算能力，支持256位宽的YMM寄存器，可以并行处理更多数据，广泛用于图像处理、机器学习等高性能计算中。<br>修改汇编指令</p>
<h2 id="MPI-optimization"><a href="#MPI-optimization" class="headerlink" title="MPI optimization"></a>MPI optimization</h2><h3 id="节点内Reduce算法优化"><a href="#节点内Reduce算法优化" class="headerlink" title="节点内Reduce算法优化"></a>节点内Reduce算法优化</h3><p>二叉树效率低是因为每个处理器开销不同，尤其在根节点，其他处理器都空闲（idle），<strong>加载不均</strong>。<br>为了解决这种严重的负载不均衡问题，我们重新设计了SK算法的Reduce实现，将本地和数组分成几部分。在节点内Reduce之后，每个worker保留本地最终和的一部分并以非阻塞方式将其发送给leader。我们的节点内Reduce实现基于MPI标准原语MPI_Send和MPI_Recv，与MPICH库中Reduce的实现一致。我们没有使用打包技术，因为要传递的数据几乎是连续的，打包带来的额外开销超过了使用它带来的性能提升。</p>
<h3 id="节点间AllReduce算法优化"><a href="#节点间AllReduce算法优化" class="headerlink" title="节点间AllReduce算法优化"></a>节点间AllReduce算法优化</h3><p>我们使用最流行的 Ring 算法实现 Allreduce，以生成列重新缩放的全局最终总和。Ring Allreduce 的一个缺点是它没有考虑节点的层次结构。一般来说，节点之间的带宽远低于节点内的带宽。因此，最近提出了分层 Ring Allreduce。<br>图 7 显示了我们基于分层环的优化。<br>主要思想是重叠节点内 Reduce 和节点间 Allreduce 的时间。我们将本地和数组分成几个数据块。如前所述，对数据块进行 allreduce 有三个连续步骤。首先，工作者对本地和的块执行节点内 Reduce，并将本地最终总和发送给领导者（图 7 中时间 1 的红色箭头）。接下来，领导者对全局最终总和执行节点间 Allreduce（图 7 中时间 2 的红色箭头）。最后，领导者将全局最终总和广播给其工作者（图 7 中时间 3 的红色箭头）。发现不同数据块的顺序步骤可以重叠。例如，图 7 中的时间 2 表示第 i 个数据块的节点间 Allreduce（红色箭头）和第 (i + 1) 个数据块的节点内 Reduce（黑色箭头）可以同时处理。因此，我们在为 SK 算法实现 Allreduce 时将管道的思想结合到分层环中。</p>
<h3 id="重叠通信和计算优化"><a href="#重叠通信和计算优化" class="headerlink" title="重叠通信和计算优化"></a>重叠通信和计算优化</h3><p>当领导者执行 Allreduce 时，工作者必须停滞。我们利用这段停滞时间让工作者修改节点内的矩阵。在我们对 SK 算法的优化 Allreduce 设计中，矩阵修改的计算被添加到流水线中。<br><strong>同时完成 Allreduce 的通信任务和修改子矩阵的计算任务</strong></p>
<h2 id="experiment-evaluation"><a href="#experiment-evaluation" class="headerlink" title="experiment evaluation"></a>experiment evaluation</h2><h3 id="Experimental-Setup"><a href="#Experimental-Setup" class="headerlink" title="Experimental Setup"></a>Experimental Setup</h3><p>为了评估 COFFEE 的有效性，我们将其两个版本进行比较，即面向 CPU 的优化（第 IV 节），表示为 COFFEE-CPU，以及面向 MPI 的优化（第 V 节），表示为 COFFEE-MPI，与 SK 算法的两个现有实现进行比较，一个使用 Ring Allreduce 算法（MPICH-Ring），另一个在 MPICH 环境中使用 SALaR（MPICH-SALaR）<br>高密度矩阵（非零元素占 95%）、中等密度矩阵（非零元素占 50%）、稀疏矩阵（非零元素占 5%）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250330172903583.png"><br>只去算非零矩阵。</p>
<h3 id="CPU-Oriented-Optimization"><a href="#CPU-Oriented-Optimization" class="headerlink" title="CPU-Oriented Optimization"></a>CPU-Oriented Optimization</h3><p>在AMD平台上使用GCC编译器运行的SK算法通过我们的优化获得了最大的改进。在ARM平台上使用Clang编译器，SK算法的典型实现的性能在所有平台上都是最好的，但我们的优化在M &#x3D; N &#x3D; 16,000时仍实现了3.3倍的加速比。</p>
<h3 id="MPI-Oriented-Optimization"><a href="#MPI-Oriented-Optimization" class="headerlink" title="MPI-Oriented Optimization"></a>MPI-Oriented Optimization</h3><h2 id="conclusion-and-further-work"><a href="#conclusion-and-further-work" class="headerlink" title="conclusion and further work"></a>conclusion and further work</h2><p>SK算法在机器学习等领域的重要性日益凸显。本文提出并实现了一种针对SK算法实现的计算和通信的跨层优化设计，称为COFFEE。与大多数现有的通过减少缩放迭代次数来加快收敛速度​​的工作不同，COFFEE着重于通过缩短每次缩放迭代来加快收敛速度​​。我们对SK算法实现中影响性能的问题进行了深入研究。发现列缩放会导致较高的缓存未命中率和较低的并行效率。我们使用列缩放重新设计、数据分块和微内核设计等跨层优化来加速列缩放。我们还根据SK算法的特点优化了MPI Reduce和Allreduce，以提高并行效率。最后，我们在天河一号超级计算机上验证了COFFEE 的有效性。未来我们计划进一步探索和利用行缩放和列缩放之间的相关性。此外，我们计划结合GPU，充分利用异构并行计算架构，进一步提高 COFFEE 的性能。最后，我们计划研究 COFFEE 在 SK 算法稀疏矩阵上的性能，其中数据不是以数组格式存储的。</p>
<h1 id="HSMU-SpGEMM"><a href="#HSMU-SpGEMM" class="headerlink" title="HSMU-SpGEMM"></a>HSMU-SpGEMM</h1><p>High Shared Memory Utilization for Parallel Sparse General Matrix-Matrix Multiplication on Modern GPUs<br>在现代 GPU 上实现并行稀疏通用矩阵-矩阵乘法的高共享内存利用率(utilization)</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>传统的基于哈希的方法无法在减少哈希冲突和有效利用快速共享内存之间取得平衡，这严重损害了在 GPU 上执行 SpGEMM 的性能。设计了一种<strong>累加器</strong>，四个通用库在三种架构上面跑，**HSMU有显著的加速优势。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Gustavson算法在GPU上用于实现快速并行稀疏矩阵乘法时有两个流程：<strong>符号阶段(symbolic stage)<strong>以及</strong>数值阶段(numeric stage)</strong> </p>
<ul>
<li>符号阶段的主要任务是去确定矩阵C中非零元素的数量(NNZ)，以便在数值计算的时候<strong>预先分配内存</strong></li>
<li>数值阶段在已分配的内存上<strong>进行实际的乘法和累加</strong>，是整个SpGEMM<strong>最耗时的部分</strong><br>高效的累加器设计对数值阶段的性能至关重要。<br>单纯<strong>增加</strong>哈希表的容量会降低GPU共享内存的利用率。<br>主流SpGEMM库的不足</li>
<li>Nsparse 虽利用最大 NNZ 设置哈希表长度以提高共享内存利用率，但哈希冲突严重，性能下降</li>
<li>spECK 通过分配 1.5× 空间减少冲突但造成约 34% 内存浪费</li>
<li>OpSparse 建议设为 2× 最大 NNZ，性能好但共享内存利用率仅达 50%<br><strong>HSMU-SpGEMM 通过为每个累加器内核维护一个按列排序的数组（长度为分配行的最大 NNZ）来避免哈希冲突，并针对小规模与大规模矩阵设计不同的符号阶段，从而在优化 GPU 共享内存利用率下的同时保持低冲突率，实现高性能 SpGEMM。</strong></li>
</ul>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Gustavson 算法具有天然的并行性，因为它可以独立计算矩阵 C 的每一行。在数值阶段，矩阵 A 中每个非零元素 𝑎𝑖𝑗会与矩阵 B 中对应行𝑏𝑗∗的非零元素相乘，生成大量中间结果，这些结果的列索引与 B 中元素的列索引一致。最终，通过累加器将这些中间结果累加到矩阵 C 的相应位置。累加器的具体设计将在下一小节介绍。<br>分为两种累加器：<strong>稠密型</strong>和<strong>稀疏型</strong></p>
<ul>
<li><p>稠密累加器使用稠密数组存储中间结果，通常由三个向量组成：一个存储实际数值，一个用于标记列索引是否插入，另一个记录列索引。这种方法在处理稠密行时效率高，但对稀疏行内存需求大、性能较差。</p>
</li>
<li><p>稀疏累加器则按累加方式分为三类：基于合并、ESC 和哈希的累加器。</p>
</li>
<li><p>基于合并的稀疏累加器在 RMerge和 bhSPARSE等库中实现。这些累加器执行多次迭代，每次迭代将一个 NZ(Non-zero) 元素垂直合并到最终的稀疏向量中。由于在合并过程中使用了大小相同的临时数组，因此基于合并的稀疏累加器对于密度变化较大的矩阵表现出<strong>较低的内存利用率</strong>。</p>
</li>
<li><p>ESC 方法在处理生成大量中间产品的矩阵时存在不足。由于存储和分类大量中间产品会产生大量的空间开销和时间成本，因此效率低下。</p>
</li>
</ul>
<h2 id="Shared-Memory"><a href="#Shared-Memory" class="headerlink" title="Shared Memory"></a>Shared Memory</h2><p>除了寄存器文件之外，共享内存是 GPU 上最快的内存类型。共享内存的主要优点是它<strong>允许多个线程共享数据</strong>，这使得共享内存成为高效并行计算的关键 GPU 组件。共享内存可供单个线程块内的所有线程访问，并且可以将其视为可编程缓存或暂存器，在其中放置经常访问的数据。但是，GPU 上的共享内存容量有限。所以高性能共享内存是非常重要的对于现代GPU。</p>
<h1 id="MOTIVATION-OF-THE-WORK"><a href="#MOTIVATION-OF-THE-WORK" class="headerlink" title="MOTIVATION  OF THE WORK"></a>MOTIVATION  OF THE WORK</h1><h2 id="Principles-of-Hash-based-Accumulators"><a href="#Principles-of-Hash-based-Accumulators" class="headerlink" title="Principles of Hash-based Accumulators"></a>Principles of Hash-based Accumulators</h2><p>现有的哈希累加器要去平衡<strong>共享内存利用率</strong>和<strong>哈希碰撞率</strong></p>
<h2 id="Philosophy-of-HSMU-SpGEMM-Accumulator-Design"><a href="#Philosophy-of-HSMU-SpGEMM-Accumulator-Design" class="headerlink" title="Philosophy of HSMU-SpGEMM Accumulator Design"></a>Philosophy of HSMU-SpGEMM Accumulator Design</h2><ul>
<li>引入一个预排序列索引数组（sorted column indices array）表示 C 的非零列。使用 findInSorted(colIp, sortedColArray) 函数来定位每个中间乘积，直接查找中间乘积该落在哪个已知列上。<strong>完全消除哈希冲突，查找位置准确，无需哈希函数或冲突处理。</strong></li>
</ul>
<h1 id="HSMU-SPGEMM"><a href="#HSMU-SPGEMM" class="headerlink" title="HSMU-SPGEMM"></a>HSMU-SPGEMM</h1><h2 id="HSMU-SpGEMM-Accumulator-Design"><a href="#HSMU-SpGEMM-Accumulator-Design" class="headerlink" title="HSMU-SpGEMM Accumulator Design"></a>HSMU-SpGEMM Accumulator Design</h2><p>采用<strong>二分查找</strong>而不是哈希，<strong>可以低开销，高效率，并且很稳定</strong>。<br>有以下好处</p>
<ul>
<li>哈希法相对于二分查找法的最大优势在于，在哈希表中添加或删除项目的成本要低得多。然而，在 HSMU-SpGEMM 中，排序数组是在符号阶段预先确定的，因此我们的新累加器不需要在数字阶段更改排序数组。因此，二分查找法中维护排序结构的缺点不存在；</li>
<li>哈希表的一个缺点是，当发生碰撞时，它会影响其他哈希位置，并可能导致链式碰撞，导致哈希性能低下。而对于二分查找，其性能稳定，最坏情况为O（logN）。在这种情况下，二分查找优于哈希查找方法；</li>
<li>二分查找更适合于范围查询等复杂操作。在这种情况下，每个线程通过不断更新变量pos逐渐缩小共享col数组上的搜索范围，从而在一定程度上减少查找次数；尽管如此，对于密集和大数据，二分查找的最坏时间复杂度为O(logN)，而哈希表的理想时间为O(1)。时间复杂度的增加可能会在某些情况下降低我们的累加器设计的搜索性能。</li>
</ul>
<h2 id="Generate-the-Sorted-Ccol-Array"><a href="#Generate-the-Sorted-Ccol-Array" class="headerlink" title="Generate the Sorted Ccol Array"></a>Generate the Sorted Ccol Array</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250408135942607.png"><br>先生成maskB，对于每一行B，非零元素位置标记为1，其他为0。<br><strong>不太懂</strong>生成maskC的原理。</p>
]]></content>
  </entry>
  <entry>
    <title>LearningHPC</title>
    <url>/2025/03/28/LearningHPC/</url>
    <content><![CDATA[<h2 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h2><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants\0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现图片的打开。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172122965.png"><br>因为在python里面\t或者是\n是转义字符，<strong>直接加r表示这就是原始语义</strong>。</p>
<p>如果要读取一个文件夹里的许多图片，需要用到os库，然后使用列表的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dir_path = <span class="string">r&quot;D:\PythonProject2\hymenoptera_data\hymenoptera_data\train\ants&quot;</span></span><br><span class="line">img_path_list = os.listdir(dir_path)</span><br></pre></td></tr></table></figure>
<p>最后达到右边的效果<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250328172705602.png"></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2025/03/30/LeetCode/</url>
    <content><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h3 id="2025-3-30"><a href="#2025-3-30" class="headerlink" title="2025.3.30"></a>2025.3.30</h3><p><a href="https://leetcode.cn/problems/make-the-string-great/submissions/617067145/">栈专题</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">makeGood</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">abs</span>(res.<span class="built_in">back</span>() - c) == <span class="number">32</span>) &#123;</span><br><span class="line">            res.<span class="built_in">pop_back</span>(); <span class="comment">// 删除上一个相反大小写的字母</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果栈空，直接插入；如果栈非空，比较当前插入的字符和栈内的字符ascii码差值是否为32，<strong>32为大小写关系</strong>。</p>
<p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/description/">左右元素和的差值</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftRightDifference</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + nums[i + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            res[i] = <span class="built_in">abs</span>(left[i] - right[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/non-decreasing-array/description/">非递减数列</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkPossibility</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]&gt;nums[i<span class="number">+1</span>])&#123;</span><br><span class="line">                    nums[i<span class="number">+1</span>] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> nums[i] = nums[i<span class="number">+1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关键在于你要去改，通过当前数的左右两边数来判断是要去改这个数大还是改这个数小，改完之后接着往下去比。<br>3 4 2 3，到了4，4大于2，发现num[i-1] &gt; num[i+1] ，如果想要满足题目的非递减，那就要把num[i+1] &#x3D; num[i]，把这个数字改大，现在序列变成了3 4 4 3，到了下一个i，4&gt;3，这时候cnt++，就跳出循环了。<br>1 4 2 3，到了4，发现要把num[i]改小，所以num[i] &#x3D; num[i+1]。</p>
<h3 id="2025-3-31"><a href="#2025-3-31" class="headerlink" title="2025.3.31"></a>2025.3.31</h3><p><a href="https://leetcode.cn/problems/reverse-bits/">颠倒二进制串</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(n&amp;<span class="number">1</span>);</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res&lt;&lt;<span class="number">1</span>|stk[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用了位运算，第一个for循环让这整个字符串和1与（1写成二进制是000…001，所以只会剩下最后一位），然后把最后一位插入stk里；第二个for循环先让res左移一位(<strong>左移相当于后面补0，0补再多的0还是0</strong>)，不然会最后多一个0，因为初始化的时候我们已经给了一个0给他了，然后再和数组进行或运算。</p>
<p><a href="https://leetcode.cn/problems/power-of-two/description/">2的幂</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n&amp;(n<span class="number">-1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>今天运气真的好，又遇到了一道<strong>位运算</strong>，而且这个设计的真的很巧妙，以后遇到二进制&#x2F;幂要想到<strong>位运算</strong>。 比如8和7，8是1000，7是0111，只要他是2的幂，就一定和他的差与为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入两个整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = a &amp; b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个数 (&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;) 的二进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二个数 (&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;) 的二进制: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(b) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;两个数相与的结果: &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(result) &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用这个程序来看看二进制出来的结果。</p>
<p><a href="https://leetcode.cn/problems/number-of-1-bits/description/">汉明距离</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>) cnt++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>已经初步掌握位运算了，还是挺开心。</p>
<p><a href="https://leetcode.cn/problems/ransom-note/description/">赎金信</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            a[magazine[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            a[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (a[ransomNote[i] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其实就是字符统计，统计看看资源够不够，但是这一题我一开始犯了一个错误，我定义的是<strong>char</strong>类型的数组，这有一个很严重的问题，char存储只能-127 ~ 128，如果同一个数多了，比如128，那再遇到下一个这个字母数组的值马上变成-127，问题就在这！<br>然后是要用<strong>字母-‘a’</strong>，因为a的ASCII码值为97，z的码值为122，差最多就是25，所以创一个26大小的就可以了。</p>
<p><a href="https://leetcode.cn/problems/hamming-distance/description/">汉明距离</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> xorR = x^y;</span><br><span class="line">        <span class="keyword">while</span> (xorR&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += xorR&amp;<span class="number">1</span>;</span><br><span class="line">            xorR&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是使用异或，不同位异或结果是1，然后统计1的个数就可以了。<br><a href="https://leetcode.cn/problems/n-th-tribonacci-number/description/">第N个泰波那契数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="number">0</span>,b=<span class="number">1</span>,c=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="type">int</span> temp = a+b+c;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是斐波那契额递归的优化版，用递归太耗费时间了，我们在n大于3的时候用for循环，找到规律f(n) &#x3D; f(n-3)+f(n-2)+f(n-1)，最后输出f(n)</p>
<h3 id="2025-4-1"><a href="#2025-4-1" class="headerlink" title="2025.4.1"></a>2025.4.1</h3><p><a href="https://leetcode.cn/problems/valid-mountain-array/description/">有效地山脉数组</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (size&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span>&lt;size &amp;&amp; arr[i]&lt;arr[i<span class="number">+1</span>]) i++;</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span> || i == size<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + <span class="number">1</span>&lt;size &amp;&amp; arr[i]&gt;arr[i<span class="number">+1</span>]) i++;</span><br><span class="line">            <span class="keyword">return</span> i == size<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>先从头开始往上爬，找峰顶</li>
<li>再从峰顶往下走；</li>
<li>最后判断是否正好走到结尾。</li>
</ul>
<p><a href="https://leetcode.cn/problems/count-elements-with-strictly-smaller-and-greater-elements/description/">元素计数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">num</span> (nums);</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(),num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = num[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> min = num[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> cnnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i&lt;nums.<span class="built_in">size</span>() ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i]!=max &amp;&amp; num[i]!= min) cnnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是去找非最大和非最小的元素。<br><a href="https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/description/">数字小镇中的捣蛋鬼</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getSneakyNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            count[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(a.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希表，键值对的问题。<br><strong>特别注意</strong>：unordered_map不能通过下标去访问，而是通过<strong>键</strong>去访问数据的<br><a href="https://leetcode.cn/problems/happy-number/">快乐数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getValue</span>(n);</span><br><span class="line">            <span class="keyword">if</span> (sum==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum)!=s.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">insert</span>(sum);</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>find返回的是<strong>迭代器</strong>的值，迭代器可以理解为一个指向该元素的<strong>指针</strong>，当迭代器返回的值是a.end()代表<strong>没有找到这个元素</strong>，所以我们在判断条件中使用<strong>s.find(num)<strong>得到的是一个迭代器的值，而不是布尔值，如果它不等于s.end()，那就说明已经存在了。 <em>s.end()指向的是最后一个元素的下一个位置</em><br>当我们进入</strong>无限循环</strong>的时候去想想<strong>哈希表</strong>的思路，哈希表可以快速查找。</p>
<p><a href="https://leetcode.cn/problems/single-number/description/">只出现一次的数字</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            res =a^res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>①任何数和自己异或就是0，最后剩下的那个数就是只出现过一次。<br>②用map，出现就值+1，去遍历值为1的。<br><a href="https://leetcode.cn/problems/majority-element-ii/">多数元素Ⅱ</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> times = nums.<span class="built_in">size</span>() / <span class="number">3</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : nums) &#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second &gt; times) &#123;</span><br><span class="line">                a.<span class="built_in">push_back</span>(p.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希表使用的已经比较熟练了，现在问题在于对map的取键值对语法总是忘记，以后就规范用auto，auto自动推导为迭代器，然后用.访问符就可以访问键&#x2F;值了。</p>
<h3 id="2025-4-2"><a href="#2025-4-2" class="headerlink" title="2025.4.2"></a>2025.4.2</h3><p><a href="https://leetcode.cn/problems/isomorphic-strings/description/">同构字符串</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,<span class="type">char</span>&gt; ms,mt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> a = s[i],b = t[i];</span><br><span class="line">            <span class="keyword">if</span> (ms.<span class="built_in">count</span>(a)&amp;&amp;ms[a]!=b || mt.<span class="built_in">count</span>(b)&amp;&amp;mt[b]!=a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ms[a] = b;</span><br><span class="line">            mt[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>哈希表的运用，双射，如果我在a中找到了这个字符，并且我的映射不等于b中的字符，就return false<br><a href="https://leetcode.cn/problems/word-pattern/description/">单词规律</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector &lt;string&gt; <span class="built_in">Split</span>(string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span>(iss&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            words.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> words;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string s)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">char</span>,string&gt; m;</span><br><span class="line">        unordered_map &lt;string,<span class="type">char</span>&gt; m1;</span><br><span class="line">        vector&lt;string&gt; cc = <span class="built_in">Split</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;pattern.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pattern.<span class="built_in">size</span>()!=cc.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">char</span> a = pattern[i];</span><br><span class="line">            string b = cc[i];</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(a)&amp;&amp;m[a]!=b || m<span class="number">1.</span><span class="built_in">count</span>(b)&amp;&amp;m1[b]!=a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[a] = b;</span><br><span class="line">            m1[b] = a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>istringstream 是 C++ 标准库 <sstream> 中的类，用于从字符串中像从流（例如 cin）中一样提取数据。它常用于字符串的“切割”或格式化读取。</sstream></p>
<ul>
<li>iss &gt;&gt; word 会跳过空格，自动提取下一个以空格分隔的单词。</li>
<li>也可以提取数字等，比如：int x; iss &gt;&gt; x;</li>
<li>适合用来解析以空格、换行等分隔的字符串数据。<br>要保证他是双向映射的，所以需要两个哈希表来维护。</li>
</ul>
<h3 id="2025-4-9"><a href="#2025-4-9" class="headerlink" title="2025.4.9"></a>2025.4.9</h3><p><a href="https://leetcode.cn/problems/unique-paths/description/">不同路径</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[m][n];</span><br><span class="line">        <span class="comment">//vector &lt;vector&lt;int&gt;&gt; dp(m,vector&lt;int&gt;(n,1));</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span> (i==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span> dp[i][j] = dp[i][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以先从一维的动态规划数组理解，斐波那契数列1 1 2 3 5 8……dp[0] &#x3D; 1，dp[1] &#x3D; 1,从2开始往后的就是dp[i] &#x3D; dp[i-1]+dp[i-2]<br>现在是二维的图，就要去分成小的子问题，用子问题倒推回最难的问题，画一个表格就一目了然了。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250409174221016.png"><br>看这张图，只能向右或者向下移动，那我们把机器人旁边的格子设为终点，机器人有几条路可以到终点呢？只有一条，机器人斜对角也就是dp[i-1][j-1] &#x3D; dp[i][j-1] + dp[i-1][j]两种方案合起来。</p>
<h3 id="2025-4-10"><a href="#2025-4-10" class="headerlink" title="2025.4.10"></a>2025.4.10</h3><p><a href="https://leetcode.cn/problems/remove-element/description/">移除元素</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用<strong>快慢指针法</strong>，先判断当前这个数字是不是想要的值，如果不是就让它往后滚动。</p>
<p><a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">反转字符串中的元音字母</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvowel</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        c = <span class="built_in">tolower</span>(c);</span><br><span class="line">        <span class="keyword">return</span> (c==<span class="string">&#x27;a&#x27;</span> || c==<span class="string">&#x27;e&#x27;</span> || c==<span class="string">&#x27;i&#x27;</span> || c==<span class="string">&#x27;o&#x27;</span> || c==<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseVowels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left &amp;&amp; !<span class="built_in">isvowel</span>(s[left])) left++;</span><br><span class="line">            <span class="keyword">while</span>(right&gt;left &amp;&amp; !<span class="built_in">isvowel</span>(s[right])) right--;</span><br><span class="line">            <span class="keyword">if</span> (right&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用双指针来实现，两边都去找元音，都找到了就交换。</p>
<h3 id="2025-4-11"><a href="#2025-4-11" class="headerlink" title="2025.4.11"></a>2025.4.11</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">反转链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    	ListNode *p = <span class="literal">nullptr</span>;</span><br><span class="line">    	ListNode *cur = head;</span><br><span class="line">    	<span class="keyword">while</span> (cur!=<span class="literal">nullptr</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		ListNode *temp = cur-&gt;next;</span><br><span class="line">    		cur-&gt;next = p;</span><br><span class="line">    		p = cur;</span><br><span class="line">    		cur = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>采用<strong>头插法</strong>，不要自己空想一个头出来！！！！！现在全世界没人比我更懂链表！</p>
<h3 id="2025-4-12"><a href="#2025-4-12" class="headerlink" title="2025.4.12"></a>2025.4.12</h3><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">移除链表元素</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        ListNode *q = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        q = dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">                ListNode *cur = p-&gt;next;</span><br><span class="line">                q-&gt;next = cur;  <span class="comment">// 这里更新了q指向的节点，跳过p</span></span><br><span class="line">                <span class="keyword">delete</span> p;       <span class="comment">// 删除p节点</span></span><br><span class="line">                p = cur;        <span class="comment">// p继续前进</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = dummy-&gt;next;  <span class="comment">// 返回新头节点</span></span><br><span class="line">        <span class="keyword">delete</span> dummy;  <span class="comment">// 删除虚拟头节点</span></span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在应该彻底搞懂链表到底是什么了，其实不是链表的知识不懂，是<strong>函数传参</strong>出现了问题，这个函数传进来的<strong>是一个head节点，它指向链表的头部</strong>，而不是传一个链表进来，函数前几行定义了一个虚拟的头节点，让前后两个指针往后遍历。最后返回的时候不能return q，因为q节点已经遍历完链表了啊。</p>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">删除链表倒数的第N个节点</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,<span class="literal">nullptr</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        ListNode *q = dummy;</span><br><span class="line">        <span class="type">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *toDelete = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = toDelete-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> toDelete;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在已经把函数传参的问题解决了，以后要多画图，像今天蓝桥杯画图就解决出来了，然后是找到倒数第N个节点，我们先虚构出一个头节点，让一个指针先走N步，然后两个指针一起往后挪动，如果前面的指针下一个是空，那说明我们后面出发的指针下一位置就是要删除节点了，我们就采用删除节点的方法，创建一个新指针指向要被删除的节点，再把链表连接起来。</p>
<h3 id="2025-4-13"><a href="#2025-4-13" class="headerlink" title="2025.4.13"></a>2025.4.13</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *newlink = dummy;</span><br><span class="line">        ListNode *p = list1;</span><br><span class="line">        ListNode *q = list2;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &gt;= q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink-&gt;next = q;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                newlink = newlink-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;val &gt;= p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlink-&gt;next = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                newlink = newlink-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newlink-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newlink-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *res = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>今天对链表的掌握程度更上一层楼了，记住要画图进行需求分析，这样不容易乱，还有在堆内存的释放。</p>
<p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">逆波兰表达式求值</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">char</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left+right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left - right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left*right;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> left/right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;</span><br><span class="line">                (a[<span class="number">0</span>]==<span class="string">&#x27;+&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;/&#x27;</span>||a[<span class="number">0</span>]==<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> right = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> left = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> val = <span class="built_in">cal</span>(left,right,a[<span class="number">0</span>]);</span><br><span class="line">                    s.<span class="built_in">push</span>(val);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="built_in">stoi</span>(a));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>逆波兰表达式也就是后缀求值，遇到数字就入栈，遇到符号就从栈里面取出两个数字进行运算。先pop出来的值作为等号右边的值，后pop出来的是等号左边的值。</p>
<p><a href="https://leetcode.cn/problems/sort-an-array/description/">排序数组</a><br>希尔排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> gap = nums.<span class="built_in">size</span>()/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = gap;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> val = nums[i];</span><br><span class="line">                <span class="type">int</span> j = i - gap;</span><br><span class="line">                <span class="keyword">for</span> ( ; j&gt;=<span class="number">0</span> ; j-=gap)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (val &gt;= nums[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums[j+gap] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[j + gap] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后面慢慢更其它的。</p>
<h3 id="2025-4-14"><a href="#2025-4-14" class="headerlink" title="2025.4.14"></a>2025.4.14</h3><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">反转字符串中的单词</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (ss&gt;&gt;word)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(word);</span><br><span class="line">        &#125;</span><br><span class="line">        string sres;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                sres += res[i]+<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sres +=res[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用istringstream读取原字符串，然后将分割出来的单词插入进数组，反向遍历。<br><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">删除字符串中的所有相邻重复项</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;<span class="type">char</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">            	res.<span class="built_in">push</span>(s[i]);	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (res.<span class="built_in">top</span>()==s[i])</span><br><span class="line">            	&#123;</span><br><span class="line">                res.<span class="built_in">pop</span>();</span><br><span class="line">            	&#125;</span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">            	&#123;</span><br><span class="line">                res.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            	&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(!res.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans += res.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>栈的应用，很简单。<br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">相交链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt1++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt2++;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 &gt;= cnt2)</span><br><span class="line">        &#123;</span><br><span class="line">            p = headA;</span><br><span class="line">            q = headB;</span><br><span class="line">            <span class="type">int</span> dif = cnt1 - cnt2;</span><br><span class="line">            <span class="keyword">while</span> (dif &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                dif--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt2 &gt; cnt1)</span><br><span class="line">        &#123;</span><br><span class="line">            p = headA;</span><br><span class="line">            q = headB;</span><br><span class="line">            <span class="type">int</span> dif1 = cnt2 - cnt1;</span><br><span class="line">            <span class="keyword">while</span> (dif1 &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">                dif1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p!=<span class="literal">nullptr</span> &amp;&amp; q!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p==q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相交链表很有意思，在它们<strong>没有相交之前</strong>，如果第一个链表比第二个链表长，那就让长链表的指针先往下走这些差值，然后开始进行比较。<br><a href="https://leetcode.cn/problems/add-strings/description/">字符串相加</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">1.</span><span class="built_in">begin</span>(),num<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num<span class="number">2.</span><span class="built_in">begin</span>(),num<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxsize = <span class="built_in">max</span>(num<span class="number">1.</span><span class="built_in">size</span>(),num<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">res</span>(maxsize<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxsize;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = i &lt; num<span class="number">1.</span><span class="built_in">size</span>() ? num1[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> b = i &lt; num<span class="number">2.</span><span class="built_in">size</span>() ? num2[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            res[i] += a + b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;maxsize<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i]&gt;=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i<span class="number">+1</span>] += (res[i])/<span class="number">10</span>;</span><br><span class="line">                res[i]%=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string resS;</span><br><span class="line">        <span class="type">int</span> j = res.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;res[j]==<span class="number">0</span>) j--;</span><br><span class="line">        <span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            resS += <span class="built_in">to_string</span>(res[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> resS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实就是在问你，如果超出了long long范围的加法，你怎么办？<br>用两个字符串来倒序相加，加进结果数组，如果这个数字大于等于10表明要进位，那就&#x2F;&#x3D;10，然后留下进位后的数，<strong>最后找前导0，找第一个非0元素，没找到就一直–</strong></p>
<h3 id="2025-4-15"><a href="#2025-4-15" class="headerlink" title="2025.4.15"></a>2025.4.15</h3><p><a href="https://leetcode.cn/problems/sort-list/description/">排序链表</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        ListNode *q = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *dummy = q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            dummy-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num);</span><br><span class="line">            dummy = dummy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>排序用快排，先将链表中的所有数字取出来放到vector里，然后sort排序，最后使用for (int)遍历，不要用i来遍历，因为vector会自动扩容</p>
<h3 id="2025-4-16"><a href="#2025-4-16" class="headerlink" title="2025.4.16"></a>2025.4.16</h3><p><a href="https://leetcode.cn/problems/unique-number-of-occurrences/">独一无二的出现次数</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">uniqueOccurrences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:arr)</span><br><span class="line">        &#123;</span><br><span class="line">            m[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b:m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.first!=b.first &amp;&amp; a.second==b.second)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用哈希表存储每一个数字出现的次数，然后两重循环遍历个数。<br><a href="https://leetcode.cn/problems/first-letter-to-appear-twice/">第一个出现两次的字母</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(a);</span><br><span class="line">            <span class="keyword">if</span> (it==m.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">emplace</span>(a,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>思路：去遍历哈希表里是否有过这个字母（数字），如果没有，就把它添加进去，如果有，就说明是我们刚刚添加过的，它就是第二次出现的！<br><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中第k个最大元素</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;q.<span class="built_in">top</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用优先队列来实现，默认的优先队列是一个大顶堆，我们用大根堆来找前k个最小的数，如果想要设置为小根堆，需要priority_queue&lt;int,vector<int>,greater<int>&gt;，这是去找前k个最大的数；最后我们return q.top()即可得到第k个最大&#x2F;最小的数</int></int></p>
<h3 id="2025-4-18"><a href="#2025-4-18" class="headerlink" title="2025.4.18"></a>2025.4.18</h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">树的前序、中序、后续遍历</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode *node,vector&lt;<span class="type">int</span>&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">InOrder</span>(node-&gt;left,ans);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="built_in">InOrder</span>(node-&gt;right,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">InOrder</span>(root,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也是终于进入到树了，采用递归的思想去解决问题。</p>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *node,<span class="type">int</span> level,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (node==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span> (level == ans.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">    	ans[level].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">    	<span class="built_in">dfs</span>(node-&gt;left,level<span class="number">+1</span>,ans);</span><br><span class="line">	    <span class="built_in">dfs</span>(node-&gt;right,level<span class="number">+1</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">dfs</span>(root,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里使用的是vector&lt;vector<int>&gt;,使用ans.size()返回的是这个二维数组的（行）层数，一开始行数为0，就创建一行，接下来递归调用，在当前level层里push node的数值。</int></p>
<p><a href="https://leetcode.cn/problems/subsets/description/">子集</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Res</span><span class="params">(<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt; &amp;nums,vector&lt;<span class="type">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i==nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">Res</span>(i<span class="number">+1</span>,nums,path);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="built_in">Res</span>(i<span class="number">+1</span>,nums,path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">Res</span>(<span class="number">0</span>,nums,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>今天开始学习回溯算法，回溯其实就是一直递归，递归到了子集树的叶子节点就处理这个子集，如果没有递归到这个子集，就处理<strong>选择</strong>或者<strong>不选择</strong></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法</title>
    <url>/2025/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>下标访问的复杂度为O(1)</li>
<li>末尾位置增加删除元素时间复杂度为O(1)  删除就是–，增加就是++</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>非末尾元素增加位置需要<strong>大量的数据移动</strong></li>
<li><strong>搜索的复杂度是O(n)</strong>  注意搜索和访问不是一个东西，搜索是遍历寻找这个值，而访问是a[0]–a[n-1]，在<strong>无序数组</strong>中采用遍历，是<strong>线性搜索</strong>；在<strong>有序数组</strong>中采用二分，复杂度为O(logn)</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>内存利用率高，不需要大块连续内存</li>
<li>插入和删除节点不需要移动其它节点，时间复杂度O(1)</li>
<li>不需要专门进行扩容操作</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>内存占用量大，每一个节点多出存放地址的空间</li>
<li>节点内存不连续，无法进行内存随机访问</li>
<li>链表搜索效率不高，只能从头节点开始逐节点遍历</li>
</ul>
<h4 id="内存碎片化"><a href="#内存碎片化" class="headerlink" title="内存碎片化"></a>内存碎片化</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411081508857.png"><br>现在我们有100M的内存空间（堆上），<strong>内存的释放是一块一块的，谁用完了谁就被释放了</strong>，如果将中间的20M和最右边的10M手动释放掉；我们就得到了两块内存碎片；现在我们有30M的空闲空间。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411081846625.png"><br>如果现在进程运行需要25M的内存空间，我们能不能分配25M的数组呢？ <strong>不能</strong>，数组的内存是绝对连续的<br>在<strong>内存碎片</strong>过多的情况下，无法开辟大数组，这时候就可以用<strong>链表</strong>，每一个节点都是独立new出来的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250411082625810.png"><br>从头节点访问到最后一个节点，最后一个节点的地址域为<strong>NULL</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> data = <span class="number">0</span>) : <span class="built_in">data_</span>(data),<span class="built_in">Next_</span>(<span class="literal">nullptr</span>)&#123;&#125; </span><br><span class="line">    <span class="type">int</span> data_;</span><br><span class="line">    Node *Next_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体其实就是一个public的类，现在写了一个<strong>Node</strong>的构造函数，如果不传参默认data就是0。为什么后面要加一个大括号？因为前面在初始化，初始化已经完成了，后面是函数体{}可以是空的。<br>不要总去判断当前节点的下一节点<strong>是否为空</strong>，老老实实判断当前节点是否为空，除非你真的要去找末尾节点。</p>
<h3 id="链表接口"><a href="#链表接口" class="headerlink" title="链表接口"></a>链表接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">int</span> data = <span class="number">0</span>):<span class="built_in">data_</span>(data),<span class="built_in">next_</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">	<span class="type">int</span> data_;</span><br><span class="line">	Node *next_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clink</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Clink</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//给head初始化，指向头节点 </span></span><br><span class="line">			head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">Clink</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			Node *p = head;</span><br><span class="line">			<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				head = head-&gt;next_;</span><br><span class="line">				<span class="keyword">delete</span> p;</span><br><span class="line">				p = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//尾插法 复杂度O(n) 因为要遍历整个链表 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">InsertTail</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="comment">//先找到当前链表的末尾节点</span></span><br><span class="line">			Node *p = head;</span><br><span class="line">			<span class="keyword">while</span>(p-&gt;next_!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p = p-&gt;next_;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//生成新节点 </span></span><br><span class="line">			Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">			p-&gt;next_ = node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 头插法 复杂度O(1) 因为直接找到头节点的下一节点 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">InsertHead</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">			node-&gt;next_ = head-&gt;next_;</span><br><span class="line">			head-&gt;next_ = node;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 链表单个节点删除 用双节点法 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			Node *q = p; <span class="comment">//q永远跟在p后面 </span></span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">				&#123;</span><br><span class="line">					q-&gt;next_ = p-&gt;next_;</span><br><span class="line">					<span class="keyword">delete</span> p;</span><br><span class="line">					<span class="keyword">return</span>; </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					q = p; </span><br><span class="line">					p = p-&gt;next_;</span><br><span class="line">						</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">RemoveAll</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			Node *q = head;</span><br><span class="line">			<span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">				&#123;</span><br><span class="line">					q-&gt;next_ = p-&gt;next_;</span><br><span class="line">					<span class="keyword">delete</span> p; <span class="comment">//delete只是释放指针指向的内存，指针本身不改变 </span></span><br><span class="line">					p = q-&gt;next_;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					q = p;</span><br><span class="line">					p = p-&gt;next_;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 打印链表 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;p-&gt;data_&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">				p = p-&gt;next_;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//搜索</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			Node *p = head-&gt;next_;</span><br><span class="line">			<span class="keyword">while</span> (p!=<span class="literal">nullptr</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (p-&gt;data_==val)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					p = p-&gt;next_;	</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125; </span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">//指向链表的头节点 </span></span><br><span class="line">		Node *head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Clink c;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> val = <span class="built_in">rand</span>()%<span class="number">100</span>;</span><br><span class="line">		c.<span class="built_in">InsertHead</span>(val);</span><br><span class="line">		cout&lt;&lt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	c.<span class="built_in">InsertHead</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">InsertHead</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">InsertTail</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">show</span>();</span><br><span class="line">	c.<span class="built_in">RemoveAll</span>(<span class="number">23</span>);</span><br><span class="line">	c.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>数组：下标访问&#x2F;随机访问多、搜索</li>
<li>链表：增加、删除多<br>不过还是要看插入哪里，如果插入中间位置都是O(n)</li>
</ul>
<p><strong>后续我自己rewrite发现语法出问题</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">mylink</span>()&#123;</span><br><span class="line">			<span class="function">Node <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="comment">//head = new Node();</span></span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">mylink</span>()&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>我一开始写的是没有注释的 <em>Node head()</em> 这样程序无法运行，为什么呢？因为这是一个<strong>函数声明</strong>，返回值为Node的函数声明！<strong>并没有创造出对象！<strong>所以我们需要new一个对象出来！<br>而且不要</strong>空想一个头节点</strong>，题目如果给你链表是:1,2,3,4,5。那就是这样，第一个节点就是头节点。</p>
<ul>
<li>单链表逆序 <strong>头插法</strong></li>
<li>单链表求倒数第k个节点 <strong>双指针，第一个指针先移动k</strong></li>
<li>合并两个有序的单链表 <strong>双指针比较大小</strong></li>
<li></li>
<li></li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出</p>
<h3 id="栈接口"><a href="#栈接口" class="headerlink" title="栈接口"></a>栈接口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈 c++stack push,pop, </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqStack</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">SeqStack</span>(<span class="type">int</span> size = <span class="number">10</span>) : <span class="built_in">mtop</span>(<span class="number">0</span>),<span class="built_in">mcap</span>(size)</span><br><span class="line">		&#123;</span><br><span class="line">			mpStack = <span class="keyword">new</span> <span class="type">int</span>[mcap];</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">SeqStack</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> []mpStack;</span><br><span class="line">			mpStack = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//入栈 </span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mtop==mcap)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">expand</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			mpStack[mtop++] = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出栈</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mtop==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>;</span><br><span class="line">			mtop--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取栈顶元素</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (mtop==<span class="number">0</span>) <span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> mpStack[mtop<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//栈空</span></span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mtop==<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mtop;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[mcap*<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;mcap;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				p[i] = mpStack[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> []mpStack;</span><br><span class="line">			mpStack = p;</span><br><span class="line">			mcap = <span class="number">2</span>*mcap;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> *mpStack;</span><br><span class="line">		<span class="type">int</span> mtop; <span class="comment">//栈顶位置 </span></span><br><span class="line">		<span class="type">int</span> mcap; <span class="comment">//栈空间大小 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="function">SeqStack <span class="title">stack</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		stack.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	stack.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;stack.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		stack.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>环形队列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250413145914558.png"><br>不能用++，留下一个位置来判断是否为空</p>
<ul>
<li>入队:(rear+1)%length</li>
<li>出队（first+1）%length</li>
<li>满 (rear+1)%length &#x3D;first</li>
<li>空rear &#x3D; rear</li>
</ul>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><ul>
<li>冒泡排序：相邻两两元素比较，值大&#x2F;小的元素往下交换；缺点：数据交换次数太多</li>
<li>选择排序：每次在剩下的数据选择最大&#x2F;最小的数据和当前元素进行交换；缺点：交换次数仍然多</li>
<li>插入排序：**如果数据趋于有序，那么插入排序是所有排序算法中效率最高的算法！**插入排序效率&gt;冒泡&amp;&amp;选择，不仅没有交换，而且比较的次数也少。</li>
<li>希尔排序：插入排序PLUS，从全局先将数据调整为趋于有序。对数据<strong>进行分组插入排序</strong></li>
<li>快速排序：<strong>选取一个基准数</strong>，把小于基准数的元素放到基准数左边，大于基准数的元素放在右边；<strong>然后对基准数两边的序列进行同样的操作</strong>（递归）</li>
<li>归并排序: 二路归并</li>
<li></li>
</ul>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;arr.<span class="built_in">size</span>()-i<span class="number">-1</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&gt;arr[j<span class="number">+1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(arr[j],arr[j<span class="number">+1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> a: arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bubble</span>(arr);</span><br><span class="line">	<span class="built_in">show</span>(arr);</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>冒泡排序就是像气泡一样，慢慢往下沉或慢慢往上浮，j循环是数组的大小-i-1;对于函数传参，我们如果定义普通的数组的话，传(int arr[],int n)，数组名就是一个指针。<br>复杂度：<strong>外层循环O(n)，内层循环也是一个O(n)，O(n方)</strong><br>为什么j是size-1-i，因为<strong>a[j]要和a[j+1]来比较，所以有-1</strong>，每一次排序都会排好一个数，所以-i，第一次没排好，第二次排了1个少循环一次。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> maxIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i;j&lt;arr.<span class="built_in">size</span>();j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&gt;arr[maxIndex]) maxIndex = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i],arr[maxIndex]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存放<strong>最大值&#x2F;最小值的</strong>下标，比较结束后用下标来索引交换。<br>复杂度O(n)<em>O(n)，是一个*<em>不稳定的排序算法</em></em> &#x2F;&#x2F;5 5 3,第一个5和3交换后这个5跑去后面了。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> val = arr[i];</span><br><span class="line">		<span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val&gt;=arr[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[j<span class="number">+1</span>] = arr[j];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[j<span class="number">+1</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250413173038592.png"><br>为什么i要从1开始？因为之前的序列默认有序了，定义j在外面是为下面能成功访问j。<br>时间复杂度最坏O(n)*O(n)，最好O(n)；空间O(1)。稳定性好，</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> gap = arr.<span class="built_in">size</span>()/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = gap;i&lt;arr.<span class="built_in">size</span>();i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> val = arr[i];</span><br><span class="line">			<span class="type">int</span> j = i-gap;</span><br><span class="line">			<span class="keyword">for</span> (;j&gt;=<span class="number">0</span>;j-=gap)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (val&gt;=arr[j])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				arr[j+gap] = arr[j];</span><br><span class="line">			&#125;</span><br><span class="line">		arr[j+gap] = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n)*O(n)最坏，最好O(n)，不稳定。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> val = arr[l]; <span class="comment">//最左边的当作基准数</span></span><br><span class="line">	<span class="comment">//l == r的位置就是放基准数的位置 </span></span><br><span class="line">	<span class="keyword">while</span> (l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r &amp;&amp;arr[r] &gt; val)</span><br><span class="line">		&#123;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[l] = arr[r];</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;r&amp;&amp;arr[l]&lt;val)</span><br><span class="line">		&#123;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			arr[r] = arr[l];</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[l] = val;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> pos = <span class="built_in">Partition</span>(arr,begin,end);</span><br><span class="line">	<span class="built_in">QuickSort</span>(arr,begin,pos<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">QuickSort</span>(arr,pos<span class="number">+1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">QuickSort</span>(a,<span class="number">0</span>,a.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>函数传参的时候是要传起始位置，而不是具体的a[0]。<br>时间复杂度O(nlogn)，空间复杂度O(logn) 二叉树递归所占用的栈内存<br>是<strong>不稳定</strong>的排序</p>
<p>快速排序的优化</p>
<ul>
<li>排的越来越有序的时候，找一个合适的地方调用插入排序，因为插入排序是效率最高的当趋于有序的时候</li>
<li>采用<strong>三数取中</strong>法，L，R，Mid（（l+r）&#x2F;），取这三个数值在中间的数作为基准数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[mid]) <span class="built_in">swap</span>(arr[l], arr[mid]);</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[r]) <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[r]) <span class="built_in">swap</span>(arr[mid], arr[r]);</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[mid]); <span class="comment">// 将中位数放到最左边</span></span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">medianOfThree</span>(arr, l, r);</span><br><span class="line">    <span class="comment">// 原先 Partition 的逻辑保持不变</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; val) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[l++] = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; val) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[r--] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = val;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后的算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INSERTION_SORT_THRESHOLD = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianOfThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[mid]) <span class="built_in">swap</span>(arr[l], arr[mid]);</span><br><span class="line">    <span class="keyword">if</span> (arr[l] &gt; arr[r]) <span class="built_in">swap</span>(arr[l], arr[r]);</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[r]) <span class="built_in">swap</span>(arr[mid], arr[r]);</span><br><span class="line">    <span class="built_in">swap</span>(arr[l], arr[mid]); <span class="comment">// 中位数放到最左边</span></span><br><span class="line">    <span class="keyword">return</span> arr[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">medianOfThree</span>(arr, l, r);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r] &gt; val) r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[l++] = arr[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[l] &lt; val) l++;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) arr[r--] = arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = val;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= l &amp;&amp; arr[j] &gt; key) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin + <span class="number">1</span> &lt;= INSERTION_SORT_THRESHOLD) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">Partition</span>(arr, begin, end);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, begin, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, pos + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HybridSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">QuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">InsertionSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含了三数取中 + 插入排序的优化。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414121639433.png"><br>归 ： 递归 要先递，才能归。<br>并 ： 合在一起<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414122146161.png"><br>递归到结束（<strong>每个子树都只有一个元素</strong>）后要进行合并，合并要开辟新的内存空间，直到所有的子树都能合并起来，要一直开辟内存，很耗内存。<br><strong>要递归的时候函数传参需要传起始位置和终止位置，就像快排那样传参</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(vector &lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[r-l<span class="number">+1</span>];  <span class="comment">//38 62 99     75 81   4-0+1=5</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = l;</span><br><span class="line">	<span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i]&lt;=arr[j])</span><br><span class="line">		&#123;</span><br><span class="line">			p[index++] = arr[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p[index++] = arr[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">	&#123;</span><br><span class="line">		p[index++] = arr[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		p[index++] = arr[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//再把合并好的大段有序结果，拷贝回arr[r,l]区间内 </span></span><br><span class="line">	<span class="keyword">for</span> (i = l,j = <span class="number">0</span>;i &lt;=r;i++,j++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = p[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> []p;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr,<span class="type">int</span> begin,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (begin&gt;=end) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//要先进行递，才能进行归</span></span><br><span class="line">	<span class="type">int</span> mid = (begin + end)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr,begin,mid);</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr,mid + <span class="number">1</span>,end);</span><br><span class="line">	<span class="comment">//再归并，把两个小段有序的序列合并成大段</span></span><br><span class="line">	<span class="built_in">Merge</span>(arr,begin,mid,end); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MergeSort</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是一个稳定的算法</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h4 id="二叉堆-大根堆-小根堆"><a href="#二叉堆-大根堆-小根堆" class="headerlink" title="二叉堆&amp;大根堆&amp;小根堆"></a>二叉堆&amp;大根堆&amp;小根堆</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414125441474.png"><br><strong>完全二叉树的最后一层叶子节点</strong>靠左排列，用数组存放的数在逻辑上可以被视为完全二叉树，2i+<br>1和2i+2<br>大根堆和小根堆只是基于二叉堆的基础规定了当前节点和两个孩子节点值的大小关系。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250414125908109.png"></p>
<ul>
<li><p>叶子节点（树枝的末端，没有子节点）找到第一个非叶子节点：(末位元素下标-1)&#x2F;2</p>
</li>
<li><p>大根堆：arr[i] &gt; arr[i<em>2+1]&amp;&amp;arr[i] &gt; arr[i</em>2+2]</p>
</li>
<li><p>小根堆：arr[i] &lt; arr[i<em>2+1]&amp;&amp;arr[i] &lt; arr[i</em>2+2]<br>操作堆的时候像队列&#x2F;栈一样，只能操作堆顶元素</p>
</li>
<li><p>STL里的sort算法用的是什么排序？<br>快速排序 + 插入排序 （32的时候转为插入） + 堆排序（递归深度过深）</p>
</li>
<li><p>快速排序的时间复杂度不是稳定的nlogn，如何解决恶化问题<br>1.转插入排序 2.三数取中，选择合适的基准数</p>
</li>
<li><p>递归过深会引发什么问题？<br>函数开销变大，导致栈内存溢出，程序挂掉</p>
</li>
<li><p>怎么控制递归深度？如果达到递归深度了还没排完序怎么办？<br>转换成非递归的排序方式，如堆排序，好坏都是nlogn。</p>
</li>
</ul>
<h4 id="二叉堆代码"><a href="#二叉堆代码" class="headerlink" title="二叉堆代码"></a>二叉堆代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PriorityQueue</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:<span class="comment">//using是定义类型别名，这里定义了一个Comp的比较大小函数 </span></span><br><span class="line">		<span class="keyword">using</span> Comp = function&lt;<span class="built_in">bool</span>(<span class="type">int</span>,<span class="type">int</span>)&gt;; </span><br><span class="line">		<span class="built_in">PriorityQueue</span>(<span class="type">int</span> cap = <span class="number">20</span>,Comp comp = <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) <span class="comment">//默认大根堆 </span></span><br><span class="line">			:<span class="built_in">size_</span>(<span class="number">0</span>)</span><br><span class="line">			,<span class="built_in">cap_</span>(cap)</span><br><span class="line">			,<span class="built_in">comp_</span>(comp)</span><br><span class="line">			&#123;</span><br><span class="line">				que_ = <span class="keyword">new</span> <span class="type">int</span>[cap];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">PriorityQueue</span>(Comp comp) <span class="comment">//小根堆，通过传比较器对象实现 </span></span><br><span class="line">			:<span class="built_in">size_</span>(<span class="number">0</span>)</span><br><span class="line">			,<span class="built_in">cap_</span>(<span class="number">20</span>)</span><br><span class="line">			,<span class="built_in">comp_</span>(comp)</span><br><span class="line">			&#123;</span><br><span class="line">				que_ = <span class="keyword">new</span> <span class="type">int</span>[cap_];</span><br><span class="line">			&#125;</span><br><span class="line">		~<span class="built_in">PriorityQueue</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> []que_;</span><br><span class="line">			que_ = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//入堆</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (size_==cap_)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*cap_];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;cap_;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					p[i] = que_[i];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">delete</span> []que_;</span><br><span class="line">				que_ = p;</span><br><span class="line">				cap_ = <span class="number">2</span>*cap_;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (size_==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//只有一个元素不用上浮调整。 </span></span><br><span class="line">				que_[size_] = val; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//有多个元素，插入位于大小位置的下标 </span></span><br><span class="line">				<span class="built_in">ShiftUp</span>(size_,val);</span><br><span class="line">			&#125;</span><br><span class="line">			size_++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (size_ == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">&quot;The container is empty&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			size_--;</span><br><span class="line">			<span class="keyword">if</span> (size_ &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//删除堆顶元素，还有剩余的元素，进行下沉</span></span><br><span class="line">				<span class="built_in">ShiftDown</span>(<span class="number">0</span>,que_[size_]); </span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> size_==<span class="number">0</span>;&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> que_[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> size_;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">ShiftUp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (i &gt; <span class="number">0</span>) <span class="comment">//最多计算到根节点 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> father = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">comp_</span>(val,que_[father]))</span><br><span class="line">				&#123;</span><br><span class="line">					que_[i] = que_[father];</span><br><span class="line">					i = father;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			que_[i] = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">ShiftDown</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (i&lt;size_/<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> child = <span class="number">2</span>*i <span class="number">+1</span>;</span><br><span class="line">				<span class="keyword">if</span> (child + <span class="number">1</span> &lt;size_&amp;&amp;<span class="built_in">comp_</span>(que_[child<span class="number">+1</span>],que_[child]))</span><br><span class="line">				&#123;</span><br><span class="line">					child = child + <span class="number">1</span>; <span class="comment">//如果右孩子的值大于左孩子，child记录右孩子的下标</span></span><br><span class="line">					 </span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">comp_</span>(que_[child],val))</span><br><span class="line">				&#123;</span><br><span class="line">					que_[i] = que_[child];</span><br><span class="line">					i = child;</span><br><span class="line">				 &#125;</span><br><span class="line">				 <span class="keyword">else</span></span><br><span class="line">				 &#123;</span><br><span class="line">				 	<span class="keyword">break</span>; <span class="comment">//已经满足了堆的性质，提前出 </span></span><br><span class="line">				 &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			que_[i] = val;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> *que_; <span class="comment">//指向动态扩容的数组 </span></span><br><span class="line">		<span class="type">int</span> size_; <span class="comment">//元素个数</span></span><br><span class="line">		<span class="type">int</span> cap_; <span class="comment">//数组的总空间大小</span></span><br><span class="line">		Comp comp_; <span class="comment">//比较器对象 </span></span><br><span class="line">		</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//PriorityQueue que; //第一个构造函数 </span></span><br><span class="line">	<span class="function">PriorityQueue <span class="title">que</span><span class="params">([](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&lt;b;&#125;)</span></span>;<span class="comment">//第二个构造函数 </span></span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">30</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		que.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;que.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>快速的查询时要第一时间想到哈希表。</p>
<ul>
<li>有序的关联容器：set\map （红黑树实现，O(logn)）</li>
<li>无序的关联容器：unordered_set\unordered_map （哈希表O(1)）</li>
</ul>
<h3 id="通过哈希函数（除留余数法实现）"><a href="#通过哈希函数（除留余数法实现）" class="headerlink" title="通过哈希函数（除留余数法实现）"></a>通过哈希函数（除留余数法实现）</h3><ul>
<li>如何解决哈希冲突？<br>1.线性探测法 2.链地址法<br>3.设置哈希表的长度为素数，可以尽可能的减少哈希冲突</li>
<li><pre><code>如果你长度为8，有很多能mod8的数都会被存到同一个位置；如果是素数，则会减少一些。
</code></pre>
</li>
</ul>
<p>4.设置哈希表装载因子（已用个数&#x2F;容量）</p>
<ul>
<li>一般是0.75，超过了0.75后就要将哈希表<strong>扩容</strong>，扩容会从素数表里面找下一个质数作为新的容量，原来哈希表中的元素需要在新的哈希表中<strong>重新哈希</strong></li>
</ul>
<p>查找<br>未发生哈希冲突 O(1) 比如18%7 &#x3D; 4，去看arr[4]有无18；如果发生了哈希冲突，就要往后去遍历，O(n)可能是线性探测.<br>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">	STATE_UNUSE, </span><br><span class="line">	STATE_DELETE, <span class="comment">//在哈希表中，我们删除元素不用置成0，而是设置状态 </span></span><br><span class="line">	STATE_USING,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不要用vector，vector会自动扩容，我们自己用指针来 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bucket</span>&#123;</span><br><span class="line">	<span class="built_in">Bucket</span>(<span class="type">int</span> key = <span class="number">0</span>,State state = STATE_UNUSE)</span><br><span class="line">		:<span class="built_in">key_</span> (key),<span class="built_in">state_</span>(state)&#123;&#125;</span><br><span class="line">	<span class="type">int</span> key_; <span class="comment">//存储的数据 </span></span><br><span class="line">	State state_; <span class="comment">//桶的当前状态 </span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个类，先去处理成员变量 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">HashTable</span>(<span class="type">int</span> size = primes_[<span class="number">0</span>],<span class="type">double</span> LoadFactor = <span class="number">0.75</span>)</span><br><span class="line">			:<span class="built_in">useBucketNum_</span>(<span class="number">0</span>)</span><br><span class="line">			,<span class="built_in">loadFactor_</span>(LoadFactor)</span><br><span class="line">			,<span class="built_in">primeIdx_</span>(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//把用户传入的size调整到最近的比较大的素数上（因为用户可能传入非素数）	</span></span><br><span class="line">			<span class="keyword">if</span> (size != primes_[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (;primeIdx_&lt;PRIME_SIZE;primeIdx_++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (primes_[primeIdx_]&gt;size)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (primeIdx_ == PRIME_SIZE)</span><br><span class="line">					&#123;</span><br><span class="line">						primeIdx_--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			tableSize_ = primes_[primeIdx_];</span><br><span class="line">			table_ = <span class="keyword">new</span> Bucket[tableSize_];</span><br><span class="line">		&#125;</span><br><span class="line">		~<span class="built_in">HashTable</span>()</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> []table_;</span><br><span class="line">			table_ = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">double</span> factor = useBucketNum_*<span class="number">1.0</span> / tableSize_;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;factor:&quot;</span>&lt;&lt;factor&lt;&lt;endl;</span><br><span class="line">			<span class="keyword">if</span> (factor &gt; loadFactor_)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">expand</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="type">int</span> idx = key % tableSize_;</span><br><span class="line">		<span class="type">int</span> i = idx;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (table_[i].state_!=STATE_USING)</span><br><span class="line">			&#123;</span><br><span class="line">				table_[i].state_ = STATE_USING;</span><br><span class="line">				table_[i].key_ = key;</span><br><span class="line">				useBucketNum_++;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			i = (i + <span class="number">1</span>)%tableSize_;</span><br><span class="line">		&#125;<span class="keyword">while</span> (i!=idx);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			if (table_[idx].state_!= STATE_USING)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				table_[idx].state_ = STATE_USING;</span></span><br><span class="line"><span class="comment">				table_[idx].key_ = key;</span></span><br><span class="line"><span class="comment">				return true;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			//如果第一个位置是被using的，那就从idx往下找，让数组成环 </span></span><br><span class="line"><span class="comment">			for (int i = (idx+1)%tableSize_;i!=idx;i=(i+1)%tableSize_)</span></span><br><span class="line"><span class="comment">			&#123;</span></span><br><span class="line"><span class="comment">				if (table_[i].state_!=STATE_USING)</span></span><br><span class="line"><span class="comment">				&#123;</span></span><br><span class="line"><span class="comment">						</span></span><br><span class="line"><span class="comment">				&#125; 		</span></span><br><span class="line"><span class="comment">			&#125;*/</span></span><br><span class="line">			<span class="comment">//代码重复冗余，用dowhile优化，因为一开始就要做一次判断 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> idx = key % tableSize_;</span><br><span class="line">			<span class="type">int</span> i = idx;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (table_[i].state_==STATE_USING&amp;&amp;table_[i].key_==key)</span><br><span class="line">				&#123;</span><br><span class="line">					table_[i].state_ = STATE_DELETE;</span><br><span class="line">					useBucketNum_--;</span><br><span class="line">				&#125;</span><br><span class="line">				i = (i<span class="number">+1</span>)%tableSize_;</span><br><span class="line">			&#125;<span class="keyword">while</span> (table_[i].state_!=STATE_UNUSE&amp;&amp;i !=idx ); <span class="comment">//遇到了unuse说明发生冲突后也没往后插了 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="type">int</span> idx = key % tableSize_;</span><br><span class="line">			<span class="type">int</span> i = idx;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (table_[i].state_==STATE_USING&amp;&amp;table_[i].key_==key)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				i = (i<span class="number">+1</span>)%tableSize_;</span><br><span class="line">			&#125;<span class="keyword">while</span> (table_[i].state_!=STATE_UNUSE &amp;&amp; i != idx); <span class="comment">//遇到了unuse说明发生冲突后也没往后插了 </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			++primeIdx_;</span><br><span class="line">			<span class="keyword">if</span> (primeIdx_ == PRIME_SIZE)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">&quot;HashTable is large enought and it can&#x27;t be expanded&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Bucket *newTable = <span class="keyword">new</span> Bucket[primes_[primeIdx_]];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;tableSize_;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (table_[i].state_==STATE_USING) <span class="comment">//旧表中有效的数据重新哈希 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> idx = table_[i].key_ % primes_[primeIdx_];</span><br><span class="line">					<span class="type">int</span> k = idx;</span><br><span class="line">					<span class="keyword">do</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> (newTable[k].state_!=STATE_USING)</span><br><span class="line">						&#123;</span><br><span class="line">							newTable[k].state_ = STATE_USING;</span><br><span class="line">							newTable[k].key_ = table_[i].key_;</span><br><span class="line">							<span class="keyword">break</span>; </span><br><span class="line">						&#125;</span><br><span class="line">						k = (k<span class="number">+1</span>) % primes_[primeIdx_];</span><br><span class="line">					&#125; <span class="keyword">while</span>(k!=idx);</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> []table_;</span><br><span class="line">			table_ = newTable;</span><br><span class="line">			tableSize_ = primes_[primeIdx_];</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Bucket *table_; <span class="comment">//指向动态开辟的哈希表</span></span><br><span class="line">		<span class="type">int</span> tableSize_; <span class="comment">//哈希表的长度</span></span><br><span class="line">		<span class="type">int</span> useBucketNum_; <span class="comment">//已经使用的桶的数量</span></span><br><span class="line">		<span class="type">double</span> loadFactor_; <span class="comment">//装载因子</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PRIME_SIZE = <span class="number">10</span>;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> primes_[PRIME_SIZE];<span class="comment">//素数表</span></span><br><span class="line">		<span class="type">int</span> primeIdx_; <span class="comment">//当前素数的下标  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> HashTable::primes_[PRIME_SIZE] = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">47</span>,<span class="number">97</span>,<span class="number">251</span>,<span class="number">443</span>,<span class="number">911</span>,<span class="number">1471</span>,<span class="number">42773</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HashTable htable;</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">21</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">15</span>);</span><br><span class="line">	htable.<span class="built_in">insert</span>(<span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;htable.<span class="built_in">find</span>(<span class="number">14</span>)&lt;&lt;endl;</span><br><span class="line">	htable.<span class="built_in">erase</span>(<span class="number">14</span>);</span><br><span class="line">	cout&lt;&lt;htable.<span class="built_in">find</span>(<span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h3><h4 id="查重"><a href="#查重" class="headerlink" title="查重"></a>查重</h4><p>查重或者统计重复的次数，查询的<strong>效率高</strong>但是<strong>占用内存空间较大</strong>。<br>找<strong>第一个重复出现的数字</strong><br>用unordered_set来查，先遍历数组，然后用find函数去查询是否哈希表里是否存在有这个数（find返回的是迭代器的值，如果没找到就返回哈希表的末尾）如果没有就会insert，有的话就会输出。切记，在map和set这里尽量都用auto，不要用下标访问。<br><strong>找第一个和找所有的其实就是加不加break</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unordered_set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> val : a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> it = s.<span class="built_in">find</span>(val);</span><br><span class="line">		<span class="keyword">if</span> (it!=s.<span class="built_in">end</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;*it;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> s.<span class="built_in">insert</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找所有重复出现的元素以及重复的次数，用unordered_map，没找到，就把这个数字插入（用emplace方法），找到了，迭代器的second++（值++）；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">10000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	unordered_map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> p : a)</span><br><span class="line">	&#123;</span><br><span class="line">		m[p]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> q : m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (q.second&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;q.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q.second&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h4><p>top K问题：大小根堆来过滤，大根堆过滤前top k小的数据；小根堆过滤前top k大的数据<br>用<strong>大根堆</strong>来找前k个最小的元素；用<strong>小根堆</strong>来找前k个最大的元素。<br>64 45 52 80 66 68 0 2 18 75<br>这十个先把前三个数组成一个大根堆，然后到第四个80，80比堆顶元素64大，说明一定比这个堆里的所有元素都大，所以往下继续找，一直到0，0比堆顶元素小，我们就调整，依次这样。<br>最后复杂度为logk * O(n)但是logk是常数级，所以最终我们以O(n)复杂度的找到topK元素。</p>
<p>快排分割法。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="BST树（Binary-Search-Tree-二叉搜索树）"><a href="#BST树（Binary-Search-Tree-二叉搜索树）" class="headerlink" title="BST树（Binary Search Tree 二叉搜索树）"></a>BST树（Binary Search Tree 二叉搜索树）</h3><ul>
<li>对于二叉树上的每一个节点：<strong>左孩子的值&lt;父节点的值&lt;右孩子的值</strong></li>
<li>每一层的节点最多的个数2^(L-1)，第三层就是4个，第四层就是8个；</li>
<li>所有节点的个数N与层数的关系：等比数列求和 &#x3D; 2^L-1 &#x3D; N，2^L &#x3D; N+1，两边取对数L &#x3D; log2N</li>
</ul>
<h4 id="BST的删除操作"><a href="#BST的删除操作" class="headerlink" title="BST的删除操作"></a>BST的删除操作</h4><ul>
<li>1.没有孩子的节点 父节点地址域为nullptr</li>
<li>2.有一个孩子 孩子写入父节点地址域</li>
<li>3.删除的节点有两个孩子 ：找待删除	节点的<strong>前驱节点或后继节点</strong>，用前驱&#x2F;后继将要删除的节点值覆盖掉，然后直接删除前驱&#x2F;后继就可以了。<br>前驱：左子树里最大的 后继：右子树里最小的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250418100102229.png"></li>
</ul>
<h3 id="二叉树的递归操作"><a href="#二叉树的递归操作" class="headerlink" title="二叉树的递归操作"></a>二叉树的递归操作</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250418111746902.png"><br>左右根</p>
<h4 id="基于后序遍历，使用递归操作来判断树的层数"><a href="#基于后序遍历，使用递归操作来判断树的层数" class="headerlink" title="基于后序遍历，使用递归操作来判断树的层数"></a>基于后序遍历，使用递归操作来判断树的层数</h4><p>int GetL(Node *node)<br>{<br>	if (node!&#x3D;nullptr)<br>	{<br>		PostOrder(node-&gt;left);<br>		PostOrder(node-&gt;right);<br>		return left &gt; right ? left + 1: right + 1;<br>	}<br>}</p>
<h4 id="基于后序遍历递归操作求层数，可以用来求节点的个数"><a href="#基于后序遍历递归操作求层数，可以用来求节点的个数" class="headerlink" title="基于后序遍历递归操作求层数，可以用来求节点的个数"></a>基于后序遍历递归操作求层数，可以用来求节点的个数</h4><p>int num(Node *node)<br>{<br>	if (node &#x3D;&#x3D; nullptr) return 0;<br>	int left &#x3D; num(node-&gt;left);<br>	int right &#x3D; num(node-&gt;right);<br>	return left + right +1;	<br>}</p>
<h2 id="五大算法"><a href="#五大算法" class="headerlink" title="五大算法"></a>五大算法</h2><h3 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h3><p>算法思想：在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根节点出发深度搜索解空<br>间树。当搜索到某一节点时，要先判断该节点是否包含问题的解，如果包含就从该节点出发继续深度搜<br>索下去，否则逐层向上回溯。一般在搜索的过程中都会添加相应的剪枝函数，避免无效解的搜索，提高<br>算法效率。<br>解空间：解空间就是所有解的可能取值构成的空间，一个解往往包含了得到这个解的每一步，往往就是<br>对应解空间树中一条从根节点到叶子节点的路径。子集树和排列树都是一种解空间，它们不是真实存在<br>的数据结构，也就是说并不是真的有这样一颗树，只是抽象出的解空间树。<br>其实很像二叉树的遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">func</span>(arr, i + <span class="number">1</span>, length);</span><br><span class="line">		<span class="built_in">func</span>(arr, i + <span class="number">1</span>, length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">func</span>(arr, <span class="number">0</span>, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子集树，其实就是递归选路径，需要一个辅助数组子集树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i,<span class="type">int</span> length, <span class="type">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (x[j]==<span class="number">1</span>) cout &lt;&lt; arr[j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*x[i] = 1; //选这条路</span></span><br><span class="line"><span class="comment">		func(arr, i + 1, length,x);</span></span><br><span class="line"><span class="comment">		x[i] = 0; //不选这条路</span></span><br><span class="line"><span class="comment">		func(arr, i + 1, length,x);*/</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">		&#123;</span><br><span class="line">			x[i] = k;</span><br><span class="line">			<span class="built_in">func</span>(arr,i<span class="number">+1</span>,length,x);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2025/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h2><p>有三个主要部分：<strong>虚拟化（virtualization）</strong>、<strong>并发（concurrency）</strong>、<strong>持久性（persistence）</strong></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一、（共10分）操作系统的设计目标有哪些？</p>
<ul>
<li>抽象性：对硬件资源进行抽象，提供统一接口，简化程序开发；</li>
<li>并发性：支持多个程序同时运行，提高系统吞吐；</li>
<li>虚拟化：如虚拟内存、虚拟 CPU，使用户感觉拥有独占资源；</li>
<li>资源管理与调度：高效分配 CPU、内存、磁盘等资源，提升资源利用率；</li>
<li>安全与保护：防止程序互相干扰，保护用户数据；</li>
<li>用户友好性：提供简洁易用的接口和良好的使用体验。</li>
</ul>
<p>六、（ 共 10 分）UNIX 系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：<br>fork()和 exec()，解释说明 fork()和 exec()的作用（5 分），以 UNIX 的 Shell 为例说明为什么设<br>计这两个系统调用（5分）。 </p>
<ul>
<li>fork()创建一个和父进程几乎相同的子进程，除了PID等一些信息不同其它完全一样。</li>
<li>exec()用新的程序替换掉当前程序执行的内容，不改变其PID等信息。<br>UNIX SHELL启动一个新程序的时候，先通过fork()创建一个子进程，再通过exec()加载并执行用户命令，这样父进程（shell）仍能工作，分离设计提供灵活性。</li>
</ul>
<p>七、操作系统虚拟化CPU的机制是受限直接执行，为了实现这个机制，例举的硬件提供了哪些支持？简要说明操作系统如何利用硬件来实现LDE。<br>硬件</p>
<ul>
<li>模式划分：被划分为用户态和内核态</li>
<li>中断机制：支持外设中断和系统调用陷入内核态。</li>
<li>定时器中断：防止单一进程长时间占用CPU资源，实现抢占功能。</li>
<li>内存保护机制：通过页表和地址空间隔离来保护内核</li>
<li>指令限制：一些特权指令如（I&#x2F;O）只能被内核态执行。</li>
</ul>
<p>操作系统可以将进程调度执行化为内核态以及用户态，用户态不能执行一些特权指令比如I&#x2F;O，必须通过陷阱表的陷阱指令陷入内核态，并提供了从陷入返回指令回到用户态。操作系统还提供了中断机制，防止单一进程过度占用资源，而导致其他进程出现饥饿。结合内存保护，防止非法访问内核或其他进程内存区域，从而实现虚拟化CPU且保证系统安全和稳定。还有上下文切换，通过寄存器保存当前进程的值，然后读取另一个进程的寄存器所存储的值进行运行。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250419221319250.png"><br>1.三态：运行、就绪、阻塞<br>2.错误，进程在一个时刻只能处于一种状态。<br>3.错误，单核情况下，操作系统和进程需要通过时间片轮转轮流使用CPU，不会同时运行，操作系统也是一个程序。</p>
<h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h3><p>正在运行的程序会做一件非常简单的事情：从内存中读取指令，解码，并执行它，然后接着执行下一条指令。<br>总结为Fetch 、 Decode 、 Execute</p>
<p><strong>操作系统</strong>可以让程序<strong>共享内存</strong>、<strong>与设备交互</strong>、<strong>运行的更容易</strong>，操作系统确保系统既易于使用、又正确高效运行。为了做到这一点，采用了<strong>虚拟化</strong>的技术，在一些硬件的帮助下，操作系统负责提供虚拟化，使得<strong>单个（或一小部分）CPU可以看似认为有无限数量的CPU</strong>，从而可以同时运行多个程序，但问题就是在<strong>调度</strong>，在特定时间运行，该运行哪个？所以操作系统也承担了**资源管理器（resource manager）**的角色。</p>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><ul>
<li><p>虚拟内存，每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，打游戏的时候每个角色都有一个背包，背包的0号格子可能装有不同的东西，但并没有冲突，操作系统把编号0分到了不同的内存地址上。<br>每个程序都有自己的“背包”（内存空间），从地址 0 开始。但实际的物理内存只有一块<br>程序 A 的地址 0x1000 → 实际是 物理地址 0xA000<br>程序 B 的地址 0x1000 → 实际是 物理地址 0xC000<br>这就是虚拟内存：给程序看的假地址，每个程序都以为自己独占整片内存，其实操作系统做了“背后映射”。</p>
</li>
<li><p>操作系统通过<strong>时间片轮转（time-sharing）<strong>技术虚拟化 CPU，将 CPU 时间划分成小片段，每次只分配给一个进程运行一个时间片，然后切换到其他进程，从而营造出“多个进程同时运行”的假象。这种时分复用机制使得单核 CPU 也能实现多任务并发。其代价是</strong>频繁的上下文切换带来一定的性能开销</strong>。</p>
</li>
<li><p>进程三态：运行、阻塞、就绪</p>
</li>
<li><p>fork()系统调用的返回值：<strong>父进程获得子进程的PID，子进程的返回值是0</strong></p>
</li>
</ul>
<h3 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h3><p>有两种模式：用户模式和内核模式，用户模式下功能受限，如I&#x2F;O请求无法发送，但可以通过<strong>特殊的陷阱（trap）指令</strong>从用户模式进入内核模式，进入内核后系统就可以执行任何需要的特权操作，执行完成后，操作系统调用一个特殊的从陷阱返回(return-from-trap)指令回到用户模式。</p>
<h3 id="多级反馈队列MLFQ"><a href="#多级反馈队列MLFQ" class="headerlink" title="多级反馈队列MLFQ"></a>多级反馈队列MLFQ</h3><p>五条规则</p>
<ul>
<li>任务A的优先级高于任务B，先执行任务A，再执行任务B（保证高优先级任务的响应速度，提高系统的实时性。）</li>
<li>任务A的优先级等于任务B，以轮询的方式执行任务A、B（在同等级中实现公平性，防止个别任务长期占用CPU。）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420102050486.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420102132273.png" alt="Round-Robin"></li>
<li>新任务进入队列，放在最高优先级的队列执行（提高新任务启动速度，增强系统交互性。）</li>
<li>一旦工作用完了其在某一层中的时间配额，无论中间主动放弃了多少次CPU，就降低其优先级。（避免任务通过频繁放弃CPU来“欺骗”调度器长期占用高优先级。）</li>
<li>经过一段时间S后，就将所有任务重新加入到最高优先级（避免低优先级任务长时间得不到执行，防止饥饿现象。）</li>
</ul>
<h3 id="调度-比例份额"><a href="#调度-比例份额" class="headerlink" title="调度-比例份额"></a>调度-比例份额</h3><p>彩票数(ticket)代表了进程(或用户或其他)占有某个资源的份额，一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。拥有的彩票数越多，那被调度的概率也就越大。<br>三大特性：</p>
<ul>
<li>彩票货币</li>
<li>彩票转让：一个进程临时将自己的彩票转移给另一个进程</li>
<li>彩票通胀：一个进程的彩票数可以临时提升或降低告诉操作系统我需要CPU。</li>
</ul>
<p>步长调度：其实就是时间片轮转，执行完当前的步长然后去看看队列中现在谁的总步长最短，就去执行它，如果所有人的步长都相同了，那就随机抽一个去执行。</p>
]]></content>
  </entry>
  <entry>
    <title>cpp基础核心内容</title>
    <url>/2025/04/20/cpp%E5%9F%BA%E7%A1%80%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="三块核心内容"><a href="#三块核心内容" class="headerlink" title="三块核心内容"></a>三块核心内容</h2><h3 id="进程虚拟地址空间区域划分"><a href="#进程虚拟地址空间区域划分" class="headerlink" title="进程虚拟地址空间区域划分"></a>进程虚拟地址空间区域划分</h3><p>有四区</p>
<ol>
<li>代码区(.text) 存放程序的机器指令，通常是<strong>只读的</strong></li>
<li>数据段(.data) 存放<strong>已初始化的全局变量和静态变量</strong></li>
<li>BSS段 存放<strong>未初始化</strong>的<strong>全局变量和静态变量</strong>，操作系统在运行前会帮助自动初始化为0</li>
<li>堆栈区(Heap and Stack) <ul>
<li>堆区：程序运行时动态分配的内存(new 和 malloc)，由程序员管理</li>
<li>栈区：函数调用时使用的内存，存放局部变量和返回地址，由系统自动分配和释放<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250420233311321.png"></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>；</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三条是其实是汇编的mov指令，存放在.text区，而main函数调用的时候会在栈开辟空间。</p>
<h3 id="函数调用堆栈详细过程"><a href="#函数调用堆栈详细过程" class="headerlink" title="函数调用堆栈详细过程"></a>函数调用堆栈详细过程</h3><h3 id="程序编译链接原理"><a href="#程序编译链接原理" class="headerlink" title="程序编译链接原理"></a>程序编译链接原理</h3><p>预处理-编译-汇编-链接</p>
<ol>
<li>预处理 处理#include 之类的，除了#pragma lib和#pragma link，这两个是在链接时处理。</li>
<li>编译 gcc &#x2F; g++（gcc用来编译c语言，g++用来编译c++，其实就是dev中的F9，只不过现在换成命令行形式）  在<strong>编译的过程中符号不分配虚拟地址</strong>，在链接分配。</li>
<li>汇编 <strong>符号表的生成</strong>，生成.o文件。.o文件为目标文件（Object File），目标文件是一个二进制文件，文件的格式是ELF(executable and linkable file)</li>
<li>链接 将各个段合并（比如main.o和sum.o）生成可执行文件，Linux下是.out&#x2F;Windows下是.exe<ul>
<li>步骤一：所有的.o文件段合并，符号表合并后，进行<strong>符号解析</strong>（要找到所有符号表引用的定义）。</li>
<li>步骤二：符号的重定向（让<em>UND</em>找到初始定义的位置）<strong>这是链接的核心</strong>，符号解析成功后，给所有的符号分配虚拟地址！</li>
</ul>
</li>
</ol>
<p>g++&#x2F;gcc语法</p>
<ul>
<li>gcc -c &#x2F; g++ -c  是编译 compile<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421103629431.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421103540512.png"><br>使用objdump -t查看<strong>符号表</strong>（t - table）<br>使用cat查看文件内容</li>
<li>在main.cpp中，我们看的定义gdata是一个外部引用的变量，sum是声明，看main.o的符号表，他们并不是没有符号，符号是<em>UND</em>(undefined)，这个意思是：<strong>我现在在当前代码上用到他们了，但是我却不知道他们是怎么定义的</strong>，UND是对于<strong>符号的引用</strong>，有确定数据段的是<strong>符号的定义</strong>需要在链接这一部分才能让他们找到“家”，main函数放在.text代码段上，我们定义了data，所以data放在了.data段</li>
<li>在sum.o中，因为sum.cpp定义好了每一个位置，所以符号表都有。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421110002638.png"><br>文件头，main.o 。 .o文件就是由<strong>各种各样的段</strong>来组成的<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421110042215.png"><br>可以使用objdump -s xxx.o查看段的信息<br>ld是链接器，负责链接。</li>
<li>ELF文件头记录着文件的<strong>入口点地址</strong>，程序就知道从第几行开始执行了。</li>
</ul>
<p>总结 a.out和.o文件都是由各种段组成的，但区别在a.out多了一个#program headers段，有两个load，告诉程序在运行的时候需要加载哪些数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250421112526387.png"></p>
<h2 id="C-基础部分"><a href="#C-基础部分" class="headerlink" title="C++基础部分"></a>C++基础部分</h2><h3 id="形参带默认值的函数"><a href="#形参带默认值的函数" class="headerlink" title="形参带默认值的函数"></a>形参带默认值的函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a = <span class="number">20</span>, <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">	cout &lt;&lt; ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码是错误的，因为在函数传参压入栈的时候，参数是由右往左压，现在b没有默认值，所以是错的，如果定义b为20，a不定义，代码是正确的。代码顺序：<strong>从上到下，从右到左给默认值</strong></p>
<h3 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h3><p>&#x2F;* inline内联函数和普通函数的区别？？？</p>
<ul>
<li>inline内联函数：在编译过程中，就<strong>没有函数的调用开销</strong>了，在函数的调用点直接<strong>把函数的代码进行展开处理</strong></li>
<li>inline函数不再生成相应的函数符号（objdump -t）</li>
<li>inline只是建议编译器把这个函数处理成内联函数，但是不是所有的inline都会被编译器处理成内联函数，比如递归，如果有符号说明没有内敛</li>
<li>debug版本上，inline是不起作用的；inline只有在release版本下才能出现<br>*&#x2F;<br>函数调用的过程：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="number">3.</span> <span class="type">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">	cout &lt;&lt; ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，第三行参数从右向左压栈，然后调用<strong>call</strong>指令，call 会把返回地址（main 函数中调用 sum 后的下一条指令）压入栈顶，然后跳转到 sum。要开辟函数栈帧，栈帧包含：返回地址、保存的寄存器、局部变量空间、对齐填充等。调用完后栈帧销毁，返回地址出栈，跳回 main 继续执行。虽然就是简简单单的x+y操作（三行汇编：mov add mov），但是如果循环了100000次呢？每一次都要这样开辟，很耗内存。<br>inline int sum(int x,int y)<br>{<br>    return x+y;<br>}<br>inline函数<strong>建议</strong>编译器内联展开函数（这是个建议，而不是强制），比如在第三行，很有可能编译成int ret &#x3D; a+b而不是调用函数。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>&#x2F;*</p>
<ol>
<li>c++为什么支持函数重载，c语言不支持函数重载<ul>
<li>C++代码产生函数符号的时候，是由函数名+参数列表组成的；C产生函数符号的时候，只由函数名组成。<br> 可以理解为C++：cmp_int_int &#x2F; cmp_double_double &#x2F; cmp_char *_char *，而c就会发生链接错误。</li>
</ul>
</li>
<li>函数重载需要注意什么</li>
<li>c++和c语言代码之间如何互相调用 （为何无法调用？因为函数符号不同，一个有列表一个没列表，会无法连接，<em>UND</em>）<ul>
<li>C调用C++：无法直接调用，把c++源码扩在extern “C”</li>
<li>C++调用C：把C函数的声明扩在extern “C”中<br>*&#x2F;<br>什么是重载函数？</li>
</ul>
</li>
<li>一组函数，其中函数名相同，参数列表的<strong>个数或类型不同</strong>，那么这一组函数就称为 函数重载</li>
<li>一组函数要称得上重载，一定先是处在同一个作用域中。</li>
<li>const &#x2F; volatile,是怎么影响形参类型的。</li>
<li>一组函数，函数名相同，参数列表也相同，仅仅是返回值不同，<strong>不叫重载</strong> 因为函数名参数列表都相同</li>
</ol>
<h3 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h3><ol>
<li>const与普通变量的区别<ul>
<li>const修饰的变量不能够再作为左值！！！初始化完成后，值不能被修改。</li>
<li>不能把常量的地址泄露给一个普通的指针或普通的引用变量 不能int <em>p &#x3D; const int</em></li>
</ul>
</li>
<li>c和c++中const的区别是什么?<br> const的编译方式不同，c中，const就是当作一个变量来编译生成指令的。<br> C++中，所有出现const常量名字的地方，都被常量的初始化替换了！！！所以在C++中使用const必须要初始化。比如const int a &#x3D; 20，接下来的int arr[a]，这个a不是a了，而是20。那使用指针有没有修改掉a的值呢？有，已经改掉了。</li>
<li>c++的const必须初始化，叫常量。如果用变量为const定义的量赋值，就叫常变量(和C一样了)，因为初始值不是立即数，是一个变量，这时候printf出来的都会是变量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = b;</span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">	*p = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(&amp;a)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="const与一级指针-二级（多级）指针的结合"><a href="#const与一级指针-二级（多级）指针的结合" class="headerlink" title="const与一级指针&#x2F;二级（多级）指针的结合"></a>const与一级指针&#x2F;二级（多级）指针的结合</h3><p>c++语言规范：const修饰离它最近的类型<br><em><em>const右边如果没有指针</em>，是不参与类型的</em>*<br>const和一级指针的结合</p>
<ul>
<li>①const int <em>p &#x2F;&#x2F;修饰int，说明</em>p的值不能被改，但是p可以指向其他地方，一和二一样，const附近都是int</li>
<li>②int const *p  </li>
<li>③int *const p &#x2F;&#x2F;最靠近const的类型是：int *，修饰指针，说明指针指向不能改，但值可以改</li>
</ul>
<p><strong>总结const指针和指针类型的转换公式</strong> 理解：把一个普通指针变为const修饰的指针，告诉编译器：我不会再修改它了，是正确的</p>
<ul>
<li>int* &lt;&#x3D; const int* 是错误的</li>
<li>const int*  &lt;&#x3D; int* 是正确的</li>
</ul>
<h3 id="new-malloc-delete-free"><a href="#new-malloc-delete-free" class="headerlink" title="new&#x2F;malloc delete&#x2F;free"></a>new&#x2F;malloc delete&#x2F;free</h3><ol>
<li>delete和free的区别？malloc和free<strong>称作C的库函数</strong>，new和delete是运算符。</li>
<li>new不仅可以开辟内存，还可以初始化内存；malloc只负责开辟内存大小的空间，返回的指针是void *，所以要强制类型转换。 <code>c++int *p = (int*)malloc(sizeof(int)*20);</code></li>
<li>malloc开辟失败，是通过返回值和nullptr作比较；new开辟失败，通过<strong>抛出异常</strong>。</li>
<li>new有几种？<ul>
<li>int *p &#x3D; new int(20);</li>
<li>int *p2 &#x3D; new (nothrow) int; &#x2F;&#x2F;不抛出异常</li>
<li>const int *p3 &#x3D; new const int(40);</li>
<li>int data &#x3D; 0;int *p4 &#x3D; new (&amp;data) int(50); &#x2F;&#x2F;定位new，在指定的位置赋值</li>
</ul>
</li>
</ol>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>OOP语言的四大特征：抽象  封装&#x2F;隐藏  继承  多态<br>类：属性-&gt;成员变量  行为-&gt;成员方法<br>通过访问限定符体现：public  private  protected </p>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaLearn</title>
    <url>/2025/04/23/JavaLearn/</url>
    <content><![CDATA[<p>从今天开始，cpp转java，其实语言不是最重要的，重要的是思想，就像小学拿铅笔写字，初高中用水性笔，大学用电容笔一样，但做的都是同一件事情，写字。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>一开始就被环境变量上了一课，本博客使用hexo写的，我把D:\给删掉了，导致无法使用hexo指令，npm和node也找不到，添加完环境变量后就又能正常使用了。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>类名要和文件名相同，如果创建了Main.java文件，里面的类就要写为public class Main，否则会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印helloworld</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="制表符"><a href="#制表符" class="headerlink" title="制表符"></a>制表符</h3><p>可以在语句后面使用\n（字符串），但通用的语法是 +”\n” +”\t”,\t是制表符，补齐8个空格，让文本对齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">123</span>  );</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">-123</span> );</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">123.4566</span>  );</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="number">-123.4566</span> );</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;\t&quot;</span> + <span class="string">&quot;java&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&#x27;c&#x27;</span> + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;null\t&quot;</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="number">123</span> + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名建议"><a href="#命名建议" class="headerlink" title="命名建议"></a>命名建议</h3><p>小驼峰：方法、变量 firstName<br>大驼峰：类名 Student GoodStudent</p>
<h3 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h3><p>和python一样，使用import，这个就是cin</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>System.out.println(1+2+”abc”+2+1);<br>会输出3abc21，因为是从左到右进行运算，一开始没有加入字符串，所以就是int运算，后面是字符串的拼接操作。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>就是c&#x2F;c++的函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;13&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;14&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;15&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;16&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;17&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        playGame();</span><br><span class="line">        playGame();</span><br><span class="line">        playGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>写一个5位数的验证码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] Append() &#123;</span><br><span class="line">        <span class="type">char</span>[] newchar = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">63</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            newchar[i] = (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + i);        <span class="comment">// 大写A-Z</span></span><br><span class="line">            newchar[i + <span class="number">26</span>] = (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);   <span class="comment">// 小写a-z</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            newchar[i + <span class="number">53</span>] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newchar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">char</span> []wchar = Append();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            input += wchar[rand.nextInt(<span class="number">62</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(input);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，就是把大小写字母和0-9全部添加进数组里</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>和c++类似的，类里有成员变量，以及成员方法。<br><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为。</strong><br>this关键字：区别成员变量和局部变量，使用this就可以指向成员变量<br>标准的javabean类</p>
<ul>
<li>类名要见名知意</li>
<li>成员变量使用private修饰</li>
<li>提供至少两个构造方法<ul>
<li><strong>无参构造方法</strong></li>
<li><strong>带全部参数的有参构造方法</strong></li>
</ul>
</li>
<li>成员方法<ul>
<li><strong>提供每一个成员变量对应的set&#x2F;get</strong></li>
<li>如果还有其他行为也需要写入</li>
</ul>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>next();<br>nextLine();<br>这两个都是接收字符串的，next相当于cin，nextLine相当于getline<br>java中的&#x3D;&#x3D;比较，如果是比较基本数据类型就是比较值，如果比较String，就是比较地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```如果是这样，这是对的，s2复用了字符串池中的abc</span><br><span class="line">但如果是接下来的</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (s1==s2)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就不对了，new是在堆开辟了一片内存，和原来的abc不是同一个abc了。所以比较的时候不能用&#x3D;&#x3D;，而是要用equals方法<br>常用的方法</p>
<ul>
<li>equals 比较字符串是否相等</li>
<li>equalsIgnoreCase 忽略大小写的比较是否相等</li>
<li>charAt 用来遍历字符串的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                small++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                big++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较大小写，用ascii码来比较</p>
<ul>
<li>字符串切割s.subString(开始索引，结束索引)<br>StringBuilder对象不是String，要用toString将StringBuilder对象转换</li>
</ul>
<h3 id="集合ArrayList"><a href="#集合ArrayList" class="headerlink" title="集合ArrayList"></a>集合ArrayList</h3><p>相当于cpp的vector，有get，add，remove方法。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当类与类之间，存在相同（共性）的内容，并满足子类是父类中的一种，就可以考虑使用继承，来优化代码<br>学生和老师都有吃饭，睡觉<br>但是学生可以有学习行为，老师有教书行为<br>子类在父类的基础上有更强的行为。<br>继承格式：public class 子类 extends 父类{}<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424114044935.png"><br>多层继承：子类A继承父类B，父类B继承父类C，祖孙三代。<br>java中所有的类都直接或间接继承于Object类</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同类型的对象，表现出的不同形态。<br>如果写一个学生管理系统，学生，老师，管理员都需要注册，不能写三个方法，应该是它们三个共同的父类人类接收他们三个。已经写了三个类了，它们都继承了Person<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424141834666.png"></p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象方法所在的类必须是抽象类，抽象就是你不知道它具体要干什么，但是你总结了它要干的这件事情。比如兔子吃胡萝卜，狗吃骨头，青蛙吃虫子，它们三个都能吃，但是具体吃什么就不知道了，就可以把吃这个行为给抽象出来。<br>public abstract void eat();<br><strong>super</strong>用来调用父类构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Animal(String name) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Dog(String name) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Dog: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424144053394.png"><br>应该是弥补java中不能多重继承的缺点，打补丁。接口是一种规则，是对行为的抽象<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250424144345025.png"><br><strong>接口的子类要重写所有的抽象方法！</strong></p>
<h3 id="外部类和内部类"><a href="#外部类和内部类" class="headerlink" title="外部类和内部类"></a>外部类和内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">car</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        String brand;</span><br><span class="line">        String color;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">engine</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> age;</span><br><span class="line">            String engineName;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>内部类表示的事物是外部类的一部分,内部类单独出现没有任何意义,cpp中的结构体嵌套</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2025/04/25/MySQL/</url>
    <content><![CDATA[<h2 id="MySQL的数据模型"><a href="#MySQL的数据模型" class="headerlink" title="MySQL的数据模型"></a>MySQL的数据模型</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425151506824.png"><br>基于表存储的数据库叫做关系型数据库</p>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul>
<li>通用语法    <ol>
<li>SQL语句可以<strong>单行或多行</strong>书写，以<strong>分号</strong>结尾。</li>
<li>SQL语句可以使用空格&#x2F;缩进来增强可读性（空格缩进数量不限）</li>
<li>MySQL数据库的SQL语句<strong>不区分大小写</strong>，<strong>关键字</strong>建议使用大写</li>
<li>有多种注释</li>
</ol>
</li>
</ul>
<h3 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h3><p>语句分类<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425152338674.png"></p>
<h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><ul>
<li>查询<ol>
<li>查询所有数据库 show databases;</li>
<li>查询当前数据库 select database();</li>
</ol>
</li>
<li>创建<ol>
<li>create database 数据库名;</li>
<li>创建表:<br> create table 表名 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段1 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段2 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段3 字段类型 comment &#x27;注释内容&#x27;,</span><br><span class="line">字段n 字段类型 comment &#x27;注释内容&#x27;   (注意最后一条注释没有逗号)</span><br><span class="line">)comment &#x27;表注释&#x27;;</span><br></pre></td></tr></table></figure>
 <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155452204.png"><br> <strong>varchar() 变长字符串 char() 定长字符串</strong></li>
<li>查看创建的表：</li>
</ol>
<ul>
<li>show tables;</li>
<li>desc 表名;<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155608018.png"></li>
</ul>
<ol start="4">
<li>查看表的创建信息:</li>
</ol>
<ul>
<li>show create table 表名;<br>  <img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425155745479.png"></li>
</ul>
</li>
<li>删除<ol>
<li>数据库删除<br> drop database 数据库名;</li>
<li>表字段删除<br> alter table 表名 字段名;</li>
<li>表删除<br> drop table 表名;</li>
</ol>
</li>
<li>使用<ol>
<li>use 数据库名</li>
</ol>
</li>
<li>表修改操作<ol>
<li>修改（增加）<br>  alter table 表名 add 字段名 字段类型 comment ‘’;</li>
<li>修改数据类型<br>  alter table 表名 modify 字段名 新数据类型(长度)</li>
<li>修改字段名和字段类型<br>  alter table 表名 change 旧字段名 新字段名 类型(长度) comment ‘’;</li>
<li>修改表名<br>  alter table 表明 rename to 新表名;</li>
</ol>
</li>
</ul>
<h4 id="DML-data-manipulation-language"><a href="#DML-data-manipulation-language" class="headerlink" title="DML (data manipulation language)"></a>DML (data manipulation language)</h4><ol>
<li>添加数据(insert)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425174721753.png"></li>
<li>修改数据(update)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425180743091.png"><br>update em set name &#x3D; ‘itheima’ where id &#x3D; 1;<br>update em set entrytime &#x3D; ‘2008-01-01’; 如果不带where代表要执行整张表的数据</li>
<li>删除数据(delete)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425181556477.png"></li>
</ol>
<h4 id="DQL-data-query-language-用来-查询数据-的，设计的关键字select"><a href="#DQL-data-query-language-用来-查询数据-的，设计的关键字select" class="headerlink" title="DQL (data query language) 用来 查询数据 的，设计的关键字select"></a>DQL (data query language) 用来 查询数据 的，设计的关键字select</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425184335313.png"></p>
<ol>
<li>基本查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425184335313.png"></li>
<li>条件查询(<strong>加where</strong>)<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425190554345.png"></li>
</ol>
<ul>
<li>查询没有身份证的员工select * from em where idcard is null; （使用is null）</li>
<li>查询有 is not null</li>
<li>查询姓名为两个字的员工，用like + 两个占位符__ select * from em where name like ‘__’;</li>
<li>查询身份证最后一个位是X  select * from em where idcard like ‘%X’;</li>
</ul>
<ol start="3">
<li>聚合函数（将一列数据作为一个整体，进行纵向计算）<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425192935227.png"></li>
<li>分组查询<br>注意：先where，然后在where里分组后执行聚合函数，然后再执行having，分组之后，查询的字段一般为<strong>分组字段和聚合函数，查询其他的是没有意义的</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425193446332.png"></li>
</ol>
<ul>
<li>分组性别统计数量  select gender,count(*) from em group by gender ;</li>
<li>分组性别统计年龄 select gender,avg(age) from em group by gender;</li>
<li>年龄小于45 根据工作地址分组 获取员工数量大于3的地址<br>select workaddress,count(*) from em where age &lt;45 group by workaddress having count(*)&gt;&#x3D;3;<br>先写年龄小于45，然后再写分组，然后再挑数量，想要知道数量前面是谁？加上你选择分组的东西，最后再额外条件。</li>
</ul>
<ol start="5">
<li><p>排序查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425195312558.png"></p>
</li>
<li><p>分页查询<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425200216365.png"></p>
</li>
</ol>
<h4 id="DCL-Data-Control-Language数据控制语言-有哪些用户可以访问服务器，控制每一个用户的访问权限"><a href="#DCL-Data-Control-Language数据控制语言-有哪些用户可以访问服务器，控制每一个用户的访问权限" class="headerlink" title="DCL (Data Control Language数据控制语言) 有哪些用户可以访问服务器，控制每一个用户的访问权限"></a>DCL (Data Control Language数据控制语言) 有哪些用户可以访问服务器，控制每一个用户的访问权限</h4><ol>
<li>管理用户<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425201101284.png"></li>
<li>授予权限<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425201200579.png"></li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425203403010.png"></p>
<h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425203317834.png"><br>select lpad(round(rand()*1000000,0),6,’0’); 实现六位数的随机验证码</p>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425204154624.png"><br>select name,datediff(curdate(),entrydate) ‘entrydays’ from em order by entrydays;</p>
<h4 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425205106262.png"></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>create table user(<br>    id int primary key auto_increment comment ‘主键’,<br>    name varchar(10) not null unique comment ‘姓名’,<br>    age int check ( age &gt; 0 &amp;&amp; age &lt; 120 ) comment ‘年龄’,<br>    status char(1) default (1) comment ‘状态’,<br>    gender char(1) comment ‘性别’<br>)comment ‘用户表’;<br>这些都是约束<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425205304798.png"></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250425211835852.png"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br>比如银行转账。如果出错就要执行rollback回滚，设置为手动提交，autocommit &#x3D; 0，commit<br>事务的四大特性：</p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2025/04/27/javaweb/</url>
    <content><![CDATA[<p>Server后端开发：代码开发（java）–框架简化代码（Spring）–用包（库，包管理器：Maven）<br>总结就是三步：语言，框架，以及包</p>
<p>拼接起来就是：Fronted—www—Server—Database<br>前端发送到后端的叫请求(Request)，后端发给前端的叫响应(Response)。</p>
<h3 id="web网站的工作流程"><a href="#web网站的工作流程" class="headerlink" title="web网站的工作流程"></a>web网站的工作流程</h3><p>一个web网站大致由三个部分组成：前端服务器(前端程序)，后端服务器(后端程序)，数据库服务器<br>用户在浏览器输入域名，浏览器会根据域名请求访问前端服务器，前端服务器在接收到请求后会向浏览器返回前端代码，(浏览器也是一个程序，内置了解析前端代码的解析引擎)，从而解析出对应的页面样式<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250427193730312.png"><br>需要学习的技术：Maven、SpringBoot Web、MySQL(got it)、SpringBoot Mybatis</p>
<h3 id="初识web前端"><a href="#初识web前端" class="headerlink" title="初识web前端"></a>初识web前端</h3><ul>
<li>网页的组成部分：文字、图片、音频、超链接、视频</li>
<li>我们看到的网页背后的本质：<strong>前端代码</strong></li>
<li>前端代码如何转换成用户眼中的网页：<strong>浏览器</strong>转化(解析和渲染(浏览器内核))成用户看到的网页</li>
</ul>
<p>Web标准：</p>
<ul>
<li>HTML(HyperText Markup Language):负责网页的结构（页面元素和内容）</li>
<li>CSS：负责网页的表现（页面元素的外观，位置等页面样式，如颜色，大小）</li>
<li>JavaScript：负责网页的行为（交互效果）<br>常用标签</li>
<li>vscode装了插件之后直接!</li>
<li>hr:水平线，一般有两个</li>
<li>h1-h6：六级标题对应不同大小</li>
<li>img：插入图片，可以绝对路径或者相对路径，一般用相对路径。还可以设置宽高，但一般只设置一个，会等比例缩放</li>
<li>title：网页名字<br>2025.4.27</li>
</ul>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Maven 是一个项目管理和构建工具，主要用于管理 Java 项目的依赖库，以及自动化项目的编译、打包、测试、部署等过程。<br>简单理解就是：</p>
<ul>
<li>你在开发 JavaWeb 项目的时候，需要很多第三方库（比如数据库连接池、日志框架等等）。</li>
<li>Maven 帮你自动下载、管理版本，不用你手动找 jar 包。</li>
<li>它还能一键构建项目，比如一条命令就能打成 war 包部署到服务器上。<br>成功配置maven<br>2025.4.28</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><ul>
<li>SpringBoot快速入门<ol>
<li>创建SpringBoot工程，勾选web开发</li>
<li>编写请求处理类（加上注解）</li>
<li>看本地占用端口，打开浏览器访问端口<br>要写注解</li>
</ol>
</li>
<li>@RequestController告诉SpringBoot直接返回内容到页面</li>
<li>@RequestMapping是访问路径<br>简单url是 <a href="http://localhost:8080/array?hobby=sing&hobby=jump&hobby=rap&hobby=basketball">http://localhost:8080/array?hobby=sing&amp;hobby=jump&amp;hobby=rap&amp;hobby=basketball</a></li>
</ul>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><strong>MySQL账号密码：root 1234</strong><br>MyBatis用来简化JDBC开发的框架，<strong>用来操作数据库</strong>。<br>包是组织<strong>类</strong>的，模块是组织<strong>包</strong>的。</p>
<h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><ul>
<li>准备数据库表(dept\emp)</li>
<li>创建SpringBoot工程，引入对应的依赖：web、mybatis、mysql驱动、lombok</li>
<li>配置文件：引入mybatis的配置信息，准备对应的实体类</li>
<li>准备对应的Mapper、Service（接口、实现类）、Controller基础结构</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>javaAlgorithm</title>
    <url>/2025/05/19/javaAlgorithm/</url>
    <content><![CDATA[<p>java是一种<strong>面向对象</strong>的语言，入口程序也是一个<strong>类</strong>，类的属性有public,private,protected;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span>(String arg[])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;helloworld!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2025.5.19</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>应用场景：<strong>有序</strong> <strong>数组</strong><br>二分三元素 ：<strong>left，mid，right</strong><br>目标可能存在的区间，在[left,right]之间，所以循环条件就是他。<br>循环变更的是：left和right，是基于这一次选择的mid来变更的，而不是left和right++ &#x2F; –1；<br>时间复杂度：logN<br><a href="https://leetcode.cn/problems/binary-search/">二分查找</a><br><a href="https://leetcode.cn/problems/guess-number-higher-or-lower/description/">猜数字大小</a><br><a href="https://leetcode.cn/problems/search-insert-position/description/">搜索插入位置</a><br><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">在排序数组中查找元素的第一个和最后一个位置</a><br><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a><br><a href="https://leetcode.cn/problems/first-bad-version/description/">第一个错误的版本</a><br><a href="https://leetcode.cn/problems/peak-index-in-a-mountain-array/description/">山脉数组的峰顶索引</a><br><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">搜索旋转排序数组</a><br><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">搜索旋转排列数组Ⅱ</a><br><a href="https://leetcode.cn/problems/find-in-mountain-array/description/">山脉数组中查找目标值</a></p>
<p>2025.5.20</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">无重复字符的最长字串</a><br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">长度最小的子数组</a><br><a href="https://leetcode.cn/problems/permutation-in-string/description/">最小覆盖字串</a></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈中使用push()&#x2F;pop()来 添加&#x2F;删除元素，peek()查看栈顶元素<br><a href="https://leetcode.cn/problems/simplify-path/description/">简化路径</a>StringBuilder以及字符串切割<br><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">逆波兰表达式</a><br><a href="https://leetcode.cn/problems/valid-parentheses/">有效的括号</a></p>
<p>2025.5.21</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p><a href="https://leetcode.cn/problems/3sum/">三数之和</a><br><a href="https://leetcode.cn/problems/3sum-closest/description/">最接近的三数之和</a></p>
<p>2025.5.22</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>优先队列视为堆，默认是最小堆，堆中使用add()&#x2F;poll() 进行添加&#x2F;删除元素，peek查看堆顶元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;T&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">//最小堆</span></span><br><span class="line">PriorityQueue&lt;T&gt;pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparation.reverseOrder()); <span class="comment">//最大堆 </span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">数组中的第k个最大元素</a><br><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/">前k个高频元素</a><br><a href="https://leetcode.cn/problems/sort-characters-by-frequency/description/">根据字符出现频率排序</a><br><a href="https://leetcode.cn/problems/k-closest-points-to-origin/description/">最接近原点的 K 个点</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java八股</title>
    <url>/2025/05/15/Java%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解就像是给代码段贴上一张小标签，告诉<strong>编译器、框架或工具</strong>需要怎么去处理它，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br></pre></td></tr></table></figure>
<p>就可以告诉Spring框架进行这个对象的注入，而不是自己再手动new一个。<br>用人话来说，你拿快递的时候，快递盒子上会写备注：@轻拿轻放，提醒快递员应该怎么做。</p>
]]></content>
  </entry>
</search>
