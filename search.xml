<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章！</title>
    <url>/2025/03/08/FirstBlog/</url>
    <content><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="CPU的组成"><a href="#CPU的组成" class="headerlink" title="CPU的组成"></a>CPU的组成</h2><ul>
<li><strong>运算器</strong>进行信息处理；</li>
<li><strong>寄存器</strong>进行信息存储；</li>
<li><strong>控制器</strong>协调各种器件进行工作；</li>
<li><strong>内部总线</strong>实现CPU内各个器件之间的联系。</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"1.png","alt":"img","title":""}]</div>
  </div>
<h2 id="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"><a href="#8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？" class="headerlink" title="8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？"></a>8086上一代CPU的寄存器是八位的，那如何保证兼容性呢？</h2><p>把16位寄存器分成<strong>AH</strong>和<strong>AL</strong>两个独立的8位寄存器使用；<br>同样，32位或64位的寄存器也可以分，从而实现兼容性。<br>比如AX中现在存储0101010110101010，可以分为AH<strong>01010101</strong>和AL<strong>10101010</strong>来存储</p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h3 id="汇编指令-控制CPU完成的操作"><a href="#汇编指令-控制CPU完成的操作" class="headerlink" title="汇编指令                控制CPU完成的操作"></a>汇编指令                控制CPU完成的操作</h3><ul>
<li>mov ax,18                  将18送入AX</li>
<li>mov ah,78                  将78送入AH</li>
<li>add ax,8                   将AX中的值和8相加并把值存入AX</li>
<li>mov ax,bx                  将BX中的值赋值给AX</li>
<li>add ax,bx                  将AX和BX中的内容相加并把值存于AX<br><strong>注意：汇编指令不区分大小写，MOV也行</strong></li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"2.png","alt":"img","title":""}]</div>
  </div>
<p>在进行低八位运算的时候，比如最后一行85+93，结果等于158，但发生了溢出，只能显示58，1舍弃而不是进位到高位。</p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p>每一个内存单元在存储空间中都有唯一的位置。8086CPU有20位地址总线，可传送20位地址，寻址能力为1MB（2的20次方）。8086是<strong>16位</strong>的CPU，16位地址表示的是地址总线的宽度，即CPU可以直接访问的地址范围。如果地址总线是16位，那么可表示的地址数量为2的十六次方&#x3D;65536个字节（即 64KB）。这意味着 CPU 最多只能寻址 64KB 的内存空间。<br>使用地址加法器将两个16位地址合成一个20位的物理地址。一个叫做<strong>段地址</strong>，另一个叫做<strong>偏移地址</strong>。<br><strong>段地址✖16 + 偏移地址 &#x3D; 物理地址，也称之为左移四位（二进制中），在十六进制里左移1位即可。</strong><br>最后得到的20位物理地址被地址总线传送到存储器里。<br>描述存储单元的方法（物理地址为21F60H，段地址为2000H，则偏移地址为1F60H）</p>
<ul>
<li>数据存放在内存2000：1F60单元中</li>
<li>数据存放在内存的2000段中的1F60H中</li>
</ul>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"3.png","alt":"img","title":""}]</div>
  </div>]]></content>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2025/03/09/Thread/</url>
    <content><![CDATA[<h1 id="C-11多线程编程"><a href="#C-11多线程编程" class="headerlink" title="C++11多线程编程"></a>C++11多线程编程</h1><hr>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><ul>
<li>进程就是正在运行的程序</li>
<li>线程就是进程中的进程</li>
<li>多线程可以提高效率。</li>
<li>线程的多少取决于CPU的<strong>核数</strong><br>如下图，如果是串行的话就必须顺序执行，但如果并行的话你就可以在同一时间内干多个事情。但同时要注意你的“<strong>核数</strong>”，你不能同时刷抖音和听音乐，因为你没有四个耳朵，亦或者说你的手机同一时间内只能处理一个应用播放声音。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread1.png" alt="图片"></li>
</ul>
<h1 id="C-11-Thread"><a href="#C-11-Thread" class="headerlink" title="C++11 Thread"></a>C++11 Thread</h1><ul>
<li>准备工具 Visual Studio</li>
<li>线程库 thread</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用thread创建一个线程"><a href="#使用thread创建一个线程" class="headerlink" title="使用thread创建一个线程"></a>使用thread创建一个线程</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHelloWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;HelloWorld&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行调试后，会得到下面结果：<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread2.png" alt="图片"><br>我们发现报错了，为什么会这样呢？</p>
<hr>
<p>可以理解为main里是<strong>主线程</strong>，一开始我们便创建了一个<strong>子线程</strong>，并让其执行PrintHelloWorld的函数。当<strong>子线程</strong>没有执行完毕的时候，主线程已执行完毕。<strong>主线程不会等待子线程执行完毕</strong>，可能子线程才执行到Hello，主程序已经return 0了，所以出现报错；<strong>所以说主线程和子线程是并发运行的！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout&lt;&lt;<span class="string">&quot;HelloworldMain&quot;</span>&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>
<p>当我们再次加入一行代码时发现，先输出的是<strong>主线程</strong>的HelloworldMain,接下来才是<strong>子线程</strong>的Helloworld。从这里我们可以看出：<strong>创建线程是需要时间的</strong>。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/Thread3.png" alt="图片"></p>
<h2 id="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"><a href="#如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？" class="headerlink" title="如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？"></a>如何解决主线程和子线程先后结束时间不同而引起的程序崩溃？</h2><h3 id="函数thread-join"><a href="#函数thread-join" class="headerlink" title="函数thread.join()"></a><strong>函数thread.join()</strong></h3><p>在 C++ 中，std::thread::join() 的作用是 等待<strong>子线程执行完毕</strong>，然后<strong>主线程才继续执行</strong>。如果没有 join()，主线程可能会在子线程执行完成之前就结束，导致未定义行为程序报错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworldMain&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当我们添加了thread1.join()之后，相当于告诉主线程：“大哥你先等我弄完你再往下走，别丢下我！” （<strong>演示注释掉thread1.join()的情况</strong>）<br>join的作用是：<strong>确保子线程完成</strong>，执行顺序可控，但是会<strong>阻塞</strong>主线程，直到子线程完成。<br>阻塞示例 （joinable()用于判断线程是否可以使用join函数，返回的是一个bool值）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; i;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">thread1</span><span class="params">(print)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (thread<span class="number">1.</span><span class="built_in">joinable</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		thread<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数thread-detach"><a href="#函数thread-detach" class="headerlink" title="函数thread.detach()"></a><strong>函数thread.detach()</strong></h3><p>让子线程“脱离”主线程，主线程不再管理它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">(PrintHelloWorld)</span></span>;</span><br><span class="line">thread<span class="number">1.</span><span class="built_in">detach</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>你可以干你的事情，我也可以干我的事情，不管你了。像请客吃饭，请客的人把单买了之后说我先走一步，你们随意。对比上面的阻塞，我们发现detach是<strong>并发</strong>的。</p>
]]></content>
      <categories>
        <category>c++多线程</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread2</title>
    <url>/2025/03/09/Thread2/</url>
    <content><![CDATA[<h1 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h1><h2 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h2><p>当多线程去共享同一个数据的时候，会造成争夺</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码发现，a的值没有如我们预期所认为是20000，而是随机的数字。这是因为线程在读取同一个数据的时候发生了争夺。<br>解决办法：当一个线程拿了数据，其他线程禁止拿，也就是互斥锁：线程访问共享资源前，先<strong>加锁</strong>（lock），用完后<strong>解锁</strong>（unlock）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>(); <span class="comment">//在这个线程即将访问数据的时候上锁</span></span><br><span class="line">        a += <span class="number">1</span>;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>(); <span class="comment">//在访问完成后解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多线程安全：如果多线程程序每一次的运行结果和单线程运行的结果是一样的，那么你的线程就是安全的。</strong></p>
<h2 id="互斥量死锁"><a href="#互斥量死锁" class="headerlink" title="互斥量死锁"></a>互斥量死锁</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m1,m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		m<span class="number">2.l</span>ock();</span><br><span class="line">		m<span class="number">1.l</span>ock();</span><br><span class="line">		m<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">		m<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func_1)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func_2)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;over&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法，当某个线程获取到了m1，那就让他获取m2，按照这样的规则，所有的线程都得先有m1才有m2，那其他线程拿不到m1自然也拿不到m2，所以调换func_2的m1、m2顺序即可。</p>
<h2 id="lock-guard与unique-lock"><a href="#lock-guard与unique-lock" class="headerlink" title="lock_guard与unique_lock"></a>lock_guard与unique_lock</h2><p>std::lock_guard是C++标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。</p>
<ul>
<li>当构造函数被调用时，该互斥量会被<code>自动锁定</code></li>
<li>当析构函数被调用时，该互斥量会被<code>自动解锁</code></li>
<li>std::lock_guard对象不能复制或移动，因此它<code>只能在局部作用域中使用</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt;<span class="built_in">lg</span>(mtx);</span><br><span class="line">		shared_data++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lock_guard<mutex>lg(mtx)的作用就相当于mtx.lock() 且 mtx.unlock().<br>有五个用法：</mutex></p>
<h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">&#125;  <span class="comment">// 作用域结束，自动解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="手动解锁"><a href="#手动解锁" class="headerlink" title="手动解锁"></a>手动解锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();  <span class="comment">// 提前解锁</span></span><br><span class="line">    <span class="comment">// 此处不再受互斥锁保护</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="延迟加锁"><a href="#延迟加锁" class="headerlink" title="延迟加锁"></a>延迟加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;  <span class="comment">// 不自动加锁</span></span><br><span class="line">    <span class="comment">// ... 其他代码</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();  <span class="comment">// 需要时再手动加锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="尝试加锁"><a href="#尝试加锁" class="headerlink" title="尝试加锁"></a>尝试加锁</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::try_to_lock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lock.<span class="built_in">owns_lock</span>()) &#123;  <span class="comment">// 判断是否加锁成功</span></span><br><span class="line">        <span class="comment">// 临界区代码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 锁未获取成功，执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁转移"><a href="#互斥锁转移" class="headerlink" title="互斥锁转移"></a>互斥锁转移</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx)</span></span>;  <span class="comment">// 获取锁</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock2 = std::<span class="built_in">move</span>(lock1);  <span class="comment">// lock1 转移给 lock2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="生产者与消费者模型"><a href="#生产者与消费者模型" class="headerlink" title="生产者与消费者模型"></a>生产者与消费者模型</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311104759163.png" alt="生产者与消费者"><br>生产者与消费者模型可以这样比喻：生产者是小鸡，任务队列是鸡蛋篮子，消费者是饲养员。有源源不断的任务从生产者发出，由消费者解除，也类似于银行排队系统。<br>当任务队列为<strong>空</strong>的时候，消费者无法去取任务，因此会进入<strong>等待</strong>的状态。那此时老板会下发任务，如何让消费者知道有任务？需要<strong>通知</strong>，让消费者知道我该往里面取任务了。<br>condition_variable有两种</p>
<ul>
<li>notify_one 唤醒消费者中的<em>一个线程</em>来干活</li>
<li>notify-all 唤醒消费者中的<em>所有线程</em>来干活<br><strong>区别在于：通知只发一次，但是对象不同，唤醒一条线程和所有线程的区别</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt;g_queue;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Consumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Consumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait函数g_cv.wait(lock, predicate)的作用：</p>
<ul>
<li>当前线程进入等待状态，直到 predicate 返回 true，也就是说第二个判断条件是true就往下执行</li>
<li>lock 是一个 std::unique_lock<a href="std::mutex">std::mutex</a>，用于保护临界区资源。</li>
<li>predicate 是一个 Lambda 表达式，返回 true 时线程继续执行，否则会一直等待。<br>两个代码是等价的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g_cv.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>(); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!g_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 条件不满足，释放 lock 并进入等待状态</span></span><br><span class="line">    g_cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 条件满足，继续执行后续代码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 g_queue 为空时，线程会阻塞（等待）。</li>
<li>当 g_queue 非空时，线程继续执行，不会进入等待状态。</li>
</ul>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>除了可以用互斥锁来维护共享变量外，还可以通过原子操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line">std::atomic &lt;<span class="type">int</span>&gt; <span class="built_in">a</span>(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">		a += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在初始化的时候，不允许使用<code>std::atomic&lt;int&gt; a = 0</code>，因为原子操作不允许拷贝复制，应该用默认的构造函数<code>std::atomic&lt;int&gt; a(0)或std::atomic&lt;int&gt; a&#123;0&#125;</code><br>把共享的数据设置为原子变量，更好地维护线程安全，还可以提升运行速度。</p>
<p>小班演示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable g_cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; g_queue;  <span class="comment">//容器要包含类型</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_queue.<span class="built_in">push</span>(i);</span><br><span class="line">		g_cv.<span class="built_in">notify_one</span>();  <span class="comment">//每次加任务的时候通知一下</span></span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Producer : &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1000</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Comsumer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">100</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">		g_cv.<span class="built_in">wait</span>(lock, []() &#123;<span class="keyword">return</span> !g_queue.<span class="built_in">empty</span>();</span><br><span class="line">			&#125;);</span><br><span class="line">		flag++;</span><br><span class="line">		<span class="type">int</span> value = g_queue.<span class="built_in">front</span>();</span><br><span class="line">		g_queue.<span class="built_in">pop</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Comsumer : &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Producer)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Comsumer)</span></span>;</span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="C-11跨平台线程池"><a href="#C-11跨平台线程池" class="headerlink" title="C++11跨平台线程池"></a>C++11跨平台线程池</h1>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++Practise</title>
    <url>/2025/03/10/C-Practise/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="auto：在C-中，auto可以自动推导类型。"><a href="#auto：在C-中，auto可以自动推导类型。" class="headerlink" title="auto：在C++中，auto可以自动推导类型。"></a>auto：在C++中，auto可以自动推导类型。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//有两种方式可以遍历STL容器</span></span><br><span class="line">- <span class="keyword">for</span> (std::vector::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">- <span class="keyword">for</span> (<span class="keyword">auto</span> vtest : v)</span><br></pre></td></tr></table></figure>
<p>&amp;为引用，加&amp;与否取决于是否要修改原值或避免拷贝</p>
<ul>
<li>需要修改并输出修改后的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector &lt;<span class="type">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		v1 = v1<span class="number">+1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v1:v)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout&lt;&lt;v1&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>建议都加std::</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">a</span><span class="params">(n,c)</span>  <span class="comment">//可以生成一个包含n个c的字符串。</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string a.<span class="built_in">find</span>() <span class="comment">//可以找一个你想要东西的位置</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">abbrevName</span><span class="params">(std::string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[<span class="number">0</span>]);</span><br><span class="line">  s += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  s += <span class="built_in">toupper</span>(name[name.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)<span class="number">+1</span>]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL——set"><a href="#STL——set" class="headerlink" title="STL——set"></a>STL——set</h3><p>set 有insert，erase，count，find,size等用法，通常用于查找的时候不用find（因为要返回迭代器的值），而是用count，set底层是红黑树，可以实现自动除重，比如insert(6)两次，只会有一个，所以count()的值只会是0和1；用于判断是否存储在里面。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312112552261.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set.<span class="built_in">insert</span>();</span><br><span class="line">set.<span class="built_in">erase</span>();</span><br><span class="line">set.<span class="built_in">count</span>();</span><br></pre></td></tr></table></figure>
<p>unordered_set和set大体上一样，但是是用哈希表实现的，所以里面是无序的，但是查找很快,O(1)级，set的查找是O(logN);</p>
<p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a:nums)&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ns = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n!=ns) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>判断前后两次的size是否相同，不同则有重复插入。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是一个映射，由Key-&gt;Value，内部是用pair实现。<br>常见的用法有</p>
<ul>
<li>m[] &#x3D; ;</li>
<li>m.erase();</li>
<li>m.count(); &#x2F;&#x2F;用于查找有没有值，return1&#x2F;0;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312120338656.png"><br>可以看到map也像set一样会自动排序，且后来者会覆盖，count返回的是0和1。</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>外层循环a.size()-1次，内层循环a.size()-i-1次;加引用和不加引用的区别在于：<strong>通过引用传递，函数内部对向量的修改会直接反映在原始向量上，这正是冒泡排序需要的效果，即直接在原数组上排序。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (a[j]&gt;a[j<span class="number">+1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> temp = a[j<span class="number">+1</span>];</span><br><span class="line">				a[j<span class="number">+1</span>] = a[j];</span><br><span class="line">				a[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针是一种<strong>数据类型</strong>，在32为系统性size &#x3D; 4，64 &#x3D; 8.指针存放的是内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>意思是p指针现在存储的是a的地址，可以使用解引用号<em>来访问*<em>p存储的这个地址的值</em></em>。</p>
<h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>const为常量，加在指针前就称之为常量指针 const int *p</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*p = &amp;a;</span><br><span class="line">*p = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>
<p><strong>这是一个非法的操作</strong>，常量指针可以<strong>改变指向的地址</strong>，但<strong>不能改变指向地址的值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;</span><br><span class="line">p = &amp;b;</span><br></pre></td></tr></table></figure>
<p>这是一个合法的操作，现在p指向的就是b的地址。</p>
<h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>指针常量和常量指针作用刚好相反，要这样理解：<strong>const后面跟着谁谁就无法改变</strong>，在指针常量中，int *const p，const后面跟着的是地址，所以地址就不能改；在常量指针中，const int *p，const后面跟的是int值，所以值不可以改。<br>所以当const int *const p两个都不可以改。快速记忆：遇到英文翻译中文，const int *p,const是常量，后面是指针，所以常量指针;int *const p,先遇到指针，再遇到常量，所以叫指针常量。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用就是取别名，本质是指针，让b的地址和a的地址相同，但记住在这里引用类似于常量指针，不允许再更改成其他的地址了，但可以改值。<strong>引用必须初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure>
<h3 id="引用不要返回局部变量"><a href="#引用不要返回局部变量" class="headerlink" title="引用不要返回局部变量"></a>引用不要返回局部变量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次的时候可以正常输出10，但第二次就不行了，因为局部变量存放在栈区，会被释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> &amp;ref = <span class="built_in">test</span>();</span><br><span class="line">	cout&lt;&lt;ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static关键字让他是静态变量，存放在<strong>全局区</strong>，全局区上的数据在程序结束后释放。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类有<strong>属性</strong>和<strong>行为</strong>，比如一个学生类，属性就是学生的名字&#x2F;学生的学号，行为就是打印出名字和学号，也可以用行为来给学生的属性赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_num;</span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;m_num&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m_name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员私有化之后可以实现只读&#x2F;只写&#x2F;可读可写。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_age = <span class="number">18</span>;</span><br><span class="line">		string m_name;</span><br><span class="line">		string m_lover;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout&lt;&lt;m_age&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (age&gt;<span class="number">150</span>||age&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			m_age = age;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student s;</span><br><span class="line">	s.<span class="built_in">set_age</span>(<span class="number">160</span>);</span><br><span class="line">	s.<span class="built_in">get_age</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>圆类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_x</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_x = x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_y</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_y = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_y;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_x;</span><br><span class="line">		<span class="type">int</span> m_y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span>&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_r</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_r = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">getm_r</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">setm_center</span><span class="params">(point p)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			m_center = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">point <span class="title">getm_center</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> m_center;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> m_r;</span><br><span class="line">		point m_center;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Relation</span><span class="params">(circle &amp;c,point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dx = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_x</span>()-p.<span class="built_in">getm_x</span>();</span><br><span class="line">	<span class="type">int</span> dy = c.<span class="built_in">getm_center</span>().<span class="built_in">getm_y</span>()-p.<span class="built_in">getm_y</span>();</span><br><span class="line">	cout&lt;&lt;dx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;dy;</span><br><span class="line">	<span class="type">int</span> rdistance = c.<span class="built_in">getm_r</span>()*c.<span class="built_in">getm_r</span>();</span><br><span class="line">	<span class="type">int</span> distance = dx*dx+dy*dy;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (distance==rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆上&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(distance&gt;rdistance)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;在圆外&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;在圆内&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	point p;</span><br><span class="line">	circle c;</span><br><span class="line">	c.<span class="built_in">setm_r</span>(<span class="number">10</span>);</span><br><span class="line">	point center;</span><br><span class="line">	center.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	center.<span class="built_in">setm_y</span>(<span class="number">0</span>);</span><br><span class="line">	c.<span class="built_in">setm_center</span>(center); </span><br><span class="line"></span><br><span class="line">	p.<span class="built_in">setm_x</span>(<span class="number">10</span>);</span><br><span class="line">	p.<span class="built_in">setm_y</span>(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Relation</span>(c,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h2><p>没有返回值，不用写void，函数名与类名相同，构造函数可以有参数，可以发生重载，创建对象的时候会自动调用，而且只调用一次。<br>析构函数前加一个~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;构造&quot;</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	~<span class="built_in">person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;析构&quot;</span>;</span><br><span class="line">	 &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	person p;</span><br><span class="line">	person p1;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>可以省略冗余的代码，继承父类。 j<br>继承语法： class 子类 : 继承方式 父类<br>class cpp : public header<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183703034.png">;<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250321183742270.png">;</p>
]]></content>
  </entry>
  <entry>
    <title>算法（一）</title>
    <url>/2025/03/11/%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><p>介绍常用的算法</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>有三个关键量，right、left、middle；<code>middle = (right - left)&gt;&gt;1</code>，其中<code>&gt;&gt;</code>为右移运算符，将right - left结果的二进制位向右移一位，&gt;&gt;n右移n位，举个例子</p>
<ul>
<li>8 - 4 &#x3D; 4，4的二进制位为0100，右移一位变为0010，代表十进制2。</li>
<li>7 - 2 &#x3D; 5，5的二进制位为0101，右移一位变为0010，代表十进制2。<br>可以看出，右移运算符的作用是<code>将两数相减并向下取整得到结果</code><br>为什么要用右移运算符而不用&#x2F;2？</li>
<li>右移运算 &gt;&gt; 通常比除法 &#x2F; 更快，因为位运算是底层硬件直接支持的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (right &gt;= left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right - left)&gt;&gt;<span class="number">1</span>); <span class="comment">//left每一次加上新的中间值</span></span><br><span class="line">			<span class="keyword">if</span> (nums[middle]&gt;target)&#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle]&lt;target)&#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</strong><br><strong>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</strong><br>采用二分法，注意停止条件，当left&gt;right就停止了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> (right&gt;=left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + ((right-left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="type">double</span> p = <span class="number">1.0</span>*middle*middle;</span><br><span class="line">            <span class="keyword">if</span> (p==x) <span class="keyword">return</span> middle;</span><br><span class="line">            <span class="keyword">if</span> (p&lt;x)&#123;</span><br><span class="line">                left = middle<span class="number">+1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311182900217.png"></p>
<h2 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h2><p>滑动窗口类似于双指针，用于去求最短子序列<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311202740831.gif"><br>j是终止位置，很像毛毛虫往前拱，吃到了，然后尾巴再上来。<br>LeetCode 209</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span> (sum&gt;=target)&#123;</span><br><span class="line">                subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                x = x &gt; subLength ? subLength : x;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == INT32_MAX? <span class="number">0</span> : x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口例题2<br>The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:</p>
<p>maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4});<br>&#x2F;&#x2F;should be 6: {4, -1, 2, 1}<br>Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.</p>
<p>Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist&#x2F;subarray.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSequence</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, maxSum = <span class="number">0</span>;  <span class="comment">// 初始化最大和为 0（符合题目要求）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; arr.<span class="built_in">size</span>(); ++right) &#123;</span><br><span class="line">        sum += arr[right];  <span class="comment">// 扩展窗口</span></span><br><span class="line">        </span><br><span class="line">        maxSum = std::<span class="built_in">max</span>(maxSum, sum);  <span class="comment">// 更新最大子数组和</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前窗口的和变成负数，移动左指针</span></span><br><span class="line">        <span class="keyword">while</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum -= arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的一步在while(sum&lt;0),会把之前为负数的窗口给舍弃掉，1 + -3 &#x3D; -2，-2 -1 &#x3D; -3，left左移动一位，-3 -（-3） &#x3D; 0，left左移一位，所以left变成了3；从3又继续开始遍历。</p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>说实话贪心算法并没有固定的套路。<br><strong>所以唯一的难点就是如何通过局部最优，推出整体最优。</strong><br>LeetCode455<a href="https://leetcode.cn/problems/assign-cookies/">分饼干</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (g.<span class="built_in">size</span>()==<span class="number">0</span>||s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span> (s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span> (g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;g.<span class="built_in">size</span>()&amp;&amp;j&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i]&lt;=s[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>计算机系统</title>
    <url>/2025/03/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="汇编入门"><a href="#汇编入门" class="headerlink" title="汇编入门"></a>汇编入门</h2><h3 id="80386通用寄存器"><a href="#80386通用寄存器" class="headerlink" title="80386通用寄存器"></a>80386通用寄存器</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312130401047.png"></p>
<ul>
<li>%ax :accumulate 累加寄存器</li>
<li>%bx :base 基址寄存器</li>
<li>%cx :count 计数寄存器</li>
<li>%dx :divide 放除法的商和余数</li>
<li>%eax : extend 扩展 表示32位的寄存器<br>%eax表示32位寄存器，%ax表示低16位，在低16位的寄存器中：%ah表示高八位，%al表示第八位</li>
</ul>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="1005-s-立即数寻址"><a href="#1005-s-立即数寻址" class="headerlink" title="1005.s 立即数寻址"></a>1005.s 立即数寻址</h4><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312134223502.png"><br>movl $8,%eax; </p>
<ul>
<li>$是立即数，表示8</li>
<li>movl是移动的意思，将8赋值给%eax；<br>最终的运行结果如下<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312140455507.png"></li>
</ul>
<hr>
<h4 id="1006-s-寄存器寻址"><a href="#1006-s-寄存器寻址" class="headerlink" title="1006.s 寄存器寻址"></a>1006.s 寄存器寻址</h4><ul>
<li>movl 用于传送<strong>32</strong>位的长子值</li>
<li>movw 用于传送<strong>16</strong>位的子值</li>
<li>movb 用于传送<strong>8</strong>位的子值<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312141244989.png"><br><strong>不能把movw的w改为l，因为%bx是16位的寄存器，如果改为l试图把32位的传给16位是错误的</strong>。可以写mov &#x2F; movw<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312174829067.png"><br>命令为 movw $0x5678,%dx ; 意思是传16个字节(w)的数据到寄存器dx里，结果如我们所愿，如果用%dh&#x2F;%dl便会报错，因为%dh&#x2F;%dl是8位的寄存器;同样，也不能movw $0x5678,%edx，因为edx是32位的，所以只能写32位的地址。如下图，所以要用对应的寄存器和对应位数的mov指令或只写mov去传递数据。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312175249233.png"></li>
</ul>
<h4 id="1007-s-绝对寻址（直接寻址）"><a href="#1007-s-绝对寻址（直接寻址）" class="headerlink" title="1007.s 绝对寻址（直接寻址）"></a>1007.s 绝对寻址（直接寻址）</h4><p>movl 0x08048054,%exc，直接把这个内存地址赋给%exc。可以使用x&#x2F;4bx 08048054来查看以8054起的四个地址内容。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190744306.png" alt="查看内存内容"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312190225523.png"><br>内存之中<strong>既可以存放数据，也可以存放指令</strong>。如图，b9是指令，从后往前看08、04、80、55就是数据。</p>
<h4 id="1008-s-间接寻址"><a href="#1008-s-间接寻址" class="headerlink" title="1008.s 间接寻址"></a>1008.s 间接寻址</h4><p>movl (%ebx),%eax 和寄存器寻址的区别在于第一个寄存器套上了括号，表示不是把寄存器%ebx的值赋给%eax，而是寄存器存放的数据的地址存放的内容赋给%eax。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191539026.png"><br>第一步，立即数寻址，把立即数08048054放到%ecx<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250312191713316.png"><br>第二步，查看08048054内存中存放的数据是什么，并将其传入<strong>16位</strong>的%ax中，得到结果0x8056，为什么是8056？因为56是低位，80是高位</p>
<h4 id="1009-s-变址寻址"><a href="#1009-s-变址寻址" class="headerlink" title="1009.s 变址寻址"></a>1009.s 变址寻址</h4><p>movl (%ebx,%edx),%eax 在1008的基础上，把括号内两个寄存器的值加起来，用这个内存地址去找里面的数据，然后把数据传给%eax。</p>
<h4 id="1010-s-比例变址寻址"><a href="#1010-s-比例变址寻址" class="headerlink" title="1010.s 比例变址寻址"></a>1010.s 比例变址寻址</h4><p>movl (%ebx,%ecx,0x2),%eax<br>%ebx为基址，%ecx与第三个参数**（第三个参数只能为1，2，4，8，左移运算符）**相乘并与基址相加，最后赋值给%eax。</p>
]]></content>
  </entry>
  <entry>
    <title>Network</title>
    <url>/2025/03/19/Network/</url>
    <content><![CDATA[<h1 id="Computer-Network"><a href="#Computer-Network" class="headerlink" title="Computer Network"></a>Computer Network</h1><p>The following content is about the basic knowledge of computer network.</p>
<h2 id="Breif-introduction"><a href="#Breif-introduction" class="headerlink" title="Breif introduction"></a>Breif introduction</h2><p>Such as smartphone, tv, safe system, car and so on.All of this are called <strong>host</strong> or <strong>end system</strong>. The end system is linked by <strong>communication link</strong>(通信链路) and <strong>packet switch</strong>(分组交换机).<br>Different communication links such as <strong>电缆、光纤、无线电频谱</strong> can spread the data with different speed. The transmission rate are measured by <strong>bit&#x2F;s or bps</strong>.These message packet(信息包) are called <strong>packet</strong>(分组).<br><em>The packet seems like truck, all of the truck trans the goods to the destination by highspeed road. The communication links like the road, the packet like the truck, and the packet switch like the fork in the road, and the end system like the building.</em><br>The end system connect the Internet by <strong>ISP</strong>(Internet Service Provider).<br>The end system, packet switch and the other part of Internet are <strong>following a series of protocol</strong>(协议). <strong>These protocols control the internet message’s receive and send</strong>. Such as TCP(Transmission Control protocol，传输控制协议) and IP(Internet protocol,网际协议) are <strong>the most important protocols in the internet</strong>.IP protocol defines the rules of sending and receiving message winin router and end system.The main protocol of Internet is called <strong>TCP&#x2F;IP</strong>.<br><strong>A socket interface</strong>(套接字接口) refers to a programming interface that allows communication between different computer systems over a network. For example, you want to write a letter for your friend, you can’t just write the letter and throw it out of the window and think he&#x2F;she can receive it. You need to put the letter into the envelop and write the full name, address, and postcode of your friend. Close the envelop and post a stamp and throw it into the post office. So all of these are the socket interface of postface, you need to obey it so that you can send your letter.</p>
<h2 id="What-is-protocol"><a href="#What-is-protocol" class="headerlink" title="What is protocol?"></a>What is protocol?</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319181124581.png"><br>Let’s begin at the human protocol. If you want to  say hi to the other, you need to first say ‘hi’ and wait for his response. If he gives your certain response, you can continue say what your want. But if he does’t want to response you, you can’t continue your work.<br>Now look at the picture, you tap the web’s url. You computer send a connection request message to the Web server and wait for the respond. The Web server receives that and return a connection response message. Then the computer sends a GET message, declaring what it wants to fetch from the Web server.<br>So the protocol defines the message’s format and order between two or more than two communication entity, and sending or receiving a message or something else.</p>
<h2 id="The-media"><a href="#The-media" class="headerlink" title="The media"></a>The media</h2><p>A bit from a series of connection link and router can arrive at the other end system. Each <strong>send-receive couple</strong> send the electromagnetic and pulse through a physical media. Such as 双绞铜线，同轴电缆，多模光纤缆. The physical media has two types: the guided media and the unguided media. For the first one, The waves go along with the solid media like 光缆，双绞铜线或同轴电缆.For the other, the waves spread through air or outter space. Such as WLAN or digital satellite channels.</p>
<h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185139123.png"></p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185234778.png"></p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185333613.png"></p>
<h3 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a>陆地无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185413035.png"></p>
<h3 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319185439185.png"></p>
<h2 id="The-kernel-of-network"><a href="#The-kernel-of-network" class="headerlink" title="The kernel of network"></a>The kernel of network</h2><p>In various network application, the end system(also called host) exchanges messgae to each other. The messgae can implement a control function or contain the data. For sending a message to the destination host, the source end system cuts the long message into the little data brick. This operation called packet. Every packet can be transmited by connection link or packet switch between the source and destination. The time of transmiting is the length of bits(R) dividing the rate of connection link(R). So the time is (L&#x2F;R).</p>
<h3 id="packet-exchange"><a href="#packet-exchange" class="headerlink" title="packet exchange"></a>packet exchange</h3><p><strong>store and forward transmission</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191400491.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191419708.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191428022.png"><br><strong>The queuing delay and packet loss</strong><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191821692.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319191916889.png"><br><strong>The forwarding table and routing protocol</strong><br>The router gets the packet from a connection link linked to it, but how does it know where to trans the packet to the destination?<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319192733925.png"></p>
<h2 id="The-Internet-of-Internet"><a href="#The-Internet-of-Internet" class="headerlink" title="The Internet of Internet"></a>The Internet of Internet</h2><p>Lots of ISPs connect with each other, the low-level ISP connect to the high ISP. <strong>Peer to Peer(对等，两个运营商传输和接收尽量相同的bits，不让对方赚钱)</strong><br>IXP(Internet Exchange Point) is a meeting point, the peer ISP does’nt pay the extra fees.<br><strong>多宿(别吊死在一棵树上)</strong>:low-level ISP seeks for higher ISP to connect to make sure its capacity of connection. It can avoid the trouble caused by one of the ISP, it can use the other ISP.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319195757272.png"></p>
<h2 id="Time-Delay"><a href="#Time-Delay" class="headerlink" title="Time Delay"></a>Time Delay</h2><p>We have four types of time delay.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201045033.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319201115287.png"><br><em>dtotal &#x3D; dproc + dqueue + dtrans + dprop</em></p>
<h2 id="Five-protocols"><a href="#Five-protocols" class="headerlink" title="Five protocols"></a>Five protocols</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250319203624856.png"><br>我说张三你是帅哥，张三的身体是主机，耳朵是端口，我选择只传输给张三一个人，然后选择走哪条路（连接层就是链路层），如果他在泰国人就可以飞机过去，在国内就火车过去，电信号就通过电缆过去，最后物理层传输。</p>
<h1 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h1><p>There are two types of appliication architectures, one is <strong>client-server architecture</strong>, and the other is P2P.</p>
<h2 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h2><p>A forever-opening host is called <em>server</em>. It serves lots of other client hosts’ request. When the server receives the request for a objection form a client, it sends the objection back as the response. When we are in the client-server architecture, the client can’t communicate with the other client. Just like the two webserver can’t communicate with each other. The sever has a solid, well-known ip, and is forever-opening. So client can always send packets to the ip to communicate with it. In this system, the famous application includes the Web, FTP, Telnet and E-mail. In general, a single sever host can’t content all of the requests. So <strong>data center</strong> which has lots of hosts is used to create strong virtual server.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320113426164.png"></p>
<h2 id="Process-Communication"><a href="#Process-Communication" class="headerlink" title="Process Communication"></a>Process Communication</h2><p>In operating system, actually communicaition is a process instead of application. The processes in two different end system send message to communicate through computer network. The sending message process generates and sends the message to the net. The receiving process receives the message, and maybe send the message back to response. </p>
<h3 id="The-client-and-sever-process"><a href="#The-client-and-sever-process" class="headerlink" title="The client and sever process"></a>The client and sever process</h3><p>The web applications consist of couple of process. In Web application, a client webserver process exchanges the message with the Web server process. For each group of communication process, <strong>a process is called client, and the other is called server</strong>.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320114830448.png"></p>
<h3 id="The-process’s-interface-of-computer-network"><a href="#The-process’s-interface-of-computer-network" class="headerlink" title="The process’s interface of computer network"></a>The process’s interface of computer network</h3><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115300248.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115304351.png"></p>
<h3 id="Process-Find-Address"><a href="#Process-Find-Address" class="headerlink" title="Process Find Address"></a>Process Find Address</h3><p>If we want wo send a letter to the destination, the destination needs to have an address. A host’s process sends packet to another host’s process. We need to define two label: ①The address of host;②The destination host’s receiving process’s identifier.<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320115840795.png"></p>
<h2 id="Four-factors-of-transmission-serve"><a href="#Four-factors-of-transmission-serve" class="headerlink" title="Four factors of transmission serve"></a>Four factors of transmission serve</h2><p><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120312829.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120317239.png"><br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320120323470.png"></p>
<h2 id="Transmission-Layer-Protocol"><a href="#Transmission-Layer-Protocol" class="headerlink" title="Transmission Layer Protocol"></a>Transmission Layer Protocol</h2><p>TCP &#x2F; UDP<br>TCP和UDP之间的区别与联系：就像打电话和写信，你打电话能知道他是谁，打给谁，挂断之后即时有反馈，而写信在你寄出去的一瞬间你不能确保信是否会寄到他那里，以及什么时候才能寄到，信的内容是否完整（丢包）。UDP就是用于可以容忍一点点丢包，比如实时竞技游戏，视频通话。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>A：是B吗？我要跟你通信，听得到我说话吗？<br>B：可以通信，你听得到我说话吗？<br>A：我也听得到。</p>
<p><em>其实二次握手就可以建立链接，三次握手是为了互相确认对方的序列号，四次挥手是因为服务端有未发送完的数据。所以需要服务端连续发两次。同时客户端最后的等待也是为了确保服务端收到ASK请求fin<del>ask</del>fin~ask,如果过了等待时间则认为服务端已经关闭（没有关闭的话会有ASK）</em></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>C：我困了，先不聊了吧<br>S：还有几件事，说完我们就睡觉……<br>……（说完之后）<br>S：好了，说完了，我挂线了<br>C：好，你挂吧<br>S挂断电话<br>C说完之后就直接睡觉了，不知道电话挂没挂断，在几分钟后听到手机没有声音传来了，即使不用睁眼也知道S挂断了</p>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http(HyperText Transfer Protocol)<br>HTTP（超文本传输协议）是互联网上用来传递信息的一种规则。可以把它想象成一种通讯方式，它定义了如何发送和接收网页内容，比如文本、图片和视频等。想象一下，当你在网上浏览器里输入一个网址或点击一个链接时，你的浏览器就通过HTTP向网站的服务器发送一个请求，就像是在说：“嘿，我想看这个网页。”服务器收到这个请求后，如果网页可用，它就用同样的HTTP规则回应，发送网页的内容回来。简单来说，HTTP像是你和网站之间的对话规则，确保双方都能理解对方发送的消息。这就是你能够浏览网页和观看在线视频的原因之一。若想<strong>高效识别用户</strong>，引入了cookies，cookies就像门禁卡，我新建了一个房子，刚开始来的给一张卡刷进来，后面来的时候就拿着这张卡，网页就可以识别到你这个人做了什么。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320132409503.png"></p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>链路层协议的任何设备均成为<strong>节点</strong>，节点包括主机、路由器、交换机、和WIFI接入点。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320135508535.png"><br>数据链路层有三个重要的问题：封装成帧、差错检测、可靠传输。</p>
<h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之称为帧。<br><img src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250320140209418.png"></p>
]]></content>
  </entry>
  <entry>
    <title>FindJob</title>
    <url>/2025/03/20/FindJob/</url>
    <content><![CDATA[<h2 id="这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。"><a href="#这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。" class="headerlink" title="这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。"></a>这是一篇记录找工作学习了什么的博客，希望在未来的一年能实现。</h2><p>2025.3.20 回顾指针，常量指针，指针常量，引用，内存访问，结构体指针（地址传参和值传参）。</p>
]]></content>
  </entry>
</search>
