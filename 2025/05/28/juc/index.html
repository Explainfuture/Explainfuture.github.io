<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>juc | Explainfuture's Blog</title><meta name="author" content="Explainfuture"><meta name="copyright" content="Explainfuture"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="并发编程1.进程与线程1.进程与线程 进程   程序由指令和数据组成，指令需要运行，数据需要读写，就要将指令加载到cpu上，数据加载至内存。在指令运行过程中还需要使用磁盘，网络等设备。 进程就是用来加载指令、管理内存、管理I&#x2F;O的。 当一个程序被运行，指令代码被加载至内存，这时就开启了一个进程。 进程可以视为程序的一个实例。有些可以多开（记事本），有些只能开一个（网易云）   线程">
<meta property="og:type" content="article">
<meta property="og:title" content="juc">
<meta property="og:url" content="https://www.explainsf.com/2025/05/28/juc/index.html">
<meta property="og:site_name" content="Explainfuture&#39;s Blog">
<meta property="og:description" content="并发编程1.进程与线程1.进程与线程 进程   程序由指令和数据组成，指令需要运行，数据需要读写，就要将指令加载到cpu上，数据加载至内存。在指令运行过程中还需要使用磁盘，网络等设备。 进程就是用来加载指令、管理内存、管理I&#x2F;O的。 当一个程序被运行，指令代码被加载至内存，这时就开启了一个进程。 进程可以视为程序的一个实例。有些可以多开（记事本），有些只能开一个（网易云）   线程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.explainsf.com/image/head.jpeg">
<meta property="article:published_time" content="2025-05-28T00:44:39.000Z">
<meta property="article:modified_time" content="2025-09-07T09:55:47.696Z">
<meta property="article:author" content="Explainfuture">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.explainsf.com/image/head.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "juc",
  "url": "https://www.explainsf.com/2025/05/28/juc/",
  "image": "https://www.explainsf.com/image/head.jpeg",
  "datePublished": "2025-05-28T00:44:39.000Z",
  "dateModified": "2025-09-07T09:55:47.696Z",
  "author": [
    {
      "@type": "Person",
      "name": "Explainfuture",
      "url": "https://www.explainsf.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/image/favicon.ico"><link rel="canonical" href="https://www.explainsf.com/2025/05/28/juc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'juc',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311153314058.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/head.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250311153417995.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Explainfuture's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">juc</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">juc</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-28T00:44:39.000Z" title="发表于 2025-05-28 08:44:39">2025-05-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-07T09:55:47.696Z" title="更新于 2025-09-07 17:55:47">2025-09-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h2><h3 id="1-进程与线程-1"><a href="#1-进程与线程-1" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h3><ol>
<li>进程</li>
</ol>
<ul>
<li>程序由指令和数据组成，指令需要运行，数据需要读写，就要将指令加载到cpu上，数据加载至内存。在指令运行过程中还需要使用磁盘，网络等设备。 进程就是用来加载指令、管理内存、管理I&#x2F;O的。</li>
<li>当一个程序被运行，指令代码被加载至内存，这时就开启了一个进程。</li>
<li>进程可以视为程序的一个实例。有些可以多开（记事本），有些只能开一个（网易云）</li>
</ul>
<ol start="2">
<li>线程</li>
</ol>
<ul>
<li>一个进程之内可以有多个线程</li>
<li>一个线程就是一个指令流，是 CPU 调度的基本单位，线程按照一定顺序执行代码，多个线程可以并发地被 CPU 核心调度执行。</li>
<li>java中，线程作为最小调度单位，进程作为资源分配最小单位。</li>
</ul>
<hr>
<p>两者对比</p>
<ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li>
<li>进程间通信较为复杂<ul>
<li>同一台计算机的进程通信称为IPC(Inter-process communication) 常见的 IPC 方式包括管道（pipe）、共享内存、消息队列、socket 等。</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量<br>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h3 id="3-并行与并发"><a href="#3-并行与并发" class="headerlink" title="3.并行与并发"></a>3.并行与并发</h3><ul>
<li>并发(concurrency)：同一时间应对(dealing with)多件事情</li>
<li>并行(parallel)：同一时间动手做(doing)多件事情的能力</li>
</ul>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h3><p>同步&amp;&amp;异步调用<br>从方法调用的角度来说，如果</p>
<blockquote>
<p>类比：去奶茶店点单后站在原地等，做好了再走。 同步（调用一个方法，要等它执行完，拿到结果才能继续。）<br>类比：下单后坐下玩手机，等叫号取奶茶。 异步（调用一个方法后，不用等它完成，可以继续做别的事，结果准备好后再通知你。）</p>
</blockquote>
<h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h3><ul>
<li>单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使<br>用cpu，不至于一个线程总占用cpu，别的线程没法干活</li>
<li>多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO操作不占用cpu，只是我们一般拷贝文件使用的是【阻塞IO】，这时相当于线程虽然不用cpu，但需要一直等待IO结束，没能充分利用线程。所以才有后面的【非阻塞IO】和【异步IO】优化</li>
</ul>
<h2 id="2-Java线程"><a href="#2-Java线程" class="headerlink" title="2.Java线程"></a>2.Java线程</h2><h3 id="1-创建和运行线程"><a href="#1-创建和运行线程" class="headerlink" title="1.创建和运行线程"></a>1.创建和运行线程</h3><p>创建线程有三个方法</p>
<ol>
<li>方法一，直接创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> ()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法二，使用runnable对象，使用lambda表达式简化，可以在方法二的基础上使用alt+enter让idea自己改</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">void</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;我是线程哈哈哈&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;我是进程哈哈哈&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>使用任务和线程分开的写法好一些。</p>
<h3 id="2-原理之线程运行"><a href="#2-原理之线程运行" class="headerlink" title="2.原理之线程运行"></a>2.原理之线程运行</h3><h4 id="1-运行原理"><a href="#1-运行原理" class="headerlink" title="1.运行原理"></a>1.运行原理</h4><p>每个线程启动后，虚拟机会为其分配一块栈内存</p>
<ul>
<li>每个栈由多个栈帧组成，对应着每次方法调用使用的内存。</li>
<li>每个线程只能有一个活动栈帧。</li>
</ul>
<h4 id="2-线程上下文切换（Thread-Context-Switch）"><a href="#2-线程上下文切换（Thread-Context-Switch）" class="headerlink" title="2.线程上下文切换（Thread Context Switch）"></a>2.线程上下文切换（Thread Context Switch）</h4><ul>
<li>原因：<ul>
<li>cpu时间用完</li>
<li>垃圾回收（gc）</li>
<li>有更高优先级的线程运行</li>
<li>线程自己调用了sleep,yield,wait,join,synchronized,lock等方法</li>
</ul>
</li>
<li>当ContextSwitch发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是程序计数器(ProgramCounter Register)，它的作用是记住下一条jvm指令的执行地址，是线程私有的<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>ContextSwitch频繁发生会影响性能</li>
</ul>
</li>
</ul>
<h3 id="3-线程中的常见方法"><a href="#3-线程中的常见方法" class="headerlink" title="3.线程中的常见方法"></a>3.线程中的常见方法</h3><h4 id="run-VS-start"><a href="#run-VS-start" class="headerlink" title="run VS start"></a>run VS start</h4><ul>
<li>run()只是普通方法调用，不会并发</li>
<li><strong>start才是启动线程</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1);</span><br><span class="line">System.out.println(t1.getState());</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(t1.getState());</span><br><span class="line">t1.join();</span><br><span class="line">System.out.println(t1.getState());</span><br></pre></td></tr></table></figure>
<p>记住，start只能调用一次，会让state变为runnable。</p>
<h4 id="sleep-VS-yield"><a href="#sleep-VS-yield" class="headerlink" title="sleep VS yield"></a>sleep VS yield</h4><ul>
<li>sleep<ol>
<li>调用sleep会让当前线程从Running进入Timed Waiting状态（阻塞）</li>
<li>其它线程可以使用interrupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException</li>
<li>睡眠结束后的线程未必会立刻得到执行（不能够马上获得cpu，看线程的状态）</li>
<li>建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</li>
</ol>
</li>
<li>yield（让出，谦让）<ol>
<li>调用yield会让当前线程从Running变为runnable就绪态，然后调度执行其他线程</li>
<li>具体的实现依赖于OS<br>应用：防止CPU占用100%<br>在没有利用cpu进行计算的时候，不要让while(true)空转浪费cpu，可以使用yield或sleep让出cpu的使用权</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用wait &#x2F; 条件变量达到类似效果</li>
<li>不同的是，后两种都需要加锁，并且需要相应的唤醒(notify &#x2F; notifyall)操作，一般适用于要同步的场景<ul>
<li>wait() 必须放在 <strong>synchronized</strong> 中；</li>
<li>被 wait() 的线程会<strong>释放锁并阻塞</strong>；</li>
<li>notify() 在同一个锁对象上唤醒一个线程，notifyAll() 唤醒所有等待线程。</li>
</ul>
</li>
<li>sleep适用于无需锁同步的场景</li>
</ul>
<h4 id="interrupt-isInterrupted-interrupted"><a href="#interrupt-isInterrupted-interrupted" class="headerlink" title="interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()"></a>interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()</h4><ul>
<li>thread.interrupt();<ul>
<li>并不会立刻杀死线程！</li>
<li>它只是设置线程的“中断标志位”为 true</li>
<li>如果线程正在 sleep、wait、join 等阻塞操作，会抛出 InterruptedException 异常</li>
</ul>
</li>
<li>Thread.currentThread().isInterrupted();<ul>
<li>返回当前线程的中断状态（true&#x2F;false）</li>
<li>不会清除这个标志位</li>
</ul>
</li>
<li>Thread.interrupted(); &#x2F;&#x2F; 检查当前线程是否中断，并清除标志位<blockquote>
<p>Thread.interrupted()：“我看一下我被打断没？顺便把这事忘了”<br>isInterrupted()：“我看你有没有被打断，我不动你状态”</p>
</blockquote>
</li>
</ul>
<h5 id="拓展：设计模式（两阶段终止）"><a href="#拓展：设计模式（两阶段终止）" class="headerlink" title="拓展：设计模式（两阶段终止）"></a>拓展：设计模式（两阶段终止）</h5><blockquote>
<p>有两个线程t1和t2，t2已经完成了，t1该如何帮t2料理后事？</p>
</blockquote>
<ul>
<li>不能使用暴力stop()，因为t2可能有一些上了锁的资源，当t2被杀死后就再也没有机会释放锁，导致其它线程无法获得锁。</li>
</ul>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程是为用户线程提供服务的线程。当所有用户线程都结束时，守护线程会被 JVM 自动终止，不会阻止程序退出。</p>
<h5 id="GC-是守护线程的例子"><a href="#GC-是守护线程的例子" class="headerlink" title="GC 是守护线程的例子"></a>GC 是守护线程的例子</h5><ul>
<li>JVM 启动时会创建 GC 守护线程</li>
<li>它在后台自动运行，清理不再使用的对象</li>
<li>主线程（用户线程）结束后，GC 守护线程也会随 JVM 退出而结束</li>
<li>守护线程适合执行日志、监控、GC 等后台任务</li>
</ul>
<h2 id="3-共享模型之管程-Monitor"><a href="#3-共享模型之管程-Monitor" class="headerlink" title="3.共享模型之管程(Monitor)"></a>3.共享模型之管程(Monitor)</h2><h3 id="1-共享带来的问题"><a href="#1-共享带来的问题" class="headerlink" title="1.共享带来的问题"></a>1.共享带来的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">sout(cnt);</span><br></pre></td></tr></table></figure>
<p>不一定是0。<br>多个线程<strong>对共享资源进行读写操作</strong>，上下文交换引起的指令交错<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250528160715423.png"></p>
<ul>
<li>问题出现在多个线程访问<strong>共享资源</strong></li>
<li>一段代码块内如果存在对<strong>共享资源</strong>的多线程读写操作，称这段代码块为临界区</li>
<li>竞态条件（Race Condition）<ul>
<li>多个线程在临界区内执行，由于代码的执行顺序不同而导致结果无法预测，称之发生了<strong>静态条件</strong></li>
</ul>
</li>
</ul>
<h3 id="2-静态条件解决方案"><a href="#2-静态条件解决方案" class="headerlink" title="2.静态条件解决方案"></a>2.静态条件解决方案</h3><ul>
<li>阻塞式<ul>
<li>Synchronized、lock</li>
</ul>
</li>
<li>非阻塞式<ul>
<li>原子变量</li>
</ul>
</li>
</ul>
<h4 id="synchronized（对象锁）"><a href="#synchronized（对象锁）" class="headerlink" title="synchronized（对象锁）"></a>synchronized（对象锁）</h4><ol>
<li>语法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">    <span class="comment">//临界区代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类比说明"><a href="#类比说明" class="headerlink" title="类比说明"></a>类比说明</h5><ul>
<li>把 <code>obj</code> 想象成一个 <strong>房间</strong>，房间只有一个 <strong>门</strong>。</li>
<li>每个线程（如 <code>t1</code>、<code>t2</code>）就像是 <strong>想进房间干活的人</strong>。</li>
<li>一次只能一个线程进房间，其他线程必须在门外 <strong>排队等待</strong>。</li>
</ul>
<hr>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><ol>
<li><code>t1</code> 运行到 <code>synchronized(obj)</code><br>→ 拿到钥匙，进入房间（获得锁）<br>→ 门被锁上，其他线程进不来。</li>
<li><code>t2</code> 也运行到 <code>synchronized(obj)</code><br>→ 发现门被锁，<strong>阻塞在门外</strong>，等待钥匙。</li>
<li><code>t1</code> 时间片用完，被系统挂起<br>→ 虽然暂停了，但<strong>钥匙还在它手上</strong>（锁未释放）<br>→ <code>t2</code> 仍无法进入房间。</li>
<li><code>t1</code> 被重新调度回来<br>→ 执行完同步代码块，<strong>出门还钥匙</strong>（释放锁）<br>→ 唤醒 <code>t2</code>，<code>t2</code> 拿到钥匙进入房间继续执行。</li>
</ol>
<hr>
<h6 id="关键类比总结"><a href="#关键类比总结" class="headerlink" title="关键类比总结"></a>关键类比总结</h6><table>
<thead>
<tr>
<th>Java 概念</th>
<th>房间类比</th>
</tr>
</thead>
<tbody><tr>
<td>锁对象（如 obj）</td>
<td>房间</td>
</tr>
<tr>
<td>synchronized(obj)</td>
<td>进入房间前先锁门</td>
</tr>
<tr>
<td>获得锁</td>
<td>拿到钥匙，进入房间</td>
</tr>
<tr>
<td>阻塞线程</td>
<td>在门外排队等待钥匙</td>
</tr>
<tr>
<td>释放锁</td>
<td>出门还钥匙，唤醒别人</td>
</tr>
</tbody></table>
<h6 id="面向对象加锁"><a href="#面向对象加锁" class="headerlink" title="面向对象加锁"></a>面向对象加锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Room</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                r.Increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                r.Decrease();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        r.getCnt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Increase</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Decrease</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getCnt</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="在方法上加锁"><a href="#在方法上加锁" class="headerlink" title="在方法上加锁"></a>在方法上加锁</h6><ol>
<li>在实例上加锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在类上加锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>this 就像你家门 → 每家自己锁</li>
<li>Test.class 就像整栋楼大门 → 所有人公用<br>区别是静态方法（类对象） 非静态方法（当前实例）<br>synchronized锁的是当前实例，Test锁的是整个类<br>搜 <code>线程八锁</code>进行练习，主要分析锁住的是不是同一个对象，如果不是同一个对象，那就是并行，不存在多线程；是同一个对象，就是并发。<br>实例方法加锁锁 this，每个对象一把锁；<br>静态方法加锁锁 class，全类共用一把锁；<br>不同对象加锁不冲突，相同对象才竞争；<br>类锁和实例锁互不影响。</li>
</ul>
<h4 id="线程安全：局部变量-vs-静态变量"><a href="#线程安全：局部变量-vs-静态变量" class="headerlink" title="线程安全：局部变量 vs 静态变量"></a>线程安全：局部变量 vs 静态变量</h4><h5 id="局部变量是线程安全的"><a href="#局部变量是线程安全的" class="headerlink" title="局部变量是线程安全的"></a>局部变量是线程安全的</h5><ul>
<li>每次方法调用会创建新的栈帧</li>
<li>局部变量存放在线程独立的栈中，不共享，不冲突</li>
</ul>
<h5 id="静态变量是线程不安全的"><a href="#静态变量是线程不安全的" class="headerlink" title="静态变量是线程不安全的"></a>静态变量是线程不安全的</h5><ul>
<li>静态变量属于类，全局共享</li>
<li>多线程访问会产生数据竞争，必须加锁保护</li>
</ul>
<hr>
<h5 id="习题：银行账户转账"><a href="#习题：银行账户转账" class="headerlink" title="习题：银行账户转账"></a>习题：银行账户转账</h5><p>两个账户 <code>a</code> 和 <code>b</code>，线程 T1 从 a 转账到 b，T2 从 b 转账到 a<br>如果两个账户是不同对象，用 <code>synchronized(this)</code> 是不安全的，因为<strong>锁的是两个不同的对象</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance -= amount;</span><br><span class="line">        target.balance += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Monitor底层原理-（这里去看jvm的jmm）"><a href="#Monitor底层原理-（这里去看jvm的jmm）" class="headerlink" title="Monitor底层原理 （这里去看jvm的jmm）"></a>Monitor底层原理 （这里去看jvm的jmm）</h3><p>Monitor被翻译为<strong>监视器或管程</strong>，可以理解为提到的<strong>锁</strong></p>
<ul>
<li>第一个线程获得对象的锁后，成为owner</li>
<li>后续来的线程发现owner被占用，只能进入等待队列并切换状态为阻塞</li>
<li>当临界区代码被执行完后，owner空出，通知Monitor唤醒阻塞队列的线程，（此时的阻塞队列竞争是非公平的，不一定是先进来的就先得到锁）</li>
<li>对象总是与一个monitor相关联的<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529100222307.png"></li>
</ul>
<h3 id="notify-和wait"><a href="#notify-和wait" class="headerlink" title="notify()和wait()"></a>notify()和wait()</h3><p>在重量级锁的环境下，一个线程如果缺乏资源，就会调用wait方法<strong>主动放弃锁</strong>，进入等待池，自己的状态设置为waiting；等到别的线程将资源送来了，就会调用notify，告诉这个线程资源来了，这时候第一个线程就会离开等待池，状态变为blocking，进入锁池(EntryList)重新去竞争锁。</p>
<h3 id="park-和unpark"><a href="#park-和unpark" class="headerlink" title="park()和unpark()"></a>park()和unpark()</h3><p><code>park()</code> 和 <code>unpark()</code> 是 Java 中底层线程阻塞&#x2F;唤醒的原语，属于 <code>LockSupport</code> 类提供的工具，用于实现更灵活的并发控制（比 <code>wait/notify</code>、<code>sleep/yield</code> 更底层、更强大）。</p>
<h3 id="锁的活跃性"><a href="#锁的活跃性" class="headerlink" title="锁的活跃性"></a>锁的活跃性</h3><ul>
<li>死锁：各自持一把锁，又都想获得对方的锁，哲学家问题<br>  <strong>产生死锁的条件</strong><ul>
<li>互斥</li>
<li>占有且等待</li>
<li>不可抢占</li>
<li>循环等待 ✅ （最常通过避免循环等待解决）<br>  <strong>解决策略</strong></li>
<li>固定加锁顺序：如先锁 A 再锁 B，所有线程统一顺序，避免循环等待。</li>
<li>使用 tryLock()：尝试加锁，失败就放弃，避免永久等待。</li>
<li>死锁检测与恢复：定期检测资源等待图，发现死锁强制中断线程（一般用于数据库&#x2F;操作系统）。</li>
</ul>
</li>
<li>饥饿：线程<strong>优先级不公平</strong>、<strong>锁分配不均</strong><br>  解决策略<ul>
<li>使用 公平锁：如 <code>ReentrantLock(true)</code>，按请求顺序分配锁；</li>
<li>避免线程优先级过高差距；</li>
<li>控制资源分配策略，避免让某些线程长期得不到调度。</li>
</ul>
</li>
<li>活锁：</li>
</ul>
<h4 id="ReentrantLock-可重入锁，公平锁"><a href="#ReentrantLock-可重入锁，公平锁" class="headerlink" title="ReentrantLock(可重入锁，公平锁)"></a>ReentrantLock(可重入锁，公平锁)</h4><ol>
<li>优点</li>
</ol>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁</li>
<li>支持多个条件变量（所有条件满足了才从waitSet出来去锁池）<blockquote>
<p>与synchronized一样支持<strong>可重入</strong></p>
</blockquote>
</li>
</ul>
<ol start="2">
<li>可重入</li>
</ol>
<ul>
<li>“ReentrantLock 可重入指的是一个线程可以多次加锁而不阻塞自己，内部通过记录持有线程和重入计数来实现，类似 synchronized 的行为。”</li>
</ul>
<ol start="3">
<li>语法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">fairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 非公平锁（默认）</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">unfairLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>条件变量</li>
</ol>
<ul>
<li>用于线程间通信，代替 wait() 和 notify()；</li>
<li>支持多个等待队列（更细粒度的控制）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ReentrantLock + Condition：可以为不同条件建多个等待队列（每个condition内部有一个独立的等待队列）</p>
<ol start="5">
<li>锁超时</li>
<li>总结</li>
</ol>
</blockquote>
<ul>
<li>ReentrantLock 是显式锁，功能强于 synchronized；</li>
<li>支持更细粒度的锁策略；</li>
<li>搭配 Condition 可实现更复杂的线程通信模型；</li>
<li><strong>需手动释放锁，推荐 try-finally 结构</strong>。</li>
</ul>
<h2 id="4-共享模型之不可变"><a href="#4-共享模型之不可变" class="headerlink" title="4.共享模型之不可变"></a>4.共享模型之不可变</h2><ol>
<li>什么是Java中的不可变类</li>
</ol>
<ul>
<li>不可变类是指无法修改对象的值（<strong>无法继承、线程安全</strong>），String不可变<ul>
<li>追问：怎么实现不可变类？<ul>
<li>通过看String的源码，String添加了final(类似于cpp的const)关键字，并且是private对象</li>
<li>替换方法replace()的实现是返回一个新的字符串。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-并发工具"><a href="#5-并发工具" class="headerlink" title="5.并发工具"></a>5.并发工具</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="1-ThreadPoolExcutor"><a href="#1-ThreadPoolExcutor" class="headerlink" title="1.ThreadPoolExcutor"></a>1.ThreadPoolExcutor</h4><ol>
<li>线程池状态<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529164801644.png" alt="线程池状态"></li>
</ol>
<ul>
<li>五状态：Running、Shutdown、Stop、Tidying、Terminated<br>Shutdown就像终结对方的连胜，但不代表这局游戏结束咯。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529165203047.png"><br>数字比较，是有符号数，最高位为-4，也可以去看ThreadPoolExecutor的源码</li>
</ul>
<ol start="2">
<li>线程池构造方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250529165901446.png" alt="线程池构造方法"></li>
</ol>
<ul>
<li>corePoolSize核心线程数目：<strong>线程池中常驻的线程数。</strong></li>
<li>maximumPoolSize最大线程数目：线程池中允许创建的最大线程数。</li>
<li>keepAliveTime线程存活时间：非核心线程空闲多久被回收。</li>
<li>unit时间单位-针对救急线程</li>
<li>workQueue阻塞队列：<strong>用于缓存待执行任务的阻塞队列</strong>，如 LinkedBlockingQueue。</li>
<li>threadFactory线程工厂-可以为线程创建时起个好名字</li>
<li>handler拒绝策略：线程池满时的拒绝策略<blockquote>
<p>最大线程数 &#x3D; 核心线程数 + 救急线程数</p>
</blockquote>
</li>
<li>核心线程和救急线程的区别？<ul>
<li>核心线程在任务执行完成后仍留在线程池中，救急线程执行完后会离开线程池。（外包）</li>
</ul>
</li>
<li>如果系统面临高并发，你会怎样去配置线程池？<ul>
<li>如果任务是<strong>CPU密集型</strong>（如计算型服务），线程数设为<code>CPU核心数+1</code>，使用无界队列，避免上下文切换；因为计算型服务几乎不进行IO操作，CPU使用频率很高，增加过多线程反而会导致频繁进行上下文切换，反而拖延性能，多加一个线程是为了应对线程调度或偶尔阻塞的情况。</li>
<li>如果任务是<strong>IO密集型</strong>（如网络请求，数据库读写），可设置更多线程，如 <code>2 * CPU核心数</code>，配合适当长度的阻塞队列；因为IO密集型任务经常阻塞，线程会空闲，多设置一些线程来保证CPU有任务执行，线程看起来很多，但由于很多都处于阻塞，所以不会频繁进行上下文切换。<blockquote>
<p>所以本质上，线程池线程数的设置要根据任务的“阻塞程度”和“CPU占用率”做平衡。</p>
</blockquote>
</li>
<li>拒绝策略方面，如果系统不能丢任务，可使用 CallerRunsPolicy 让主线程帮忙执行，降低系统负载；</li>
<li>队列类型上，对于高并发请求建议使用 LinkedBlockingQueue 或 ArrayBlockingQueue 来控制流量和内存使用。</li>
</ul>
</li>
<li>线程池的执行策略<ol>
<li>如果任务数小于核心线程数，分配一个线程去处理任务</li>
<li>如果任务数大于核心线程数，进入阻塞队列等待</li>
<li>如果任务数大于核心线程数并且阻塞队列已满，创建救急线程去处理任务</li>
<li>如果救急线程数+核心线程数大于最大线程数，执行拒绝策略</li>
</ol>
</li>
</ul>
<h4 id="2-Fork-Join"><a href="#2-Fork-Join" class="headerlink" title="2.Fork&#x2F;Join"></a>2.Fork&#x2F;Join</h4><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h4 id="1-AQS"><a href="#1-AQS" class="headerlink" title="1.AQS"></a>1.AQS</h4><p>全称是：AbstractQueuedSynchronized，是<strong>阻塞式锁</strong>和相关的同步器工具的框架<br><strong>AQS 就是一套模板机制，你通过实现它的几个抽象方法，就可以“自定义一把锁”或“同步器”</strong></p>
<ul>
<li>特点：<ul>
<li>用<code>state</code>属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获得锁和释放锁<ul>
<li>getState：获取state状态</li>
<li>setState：设置state状态</li>
<li>compareAndSetState：乐观锁机制设置state状态</li>
<li>独占模式只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>基于FIFO的等待队列，类似于monitor的Entrylist</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor 的 WaitSet</li>
</ul>
</li>
<li>子类要实现下列方法<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
</li>
<li>并发工具类：是一个能让多个线程安全的去访问共享资源的一个工具，每个线程访问的时候要去<strong>判断</strong>当前共享资源是否被占用，是否正在被访问；如果没有线程访问，那当前线程就可以访问；如果当前资源被访问了，要么<strong>重试</strong>，要么<strong>阻塞</strong>，要么<strong>放弃</strong>。</li>
<li>如何表示共享资源当前正在被访问呢？<ul>
<li>状态变量。为0时表示空闲，为1时表示被占有，同样是Reentrantlock的思想</li>
<li>公平策略：AQS是基于FIFO的队列设计的，只需要重写tryAcquire方法就可以自定义公平&#x2F;非公平策略了</li>
</ul>
</li>
<li>Reentrantlock和Synchronized有什么区别？<ul>
<li>Reentrantlock基于FIFO实现了公平锁和非公平锁；而Synchronized都是非公平</li>
</ul>
</li>
</ul>
<h4 id="2-Reentrantlock"><a href="#2-Reentrantlock" class="headerlink" title="2.Reentrantlock"></a>2.Reentrantlock</h4><ul>
<li>类型：独占、可重入、支持公平&#x2F;非公平</li>
<li>关键 AQS 方法：tryAcquire() &#x2F; tryRelease()</li>
<li>state 表示：当前线程持有锁的次数（支持递归加锁）</li>
<li>典型用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3.Semaphore"></a>3.Semaphore</h4><ul>
<li>类型：共享锁</li>
<li>关键 AQS 方法：tryAcquireShared() &#x2F; tryReleaseShared()</li>
<li>state 表示：剩余可用许可数量</li>
<li>典型用法：限流、连接池并发控制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire();   <span class="comment">// 获取许可</span></span><br><span class="line">semaphore.release();   <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure>

<h4 id="4-CountDownLatch-（倒计时锁）"><a href="#4-CountDownLatch-（倒计时锁）" class="headerlink" title="4.CountDownLatch （倒计时锁）"></a>4.CountDownLatch （倒计时锁）</h4><ul>
<li>类型：共享同步器（不可重置）</li>
<li>关键 AQS 方法：tryAcquireShared()（为 0 才通过） &#x2F; tryReleaseShared()</li>
<li>state 表示：倒计时数量</li>
<li>典型用法：等待多个线程完成后再执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">latch.countDown(); <span class="comment">// 调用 3 次后 latch.await() 才能继续，countDown计数--</span></span><br><span class="line">latch.await(); <span class="comment">//等待计数归零</span></span><br></pre></td></tr></table></figure>

<h4 id="5-ReentrantReadWriteLock"><a href="#5-ReentrantReadWriteLock" class="headerlink" title="5.ReentrantReadWriteLock"></a>5.ReentrantReadWriteLock</h4><ul>
<li>类型：读锁共享，写锁独占</li>
<li>关键点：<ul>
<li>写锁使用 tryAcquire()，互斥；</li>
<li>读锁使用 tryAcquireShared()，可多个同时获取；</li>
</ul>
</li>
<li>state 表示：高 16 位写锁计数，低 16 位读锁计数（位运算拆解）</li>
<li>典型用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readLock.lock();   <span class="comment">// 多线程可以同时读</span></span><br><span class="line">writeLock.lock();  <span class="comment">// 写操作互斥，读写互斥</span></span><br></pre></td></tr></table></figure>

<h4 id="6-FutureTask"><a href="#6-FutureTask" class="headerlink" title="6.FutureTask"></a>6.FutureTask</h4><ul>
<li>类型：任务状态控制器（封装线程执行结果）</li>
<li>关键 AQS 方法：用独占锁管理任务执行与等待线程；</li>
<li>state 表示：任务状态（NEW、RUNNING、COMPLETED）</li>
<li>典型用法：配合线程池异步获取结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">task.get(); <span class="comment">// 等待并获取结果</span></span><br></pre></td></tr></table></figure>

<h1 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h1><h2 id="那请你说说：synchronized-和-ReentrantLock-有什么区别？你在什么场景下会选择用-ReentrantLock-而不是-synchronized？"><a href="#那请你说说：synchronized-和-ReentrantLock-有什么区别？你在什么场景下会选择用-ReentrantLock-而不是-synchronized？" class="headerlink" title="那请你说说：synchronized 和 ReentrantLock 有什么区别？你在什么场景下会选择用 ReentrantLock 而不是 synchronized？"></a>那请你说说：synchronized 和 ReentrantLock 有什么区别？你在什么场景下会选择用 ReentrantLock 而不是 synchronized？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picbedex.oss-cn-shenzhen.aliyuncs.com/20250610132655010.png"><br>从语法层面上说，synchronized是关键字，而Reentrantlock是concurrent包里提供的，reentrantlock可以中断，不会傻等，也支持trylock()尝试加锁，也可以设置公平&#x2F;非公平锁，可以配合<strong>条件变量</strong>进行使用，需要手动lock和unlock。</p>
<ul>
<li>如果只是简单的同步代码块或方法，用 synchronized 更方便；</li>
<li>如果需要 <code>中断等待、限时尝试加锁、公平策略或多个条件等待队列</code>，就必须用 ReentrantLock，它更灵活、可控。</li>
<li>比如我做订单超卖防止时，需要加锁保护共享资源。我如果只是简单保证线程安全，会直接用 synchronized；但如果我要限制等待时间，或者希望后来的线程也有公平机会执行，就会选择 ReentrantLock 并配合 tryLock() 或 lockInterruptibly() 实现更复杂的并发控制逻辑。</li>
<li>ReentrantLock.lockInterruptibly() 允许在等待锁的过程中被中断，是<strong>处理超时等待、线程池任务超时取消、避免死锁</strong>等高级并发场景非常实用的手段。而 synchronized 不支持中断，一旦等待只能卡住。</li>
</ul>
<h2 id="什么是ABA问题？如何解决？"><a href="#什么是ABA问题？如何解决？" class="headerlink" title="什么是ABA问题？如何解决？"></a>什么是ABA问题？如何解决？</h2><ul>
<li>ABA 问题指的是：一个变量原本是 A，线程1 读取后准备操作；但此时线程2 把它改成了 B，然后又改回 A。当线程1 继续用 CAS 比较时，会误以为这个变量从未被修改，其实已经发生过变化，导致潜在的并发安全问题。</li>
<li>解决方法：加版本号；它在变量的基础上加一个版本号，每次修改时版本号递增，CAS 时比较的不只是值，还有版本；</li>
</ul>
<h2 id="Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？"><a href="#Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？" class="headerlink" title="Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？"></a>Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？</h2><ul>
<li>Java中的线程池是通过ThreadPoolExcutor实现的，当调用.execute(task)的时候，线程池会按以下步骤执行<ol>
<li>线程核心未满？-&gt;分配一个核心线程执行任务</li>
<li>核心线程满了，队列没满？-&gt;放进任务队列<code>workQueue</code>等待执行</li>
<li>队列也满了，但是最大线程数还没满？-&gt;创建一个<strong>救急线程</strong>来执行</li>
<li>连最大线程数也满了？-&gt;执行拒绝策略，抛出异常</li>
</ol>
</li>
</ul>
<h2 id="I-O多路复用是什么？"><a href="#I-O多路复用是什么？" class="headerlink" title="I&#x2F;O多路复用是什么？"></a>I&#x2F;O多路复用是什么？</h2><ul>
<li>I&#x2F;O 多路复用是指：通过一个线程同时监听多个 <strong>I&#x2F;O 事件（比如 socket 连接、读写等）</strong>，一旦有事件发生就去处理，<strong>避免为每个连接开一个线程，大大提高了并发性能和资源利用率。</strong></li>
</ul>
<h1 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h1><ul>
<li>不使用Executor创建<ol>
<li>FixedThreadPool和SingleThreadPool允许的阻塞队列长度为<code>Integer.MAX_VALUE</code>，会导致OOM</li>
<li>CachedThreadPool允许创建的线程数量为<code>Integer.MAX_VALUE</code>，也会导致OOM</li>
</ol>
</li>
<li>四种拒绝策略<ul>
<li>AbortPolicy：如果任务数超过了阻塞队列，直接拒绝执行</li>
<li>CallerRunsPolicy：由提交线程池任务的线程来运行</li>
<li>DiscardPolicy：直接丢弃新来的任务</li>
<li>DiscardOldestPolicy：丢弃队列里最老的任务，尝试执行当前任务</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.explainsf.com">Explainfuture</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.explainsf.com/2025/05/28/juc/">https://www.explainsf.com/2025/05/28/juc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.explainsf.com" target="_blank">Explainfuture's Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/image/head.jpeg" data-sites="wechat,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/27/jvm/" title="jvm"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">jvm</div></div><div class="info-2"><div class="info-item-1">什么是JVM? 定义：Java Virtual Machine java程序的运行环境（更确切：java二进制字节码的运行环境） 好处： 一次编写，到处运行的基石（跨平台） 自动内存管理，垃圾回收功能（垃圾回收处理堆内存的无用对象） 数组下标越界检查 多态   比较：Jvm Jre Jdk的关系  JVM的内存结构程序计数器（PC）1. 定义 Program Counter Register 使用寄存器实现  2. 作用： 记住下一条jvm指令的执行地址  3. 特点： 线程私有：每一个线程都是独立的，都有自己的时间片，以及自己的程序计数器 不会存在内存溢出  虚拟机栈1. 定义（java virtual machine stacks） 每个线程运行时所需要的内存称为虚拟机栈，线程私有 栈由多个栈帧（Frame）组成，每个栈帧对应一次方法调用。 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法（人话：栈顶）  2. 问题辨析： 垃圾回收是否涉及栈内存？ 不涉及。虚拟机栈随着方法调用自动创建和销毁，不由 GC...</div></div></div></a><a class="pagination-related" href="/2025/05/30/RocketMQ/" title="RocketMQ"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">RocketMQ</div></div><div class="info-2"><div class="info-item-1">实际开发：短信分发，第一次进行预处理 用三个消息队列分别存储 ： 移动&#x2F;联通&#x2F;电信的号码 RocketMQMQ概述MQ ： Message Queue 消息队列，是在消息传输过程中保存消息的容器 1.优势 应用解耦   耦合度：指的是模块或组件之间的依赖程度。耦合度越高，容错越低。 防止消费者&#x2F;生产者某一方崩了导致整个流程崩溃。  提高系统容错性以及可维护性     异步提速   生产方发完消息，可以继续下一步业务逻辑。 提升用户体验和系统吞吐量     削峰填谷相当于数据先打到缓存中，然后消费者从缓存中拿数据，而不是直接打到消费者，如果1w&#x2F;s打到物流系统会崩溃 提高系统稳定性    2.劣势 系统可用性降低   如果MQ崩了，就会对业务造成影响。 如何保障MQ的高可用？     系统复杂度提高如何保障消息没有被重复消费，如何处理信息丢失，如何保障信息传递的顺序性 一致性问题A处理完业务通过MQ发给BCD，BC都成功处理，那D处理失败，如何保障消息处理数据的一致性？  RocketMQ 工作原理总结RocketMQ...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/image/head.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Explainfuture</div><div class="author-info-description">这是一个计科学生终于开始学东西的记录网站</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Explainfuture"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Explainfuture" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lcc@hnu.edu.cn" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.进程与线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">3.并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">4.应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%93%E8%AE%BA"><span class="toc-number">1.1.4.</span> <span class="toc-text">5.结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Java%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2.Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.创建和运行线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.原理之线程运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.运行原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88Thread-Context-Switch%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.线程上下文切换（Thread Context Switch）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.线程中的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#run-VS-start"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">run VS start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-VS-yield"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">sleep VS yield</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt-isInterrupted-interrupted"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">interrupt() &amp;&amp; isInterrupted() &amp;&amp; interrupted()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%EF%BC%89"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">拓展：设计模式（两阶段终止）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">守护线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#GC-%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">GC 是守护线程的例子</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B-Monitor"><span class="toc-number">1.3.</span> <span class="toc-text">3.共享模型之管程(Monitor)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.共享带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%9D%A1%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.静态条件解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%EF%BC%88%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%89"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">synchronized（对象锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">类比说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.2.1.2.1.</span> <span class="toc-text">关键类比总结</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8A%A0%E9%94%81"><span class="toc-number">1.3.2.1.2.2.</span> <span class="toc-text">面向对象加锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A%E5%8A%A0%E9%94%81"><span class="toc-number">1.3.2.1.2.3.</span> <span class="toc-text">在方法上加锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F-vs-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">线程安全：局部变量 vs 静态变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">局部变量是线程安全的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">静态变量是线程不安全的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98%EF%BC%9A%E9%93%B6%E8%A1%8C%E8%B4%A6%E6%88%B7%E8%BD%AC%E8%B4%A6"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">习题：银行账户转账</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%EF%BC%88%E8%BF%99%E9%87%8C%E5%8E%BB%E7%9C%8Bjvm%E7%9A%84jmm%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">Monitor底层原理 （这里去看jvm的jmm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E5%92%8Cwait"><span class="toc-number">1.3.4.</span> <span class="toc-text">notify()和wait()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#park-%E5%92%8Cunpark"><span class="toc-number">1.3.5.</span> <span class="toc-text">park()和unpark()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">1.3.6.</span> <span class="toc-text">锁的活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%8C%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">ReentrantLock(可重入锁，公平锁)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.4.</span> <span class="toc-text">4.共享模型之不可变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.5.</span> <span class="toc-text">5.并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.5.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ThreadPoolExcutor"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">1.ThreadPoolExcutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Fork-Join"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">2.Fork&#x2F;Join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC"><span class="toc-number">1.5.2.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AQS"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">1.AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Reentrantlock"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">2.Reentrantlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Semaphore"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">3.Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-CountDownLatch-%EF%BC%88%E5%80%92%E8%AE%A1%E6%97%B6%E9%94%81%EF%BC%89"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">4.CountDownLatch （倒计时锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-ReentrantReadWriteLock"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5.ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-FutureTask"><span class="toc-number">1.5.2.6.</span> <span class="toc-text">6.FutureTask</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">面试准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%EF%BC%9Asynchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BD%A0%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BC%9A%E9%80%89%E6%8B%A9%E7%94%A8-ReentrantLock-%E8%80%8C%E4%B8%8D%E6%98%AF-synchronized%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">那请你说说：synchronized 和 ReentrantLock 有什么区别？你在什么场景下会选择用 ReentrantLock 而不是 synchronized？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFABA%E9%97%AE%E9%A2%98%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">什么是ABA问题？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BD%93%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%BB%99%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">Java线程池的工作原理是什么？当一个新任务提交给线程池时，线程池是如何处理的？整个流程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">I&#x2F;O多路复用是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="toc-number">3.</span> <span class="toc-text">线程池</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/Redis%E5%A4%8D%E7%9B%98/" title="Redis复盘">Redis复盘</a><time datetime="2025-09-11T11:46:55.000Z" title="发表于 2025-09-11 19:46:55">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/11/FastAPI/" title="FastAPI">FastAPI</a><time datetime="2025-09-11T01:18:13.000Z" title="发表于 2025-09-11 09:18:13">2025-09-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/19/%E9%9D%A2%E8%AF%95%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%E7%82%B9/" title="面试补充知识点">面试补充知识点</a><time datetime="2025-08-19T08:20:00.000Z" title="发表于 2025-08-19 16:20:00">2025-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/11/netty/" title="Netty">Netty</a><time datetime="2025-08-11T06:33:20.000Z" title="发表于 2025-08-11 14:33:20">2025-08-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/05/SpringCloud/" title="SpringCloud">SpringCloud</a><time datetime="2025-08-05T11:29:03.000Z" title="发表于 2025-08-05 19:29:03">2025-08-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/image/bg.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Explainfuture</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div><div class="footer_custom_text">良辰美景奈何天。<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="请输入关键字" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>